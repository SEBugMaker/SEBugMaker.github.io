<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>An Empirical Study on the Usage of Transformer Models for Code Completion | Rain's Blog</title><meta name="author" content="Rain Sun"><meta name="copyright" content="Rain Sun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="代码补全相关论文 An Empirical Study on the Usage of Transformer Models for Code Completion 代码补全技术大多在预测下一个token的场景中进行评估，只有少数例外扩展到了预测整个代码语句。因此，对于最先进的代码补全方法在更具挑战性的场景中（例如必须生成整个代码块）性能知之甚少。 作者进行了大规模研究，探索了最先进的基于 Tr">
<meta property="og:type" content="article">
<meta property="og:title" content="An Empirical Study on the Usage of Transformer Models for Code Completion">
<meta property="og:url" content="http://sebugmaker.github.io/posts/c22f54fd.html">
<meta property="og:site_name" content="Rain&#39;s Blog">
<meta property="og:description" content="代码补全相关论文 An Empirical Study on the Usage of Transformer Models for Code Completion 代码补全技术大多在预测下一个token的场景中进行评估，只有少数例外扩展到了预测整个代码语句。因此，对于最先进的代码补全方法在更具挑战性的场景中（例如必须生成整个代码块）性能知之甚少。 作者进行了大规模研究，探索了最先进的基于 Tr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://box.nju.edu.cn/f/49fb0997934545dbae83/?dl=1">
<meta property="article:published_time" content="2024-05-24T14:44:39.000Z">
<meta property="article:modified_time" content="2024-05-28T11:21:54.043Z">
<meta property="article:author" content="Rain Sun">
<meta property="article:tag" content="Code Completion">
<meta property="article:tag" content="Transformer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://box.nju.edu.cn/f/49fb0997934545dbae83/?dl=1"><link rel="shortcut icon" href="https://box.nju.edu.cn/f/02da4b126cc04fd4951f/?dl=1"><link rel="canonical" href="http://sebugmaker.github.io/posts/c22f54fd.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'An Empirical Study on the Usage of Transformer Models for Code Completion',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-28 19:21:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/myhead.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body>
    <div id='loader'>
        
            <div class="loading-left-bg"></div>
            <div class="loading-right-bg"></div>
            <div class="spinner-box">
                <div class="configure-border-1">
                    <div class="configure-core"></div>
                </div>
                <div class="configure-border-2">
                    <div class="configure-core"></div>
                </div>
                <div class="loading-word">加载中...</div>
            </div>
        
    </div>

    <script>
        var endLoading = function () {
            document.body.style.overflow = 'auto';
            document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
<div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/8618b667f75848d78fe7/?dl=1" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/intro/"><i class="fa-fw fa fa-address-card"></i><span> Intro</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://box.nju.edu.cn/f/49fb0997934545dbae83/?dl=1')"><nav id="nav"><span id="blog-info"><a href="/" title="Rain's Blog"><span class="site-name">Rain's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/intro/"><i class="fa-fw fa fa-address-card"></i><span> Intro</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">An Empirical Study on the Usage of Transformer Models for Code Completion</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-24T14:44:39.000Z" title="发表于 2024-05-24 22:44:39">2024-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-28T11:21:54.043Z" title="更新于 2024-05-28 19:21:54">2024-05-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E8%AE%BA%E6%96%87/">读论文</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="An Empirical Study on the Usage of Transformer Models for Code Completion"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="代码补全相关论文-an-empirical-study-on-the-usage-of-transformer-models-for-code-completion"><a class="markdownIt-Anchor" href="#代码补全相关论文-an-empirical-study-on-the-usage-of-transformer-models-for-code-completion"></a> 代码补全相关论文 An Empirical Study on the Usage of Transformer Models for Code Completion</h1>
<p>代码补全技术大多在预测下一个token的场景中进行评估，只有少数例外扩展到了预测整个代码语句。因此，对于最先进的代码补全方法在更具挑战性的场景中（例如必须生成整个代码块）性能知之甚少。</p>
<p>作者进行了大规模研究，探索了最先进的基于 Transformer 的模型在支持不同粒度级别代码补全方面的能力，包括单个token、一条或多条完整语句，甚至整个代码块（例如 for 循环的迭代块）。我们在代码补全任务中实验了两种基于 Transformer 模型的几种变体，即 RoBERTa 和 Text-To-Text Transfer Transformer（T5）。结果显示，基于 Transformer 的模型，特别是 T5，是代码补全的可行解决方案，其最佳预测率（perfect prediction）从要求模型猜测整个代码块时的约 29% 到在较简单的场景中（从同一代码语句中掩盖[masked]少量标记）的约 69%。</p>
<h1 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h1>
<p>尽管代码补全技术的性能随着时间的推移有了显著提升，但它们对开发者提供的支持类型并没有同等速度地提升。事实上，除了少数几个关注于预测多个代码tokens或甚至预测整个语句的工作外，文献中提出的大多数方法仅在特定场景中进行了实验，即预测开发者可能输入的下一个token。这就留下了一个问题：<mark>基于深度学习的token预测能够达到什么程度（甚至超越源代码行的边界）？</mark></p>
<p>作者展开了一项大规模实证研究，探索最先进的深度学习模型支持的代码补全的局限性和能力。除了生成开发者可能编写的下一个token之外，作者还应用深度学习模型来生成整个语句和代码块（例如 if 语句的主体）。众多深度学习模型中，作者重点关注使用 Transformer 架构的模型。 特别是，在作者最近在 MSR 2021 上发表的工作中，作者评估了 RoBERTa 模型在上述代码完成任务中的性能。RoBERTa 是使用特殊的 &lt;MASK&gt; 标记屏蔽输入句子中的随机单词，其中模型负责预测屏蔽单词来进行预训练任务的BERT（来自 Transformers 的双向编码器表示）模型。</p>
<p>在尝试使用 RoBERTa 完成代码完成任务时，面临一个<mark>重要的限制</mark>，该限制使其不适合研究（即多个屏蔽标记的预测）：在 RoBERTa 预训练任务中，n 个&lt;MASK&gt; token 必须用于mask n 个代码token，从而隐式向模型建议必须生成多少代码标记才能自动完成屏蔽语句。这在实际使用场景中是不现实的，即代码补全引擎必须猜测（guess）要生成的token，不需要开发者建议必须生成多少个令牌。为了<mark>克服这一限制</mark>，我们必须调整 RoBERTa 的预训练目标，使其能够从单个 &lt;MASK&gt; token（mask给定语句中的一个或多个代码token）中猜测出需要生成哪些代码token以及生成多少代码token。这种调整受最近提出的T5架构的影响，说明T<mark>5架构适合于代码补全任务</mark>。</p>
<p>在这项工作中，作者拓展了他们的 MSR 2021 论文，表明 T5 大大超越了 RoBERTa 模型的性能，甚至能够正确预测整个代码块，这是 RoBERTa 无法实现的。正如作者在MSR 2021那篇论文中所示，作者关注<mark>三种代码预测场景</mark>：（i）token-level预测，即经典代码补全，其中模型用于预测开发人员开始编写的语句中的最后 n 个token； (ii) construct-level预测，其中模型用于预测特定的代码构造（例如 if 语句的条件），这对开发人员在编写代码时特别有用； (iii) block-level预测，屏蔽代码跨越构成代码块的一个或多个完整语句（例如，for 循环的迭代块）。</p>
<p>作者比较了几种模型的性能。 首先，我们使用之前的论文中提出的 RoBERTa 模型作为类 BERT 模型的代表。 其次，本文首次使用T5模型来完成代码补全任务。 最近的研究表明，T5 在代码相关任务中的性能优于许多最先进的技术。 最近的论文展示了训练单个 T5 模型处理四个与代码相关的任务的可能性，即错误修复、代码突变体注入、断言语句生成和代码摘要。 第三，作者用 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32829048">n-gram 模型</a>作为基于深度学习的模型的baseline进行实验，也展示了 Hellendoorn 和 Devanbu 提出的缓存机制对其性能的影响。</p>
<p>RoBERTa 和 T5 模型都分两个阶段进行训练</p>
<ol>
<li>
<p>预训练</p>
<p>允许定义可用于一大类sequence-to-sequence任务的共享知识库（例如，猜测英语句子中的掩码词[masked words]以了解该语言）</p>
</li>
<li>
<p>微调</p>
<p>专门针对特定下游任务的模型（例如，学习从英语到德语的句子翻译）。微调中也能使用多个任务来尽可能利用迁移学习（transfer learning），即模型可以将在一项任务中获取的知识重用于另一项任务。</p>
<p>例如，在多个翻译任务（例如，从英语到德语、英语到法语、法语到德语）上训练的单个模型可能比分别在特定翻译任务（例如，英语到德语）上训练的三个不同模型更有效。</p>
</li>
</ol>
<p>作者希望通过研究预训练任务和跨不同任务的迁移学习对模型性能所起的作用来研究两种基于 Transformer 的模型的性能。 然而，由于这需要对实验模型的许多不同变体进行训练，因此我们采用以下策略：</p>
<ol>
<li>通过针对我们的三种代码完成场景（即token-level级、construct-level级和block-level级）训练三种不同的模型来比较 RoBERTa 和 T5。 这意味着创建三个不同的 RoBERTa 和 T5 模型（总共六个模型）。</li>
<li>选择表现最好的一个（T5），使用预训练可以提高其性能，尽管影响有限。</li>
<li>作者展示了微调单个 T5 模型以支持所有三个预测任务可以提高性能，从而确认三个非常相似的任务之间的迁移学习（即在一项任务中获得的知识可以用于执行另一项任务）。</li>
</ol>
<p>所取得的结果表明，对于典型的代码补全任务（即token-level级别），T5在66%到 69%的情况下正确预测所有masked token（取决于所使用的数据集），而RoBERTa 的正确率达到39%到52%，n-gram模型为42%到44%。</p>
<p>值得注意的是，研究的目的并不是要证明 T5 模型是基于神经（neural-based）的代码补全的最佳选择。 工作重点是实证探索基于学习（learning-based）的代码补全技术的能力，T5、RoBERTa 和 n-gram 模型被选为最先进的模型代表。</p>
<p>综上所述，与 MSR 2021 论文相比，这项工作的贡献如下：</p>
<ol>
<li>作者使用另一种最先进的方法（即 T5 模型）进行了全面的实证研究，显示了其在代码完成任务方面非常有前途的性能；</li>
<li>与先前的论文不同，其中三种不同的 RoBERTa 模型在三种代码完成场景（即token-level级、construct-level级和block-level级）上进行了微调，无需预训练，也无需测试迁移学习的影响，我们预训练并微调性能最佳模型的几个版本（即 T5），以研究这些方面；</li>
<li>对于表现最佳的模型，作者还探索了利用预测置信度作为预测质量衡量标准的可能性，显示了该指标的可靠性。</li>
</ol>
<h1 id="research-questions-and-context"><a class="markdownIt-Anchor" href="#research-questions-and-context"></a> Research Questions And Context</h1>
<p>研究目标是评估基于 Transformer 的深度学习模型在预测不同粒度级别的masked code tokens方面的有效性。 有以下研究问题 (RQ)：</p>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><msub><mi>Q</mi><mn>1</mn></msub><mo>:</mo><mi>T</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">模</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">多</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">程</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">种</mi><mi mathvariant="normal">学</mi><mi mathvariant="normal">习</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">何</mi><mi mathvariant="normal">自</mi><mi mathvariant="normal">动</mi><mi mathvariant="normal">补</mi><mi mathvariant="normal">全</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">码</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">？</mi></mrow><annotation encoding="application/x-tex">RQ_1:Transformer 模型在多大程度上是一种学习如何自动补全代码的可行方法？</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">种</span><span class="mord cjk_fallback">学</span><span class="mord cjk_fallback">习</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">何</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">动</span><span class="mord cjk_fallback">补</span><span class="mord cjk_fallback">全</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">？</span></span></span></span></p>
<p>研究T5和RoBERTa可用于预测丢失代码token的程度。 作者从定量（即BLEU得分 、Levenshtein距离）和定性（即完美预测、错误预测的潜在有用性）角度评估生成的预测的质量。 RQ1在以下两个子RQ中进一步详细说明：</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><msub><mi>Q</mi><mn>1.1</mn></msub><mo>:</mo><mi>m</mi><mi>a</mi><mi>s</mi><mi>k</mi><mi>e</mi><mi>d</mi><mtext> </mtext><mi>t</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">多</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">程</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">影</mi><mi mathvariant="normal">响</mi><mi mathvariant="normal">预</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">质</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">？</mi></mrow><annotation encoding="application/x-tex">RQ_{1.1}:masked\ token的数量在多大程度上影响预测质量？</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">影</span><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">预</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">质</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">？</span></span></span></span>​</p>
<p>在数据集上训练和测试实验的方法，其中masked code token涵盖从给定语句中的几个连续token到构成代码块的多个缺失语句。 RQ1.1探讨Transformer 模型在考虑简单和更具挑战性的代码补全场景时的局限性。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><msub><mi>Q</mi><mn>1.2</mn></msub><mo>:</mo><mi mathvariant="normal">模</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">多</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">程</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">受</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">训</mi><mi mathvariant="normal">练</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">训</mi><mi mathvariant="normal">练</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">殊</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">影</mi><mi mathvariant="normal">响</mi><mi mathvariant="normal">？</mi></mrow><annotation encoding="application/x-tex">RQ_{1.2}:模型的性能在多大程度上受到用于训练和训练的数据集的特殊性的影响？</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">受</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">训</span><span class="mord cjk_fallback">练</span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">训</span><span class="mord cjk_fallback">练</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">殊</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">影</span><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">？</span></span></span></span>​</p>
<p>虽然可以合理地预期更大的训练数据集往往有助于深度学习模型，但作者从不同的角度回答 RQ1.2。</p>
<p>比较了两个不同数据集上的自动完成性能：第一个是更通用的，由 Java 方法组成； 第二个更具体，由 Android 应用程序的方法组成。虽然编程语言相同，两个数据集的粒度相同（即方法级粒度），但是第二个数据集中的方法大量使用 Android API，并且相同的 API 很可能用于类似的目的，例如，处理 GPS 定位的应用程序功能共享通用的 API 用法。作者希望这能够在 Android 数据集中创建“规律性”，以帮助模型学习。</p>
</li>
</ul>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><msub><mi>Q</mi><mn>2</mn></msub><mo>:</mo><mi mathvariant="normal">预</mi><mi mathvariant="normal">训</mi><mi mathvariant="normal">练</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">迁</mi><mi mathvariant="normal">移</mi><mi mathvariant="normal">学</mi><mi mathvariant="normal">习</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">基</mi><mi mathvariant="normal">于</mi><mi>T</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">模</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">何</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">？</mi></mrow><annotation encoding="application/x-tex">RQ_2:预训练和迁移学习对于基于 Transformer 的模型的性能有何作用？</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">预</span><span class="mord cjk_fallback">训</span><span class="mord cjk_fallback">练</span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">迁</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">学</span><span class="mord cjk_fallback">习</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">于</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">何</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">？</span></span></span></span></p>
<p>RoBERTa 和 T5 都可以进行预训练，然后针对多项任务进行微调。 RQ2 研究 (i) 模型预训练和 (ii) 在多个任务上微调单个模型以利用迁移学习带来的性能提升（如果有）。 仅针对性能最佳的模型（即 T5）进行了此类附加分析。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><msub><mi>Q</mi><mn>3</mn></msub><mo>:</mo><mi>T</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">模</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">先</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">的</mi><mi>n</mi><mo>−</mo><mi>g</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi mathvariant="normal">模</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">何</mi><mi mathvariant="normal">？</mi></mrow><annotation encoding="application/x-tex">RQ_3:Transformer 模型与最先进的 n-gram 模型相比如何？</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">与</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">何</span><span class="mord cjk_fallback">？</span></span></span></span></p>
<p>DL 模型的替代方案是基于 n-gram 的统计语言模型。 在这个研究问题中，将深度学习模型与（i）经典的 n-gram 模型进行比较，（ii）在较小的研究中与先进的 n-gram 缓存模型进行比较 。</p>
</li>
</ol>
<h2 id="context-selection-datasets"><a class="markdownIt-Anchor" href="#context-selection-datasets"></a> Context Selection: Datasets</h2>
<h3 id="fine-tuning-dataset"><a class="markdownIt-Anchor" href="#fine-tuning-dataset"></a> Fine-Tuning Dataset</h3>
<p>研究包含两个数据集。</p>
<ul>
<li>
<p>第一个数据集来自于作者的MSR‘21的文章，被用来微调RoBERTa和T5模型以及训练n-gram模型。将此数据集称为微调数据集，它包括 Java 和 Android 数据集以允许回答 RQ1.2。 微调数据集是从 CodeSearch Net 数据集构建的，该数据集包含从开源项目中挖掘的 Java 方法。</p>
<ul>
<li>
<p>从CodeSearchNet Java数据集来构建研究所用数据集，因为 Code SearchNet 已经<mark>经过清理步骤</mark>，使其适合代码机器学习的应用。此外，CodeSearchNet 已经按照方法级别的粒度进行组织（即一个实例是一种方法），而其他数据集则收集整个存储库。</p>
</li>
<li>
<p>CodeSearchNet 包含从开源、非分支、GitHub 存储库收集的超过 150 万个 Java 方法。数据集构建中使用的最重要的标准是：</p>
<ul>
<li>
<p>排除少于三行的方法</p>
</li>
<li>
<p>使用 CodeSearchNet 中的重复数据删除算法删除近似重复的方法</p>
<p>——这样做是为了不因训练集和测试集之间的重叠实例而夸大模型的性能</p>
</li>
<li>
<p>删除名称中包含“test”子字符串的方法，以试图<mark>删除测试方法</mark>；名为“toString”的方法也被删除，因为后者通常由 IDE 自动生成，具有非常相似的结构。因此，它们很少代表具有挑战性的代码补全场景，并且可能导致预测准确性过高。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第二个数据集是专门为回答 RQ2 而构建的，即拥有一个可用于预训练 RoBERTa 和 T5 中性能最佳的模型（即预训练数据集）的不同的数据集。</p>
<ul>
<li>从 GitHub 克隆了 AndroidTimeMachine 数据集中的 8,431 个开源 Android 应用程序。 然后从每个项目的最新快照中提取方法列表。 这总共产生了 220 万个方法。应用为 Java 数据集定义的相同过滤启发式方法，最终得到 654,224 个方法。</li>
<li>由于研究的目标之一也是比较当模型应用于更通用（Java）和更具体（Android）数据集时，我们从 Java 数据集中随机选择（使用随机 Python 函数）654,224 个方法，以<mark>匹配 Android 数据集的大小</mark>。</li>
</ul>
</li>
</ul>
<p>作者还尝试了之前研究中使用的代码抽象，以避免开放词汇问题。 然而，由于使用了利用字节对编码（Byte Pair Encoding - BPE）等技术的分词器，基于深度学习的新模型不再受到这种限制。 因此，虽然在之前的论文中作者构建了两个版本的微调数据集（有抽象和没有抽象），但在这项工作中，只关注使用原始源代码的数据集，因为这是使用代码补全技术的真实场景。 需要进行这样的澄清（clarification），因为在构建微调数据集时，排除了在抽象过程中发生解析错误的方法，使得 Java 数据集有 634,799 个方法，Android 数据集有 532,096 个方法。</p>
<p>然后，使用以下masking过程创建下表中汇总的每个数据集的三个版本（Java 和 Android）</p>
<ul>
<li>
<p>Token Masking</p>
<p>对于每个方法中超过一个token的每个代码行 l，我们mask其最后x个tokens，其中 x 是1 … n-1之间的随机数，n是组成l的标记数量。 给定一个有k行的方法m且其超过一个token，生成m的k个版本，每个版本都有一行，其中最后x个标记被masked，其余k-1行没有任何变化（即没有masked token，只是原始源代码）。 作者将屏蔽标记的最大数量设置为 10（即如果 x &gt; 10，则 x=10）。 此场景模拟了经典的代码补全任务，其中开发人员正在编写语句，代码完成工具负责自动完成它。</p>
</li>
<li>
<p>Construct Masking</p>
<p>作者选择了许多代码结构，自动代码补全对这些代码结构支持是特别有用。 给定方法 m，我们使用 scrML 工具包来识别所有 m 的标记，用于：</p>
<ul>
<li>定义 if 语句或 while/for 循环的完整条件（例如，在具有 for(int i=0;i&lt;data.size(); i++ 的语句中），我们将这之间的所有token标识为用于定义 for 循环）</li>
<li>定义方法调用中的参数（例如，在 copyFile(source, target) 中，识别token “source”、“,”和“target”）</li>
<li>定义在 catch 语句中捕获的异常（例如，在 catch(IOException io) 中，我们将 IOException io 标识为所涉及的token）。</li>
</ul>
<p>对于 m，这会产生一个集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S=\{T_1,T_2,...,T_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示前面提到的构造之一的一组相关token（例如，Ti 是用于定义 for 循环条件的集合）</p>
<p>给定 m，我们生成它的|S|个版本，每个版本都有一个被masked的主题（subject？）结构。 此外在本例中，作者将masked token的最大数量设置为 10。这意味着，如果一个构造需要mask超过 10 个token（数据集中 9.38% 的构造发生这种情况），则它不会在我们的数据集中被mask 。</p>
<p>由construct masking模拟的代码补全任务类似于开发人员使用该技术来获取关于有一定难度（non-trivial）的代码token的建议，代表程序流中的决策点（例如 if 语句的条件）或错误处理情况（例如要捕获的异常）。</p>
</li>
<li>
<p>Block Masking</p>
<p>使用 srcML 来识别每个方法m中的代码块。 代码块定义为在两个大括号之间的代码。 例如，除了方法体本身之外，块还可以是在满足 if/else/else if 等条件时在 for/while 循环中执行的代码。然后，给定 k 中识别到的块的数量 m，创建 m 的 k 个版本，每个版本都有一个特定的代码块被mask。 我们将屏蔽（masked）块的最大大小设置为两个完整的语句。 这意味着，如果一个块由两个以上的语句组成（数据集中 49.29% 的块发生这种情况），则它不会被屏蔽（masked）。 这是最具挑战性的代码补全场景，我们在其中测试实验技术。 如果成功完成此任务，代码补全技术可以大大加快代码执行活动。</p>
</li>
</ul>
<p>以上，总共有6个微调数据集：2种语言（Java &amp; Android）* 3种masking level。选择这些masking level来模拟具有不同复杂性的代码补全任务（token-masking是最简单的，block-masking是最复杂的）。</p>
<p>从六个数据集开始，继续构建上表中的训练、评估和测试集。</p>
<ol>
<li>第一步，从数据集中<mark>过滤掉特定实例</mark>。
<ul>
<li>首先，当使用生成深度学习模型时，作为输入提供的句子（在本文例子中为方法）长度的变化可能会影响模型的训练和性能，即使使用填充等技术也是如此。 为此，作者分析了数据集中方法长度的分布，发现其中三分之二最多由 100 个token组成。 因此从数据集中排除了所有具有超过 100 个token的方法。</li>
<li>其次，RoBERTa 无法有效地处理masked token多于non-masked token的情况。 例如，当在block-level方法中屏蔽整个方法体时，这种情况经常发生。 因此，这些实例也被排除在外。</li>
</ul>
</li>
<li>经过过滤步骤后，将六个数据集分别分为训练集 (80%)、评估集 (10%) 和测试集 (10%)。 虽然数据集中的方法是随机排序的，但<mark>分割</mark>不是随机的，以避免学习出现偏差。 为了解释这一点，要考虑block-masking数据集的情况。 给定一个有 k 个块的方法m，在数据集中添加 m 的 k 个版本，每个版本都有且只有一个被masked的块。 假设 m 包含两个块 b1 和 b2，从而产生 m 的两个版本：其中 b1 被屏蔽 (mb1 )，b2 未被屏蔽，反之亦然 (mb2 )。 通过随机分割，可能会发生 mb1 分配给训练集而 mb2 分配给测试集的情况。 然而，在 mb1 中 b2 没有被屏蔽。 因此，当模型必须预测 mb2 中隐藏的token时，它会在训练集中找到解决方案，从而导致了高预测性能。 因此，随机选择每个数据集中 80% 的方法，并将其所有屏蔽（masked）版本分配给训练集。 然后，以相同的方式进行评估和测试集。</li>
</ol>
<p>使用此过程，获得了表中的数据集。需要注意的是，考虑到使用token-level和construct-level masking的数据集的原始大小，将训练集限制为 750k 个实例（评估和测试集中没有变化）。 训练多个 DL 模型的高昂计算成本是必要的（研究需要训练 19 个不同的基于 DL 的模型）。 此外，评估集和测试集的大小略有不同，因为如前所述（而不是其屏蔽版本[masked version]）来分割数据集，并且每种方法可能会产生不同数量的生成屏蔽版本（masked versiond）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/2eb6b047fca8424395a6/?dl=1'>
<h3 id="pre-training-dataset"><a class="markdownIt-Anchor" href="#pre-training-dataset"></a> Pre-Training Dataset</h3>
<p>为了构建预训练数据集，使用 GitHub 搜索平台来检索所有至少有 100 次提交、10 名贡献者和 10 颗star的 Java 存储库。这些过滤标准旨在减少选择玩具（toy）和个人项目来构建该数据集的可能性。按<mark>star数量对项目进行排序</mark>，克隆前6,000个项目，并从每个项目中提取<mark>标记为发布</mark>（release）的最新快照中的方法，为了仅依赖可能在语法上正确的方法。没有快照被标记为发布的存储库被排除在外，剩下 3,175 个存储库。最后，为了避免非常大的项目对数据集产生太大影响（即向数据集贡献太多方法），因此将从每个存储库中<mark>提取的最大方法数量限制</mark>为 1,500 个。这也是根据可用的硬件资源将预训练实例的数量限制在可管理的大小。</p>
<p>除了构建微调数据集时使用的过滤器之外，还删除了所有使用@test注释或驼峰命名中包含“test”一词的<mark>测试方法</mark>（即不排除updateStatus）。此外，由于预训练数据集的目标是提供被屏蔽（masked）的随机token实例，以使模型“熟悉”特定的上下文（即本案例中的 Java 语言），因此排除了非常短的没有足够的元素来屏蔽（masked）的方法（&lt; 15 个token），并且出于与微调数据集解释相同的原因，长方法（本例中&gt;200个标记）也被排除。然后，删除预训练数据集中的所有精确重复项，仅在数据集中保留每个重复项的第一次出现时的方法。 删除重复项后，数据集包含 1,874,338 种不同的方法。</p>
<p>最后，确保预训练数据集不包含任何属于微调数据集的方法（训练、评估或测试集中均不包含）。 预训练和微调数据集总共有 23,977 个重复项，使预训练数据集中的最终实例数量达到 1,850,361 个。</p>
<h2 id="context-selection-techniques"><a class="markdownIt-Anchor" href="#context-selection-techniques"></a> Context Selection: Techniques</h2>
<h3 id="roberta"><a class="markdownIt-Anchor" href="#roberta"></a> RoBERTa</h3>
<p>第一个基于 Transformer 的模型利用现成的 RoBERTa 模型，这是一种 Encoder Transformer 架构。本文集中于解释为什么它是代码补全的合适选择。</p>
<p>基于 BERT 的模型（例如 RoBERTa）使用特殊的预训练，其中输入句子中的随机单词被特殊的 &lt;MASK&gt; token屏蔽（mask）。 此预训练任务非常适合模拟代码补全任务，其中输入是开发人员正在编写的不完整代码片段，而屏蔽标记（masked token）表示自动补全该片段所需的代码。 然而，这种预训练的一个限制是，当尝试预测多个token时，例如整个masked的 if 条件，由于 Transformer 的固定序列长度，它需要已知要生成的token数量。 为了解决这个问题，我们通过使用单个&lt;MASK&gt;标记（token）来掩盖（mask）一段连续的标记（token），从而修改了objective（？）。</p>
<p>如前所述，BERT 模型（例如 RoBERTa）可以针对多项任务进行预训练和微调。 结果将是一个能够支持不同任务的单一模型，并且可能利用它在特定任务中学到的知识来提高其在不同任务中的性能。在研究中，首先在不执行预训练的场景中比较 RoBERTa 和 T5 模型，并通过使用微调数据集构建一个单一模型来完成前面描述的三个代码补全任务（即 token、construct、 和block masking）。 然后，为了获得两者中性能最好的模型（即 T5），作者还尝试了预训练和多任务微调。 训练了 6 个 RoBERTa 模型，每个模型对应上表中的每个数据集。</p>
<p>RoBERTa 模型的实现，使用了 Python Transformers 库中提供的模型。还为每个模型训练一个分词器来克服out-of- vocabulary的问题。 当机器学习模型处理不属于训练集但出现在测试集中的术语时，就会出现out-of-vocabulary问题。 使用HuggingFace 的Python分词器库训练了Byte Pair Encoding (BPE) 模型。BPE使用字节作为vocabulary，允许它对每个文本进行分词而不需要 DL 到 NLP 应用中经常使用的未知标记，从而克服了out-of-vocabulary问题。 在源代码上使用时，BPE已被证明可以去解决out-of-vocabulary问题。</p>
<h3 id="t5"><a class="markdownIt-Anchor" href="#t5"></a> T5</h3>
<p>拉斐尔等人提出了在 NLP 领域利用多任务学习实现迁移学习的 T5 模型。 T5 有五种预定义的变体：small、base、large、3 Billion、11 Billion，它们在复杂性、大小以及训练时间上有所不同。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mn>5</mn><mrow><mi>s</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T5_{small}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是较小的变体，有 6000 万个参数，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mn>5</mn><mrow><mn>11</mn><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T5_{11B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是最大的变体，有 110 亿个参数。 尽管拉斐尔等人强调最大的模型提供了最好的准确性，但其训练时间有时太长而无法证明其使用的合理性。 考虑到计算资源，选择了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mn>5</mn><mrow><mi>s</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T5_{small}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​模型。 因此，作者认为其结果代表基于 T5 的模型性能的下限。</p>
<p>与其他深度学习（DL）模型相比，T5 具有两个优点：</p>
<ol>
<li>它通常比RNNs更高效，因为它允许并行计算输出层（output layer）</li>
<li>它可以检测标记（token）之间隐藏和远程的依赖关系，而无需假设最近的标记比远处的标记更加相关。 后者在与代码相关的任务中特别相关。 例如，局部变量可能在方法的开头（第一个语句）声明，在 if 语句内的主体中使用，最后在方法最后的语句中返回。 捕获这三个语句之间存在的依赖关系，甚至可能彼此相距甚远（例如，变量声明和返回语句），可以帮助更好地对源代码进行建模，从而提高支持代码相关任务的性能。</li>
</ol>
<h3 id="n-gram"><a class="markdownIt-Anchor" href="#n-gram"></a> n-gram</h3>
<p>作为比较的baseline，使用了广泛研究的基于 n-gram 的统计语言模型。 n-gram 模型可以根据其前面的 n-1 个token预测之后的单个token。 尽管 n-gram 模型的目的是在给定n-1个前面的token的情况下预测单个token，但我们为mask多个token的场景设计了一种公平的比较方式。 具体来说，按以下方式使用 n-gram 模型：假设我们正在使用 3-gram模型预测如何补全具有五个标记 T 的语句，其中最后两个被屏蔽（M)：&lt;T1，T2，T3，M4，M5&gt;，其中M4和M5分别掩蔽T4和T5。 将T2和T3作为输入提供给模型来预测M4，获得模型预测P4。 然后，使用T3和T4来预测M5，从而得到预测句子&lt;T1,T2,T3,P4,P5&gt;。 基本上，所有预测都被连接起来以预测多个连续的token。</p>
<p>n-gram 模型在深度学习（DL）模型微调的相同训练集上进行训练，但是没有masked token。 我们使用标准 n-gram 模型以及规模较小的研究，采用 Hellendoorn 和 Devanbu提出的 n-gram 缓存模型。</p>
<h1 id="data-collection-and-analysis"><a class="markdownIt-Anchor" href="#data-collection-and-analysis"></a> Data Collection And Analysis</h1>
<h2 id="training-of-models"><a class="markdownIt-Anchor" href="#training-of-models"></a> Training of Models</h2>
<h3 id="roberta-2"><a class="markdownIt-Anchor" href="#roberta-2"></a> RoBERTa</h3>
<p>在<mark>搭载了Nvidia RTX Titan GPU的Linux服务器</mark>上，使用<a target="_blank" rel="noopener" href="https://wandb.ai/site/">Weights &amp; Biases的Python库</a>执行超参数（hyperParameter）调整。Table 2展示了微调的参数，测试的值范围，以及最佳配置的值。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/f6e697ec3f434ecc9719/?dl=1'>
<p>除了那些超参数，作者使用了0.1的注意力丢失（<a target="_blank" rel="noopener" href="https://sota.jiqizhixin.com/models/methods/c3eb29a5-5dd9-4e98-a782-4223777b75bb">attention dropout</a>）概率和 0.3 的隐藏层丢失（hidden layer dropout）概率。对于分词器，词汇（vocabulary）数量被设置为50k。</p>
<p>使用带有token-masking的Android数据集的评估集和训练集来进行超参数搜索。选择了当应用于评估集时能够获得最多数量的“<mark>完美预测</mark>”的配置作为最佳配置。 将与开发者编写的代码完全匹配的预测定义为“完美”。 因此，模型正确地猜测了所有masked token。 如果masked token之一不同，则不会认为预测是“完美的”。</p>
<p>虽然原则上每个数据集都需要不同的超参数调整，但这样的过程非常昂贵，并且通过对其他数据集的子集进行的初步调查显示，<mark>最佳配置之间存在微小差异</mark>。</p>
<p>训练是<mark>跨服务器</mark>（分别使用他们自己的GPUs）进行的。 第一个配备了Nvidia Tesla V100S，第二个配备了Nvidia RTX Titan，第三个配备了3个Nvidia GTX 1080Ti。 训练时间很大程度上取决于数据集的大小和所使用的服务器，但每个模型的训练时间在28到114小时之间。 可以注意到，经过<mark>训练后每个模型都可以在一秒钟内执行预测</mark>（在笔记本电脑 CPU 上平均为 0.12 秒），从而使它们成为“实时”代码补全的可行解决方案。</p>
<p>对每个模型最多训练 50 个 epoch（一次epoch是指将所有数据训练一遍的次数，epoch所代表的数字是指所有数据被训练的总轮数。）。 然而，采用了以下<mark>停止条件</mark>。 在每个训练周期结束时，在评估集上运行模型并计算完美预测的数量。 如果观察到在训练过程中，模型的性能在评估集的完美预测方面正在恶化（即模型可能<mark>过度拟合</mark>训练集），就会停止训练。 特别是，给定一个训练了第 n 个 epoch 的模型，如果评估集上的完美预测数量低于第 n-4 个 epoch 之后实现的完美预测数量，我们将停止训练。 这<mark>确保了模型在最多三个epoch内的性能有一些波动</mark>。然后，如果它仍然没有改善，我们停止训练并采用迄今为止获得的最佳模型（就评估测试的完美预测而言）。没有一个模型接受过完整的50个 epoch 的训练。</p>
<h3 id="t5-2"><a class="markdownIt-Anchor" href="#t5-2"></a> T5</h3>
<p>使用<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2102.02017">Mastropaolo等人</a>使用的相同配置。关于预训练，不调整 T5 模型的超参数，因为预训练步骤与任务无关，这带来的好处是有限的。 相反，使用Table 3中展示的配置，在微调阶段尝试四种<mark>不同的学习率计划</mark>，并根据评估集上的完美预测确定最佳性能配置。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/ce23b572a8a9499da9ff/?dl=1'>
<p>四个实验配置均在评估其性能前训练了超过了100k步（～7个epoch）。在6个评估数据集中，使用<mark>Slanted Triangular Learning Rates</mark>（Slanted Triangular Learning Rates的核心思想是通过在训练过程中动态调整学习率来提高模型的训练效率和性能。其具体形式为在训练的前半段逐渐增加学习率，然后在后半段逐渐减少学习率。学习率的变化模式呈现出一个“斜三角形”形状。）的配置获得了最好的表现。同时，构建的所有T5模型都使用了在预训练数据集上训练过且包含32k单词片段的<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1808.06226">SentencePiece分词器</a>。</p>
<p>将上文确定的最佳配置用于训练六种不同的T5模型（即Table 1中的每个数据集一个）并评估它们在相应测试集上的性能。 这些结果可用于直接比较 T5 和 RoBERTa 模型在未经预训练的情况下以及在单任务设置（即无迁移学习）中进行微调时的情况。 由于发现<mark>T5的性能优于 RoBERTa</mark>，因此使用该模型来回答 RQ2。 因此除了这六个模型之外，我们还构建了另外七个模型：其中六个模型利用预训练加上单任务微调。 换句话说，它们相当于之前构建的前六个模型，但增加了预训练阶段。</p>
<p>为了预训练 T5 模型，随机mask预训练数据集中每个实例（方法）中15%的token。 预训练执行200k步骤（28 个epoch），由于没有观察到任何的改进，使用Google Colab的 2x2 TPU 拓扑（8 核）来训练模型，batch size为 256，序列长度（输入和目标）为256个token。 使用规范配置的平方根倒数作为学习率。 训练100步大约需要26秒。</p>
<p>最后创建了一个利用预训练和多任务微调的 T5 模型（首先对单个模型进行预训练，然后在Table 1中的所有六个数据集上进行微调）。这样做是为了检查迁移学习对模型性能的影响。 <mark>总共训练了13个T5模型：6个没有预训练和单任务微调，6个有预训练和单任务微调，1个有预训练和多任务微调。</mark></p>
<h2 id="analysis-of-results"><a class="markdownIt-Anchor" href="#analysis-of-results"></a> Analysis of Results</h2>
<p>为了回答RQ1，通过在每个训练好的模型上运行Table 1中的测试集计算的度量指标，度量指标总结在Table 4</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/82f2ffef70154461a46c/?dl=1'>
<ol>
<li>第一个指标是<mark>Bilingual Evaluation Understudy(BLEU)-n</mark>得分，这个指标评估的是自动翻译文本的质量。BLEU得分是通过计算翻译文本和参考文本中出现的单词的加权百分比（即考虑出现次数）。 使用 BLEU 的四种变体，即 BLEU-1、BLEU-2、BLEU-3 和 BLEU-4。 BLEU-n变体通过考虑生成文本中的n元模型来计算BLEU分数。软工方向以前的的大部分工作都采用BLEU-4得分，但是这个变体不能用于计算目标预测小于4的情况（本文中是masked token的数量）。因此，作者计算了从BLEU-1到BLEU-4四个版本的得分。==BLEU-1对于任何预测都可以计算，但BLEU-n（n&gt;1）只适用于长度大于等于n的预测。==BLEU得分的范围是0-100%，其中100%意味着对于maksed token生成的代码和参考代码是一样的。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337192405">The Levenshtein distance</a>。为了提供一种开发人员将模型生成的预测转换为参考（正确）代码的所需工作量的衡量标准，在token颗粒度上计算Levenshtein distance：这可以被定义为将预测代码转换为参考代码所需的最小token编辑（插入、删除或替换）次数。 由于这种衡量方式没有标准化，因此在我们的上下文中解释它是困难的。 如果不知道参考代码中的token数量就说必须改变5个token来获得参考代码是没有意义的。 因此，作者通过将预测代码和参考代码中最长序列中的标记数量做除法来标准化该值。</li>
<li>The percentage of perfect predictions。这个指标告诉我们实验模型预测token序列的性能，这些token序列在目标代码中被masked。</li>
</ol>
<p>通过不同的统计分析，对RoBERTa和T5的结果进行对比。假设显著性水平为95%，使用比例检验（<a target="_blank" rel="noopener" href="https://blog.csdn.net/HoWingjan/article/details/112570754">tests on proportions</a>）和数值变量的非参数检验（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/49217262">non-parametric tests</a>）。不使用参数检验是因为根据<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26477641">Anderson-Darling检验</a>（p 值 &lt; 0.001），BLEU得分和Levenshtein距离的结果都偏离正态性。每当分析需要运行多个测试实例时，都会使用<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/342425585">Benjamini-Hochberg过程</a>调整p值。</p>
<p>为了（成对）比较 RoBERTa 和 T5 的完美预测，我们使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/orDream/article/details/122540099">McNemar检验</a>，这是一种比例检验，适合成对比较两种不同处理的二分结果。 为了计算测试结果，我们创建一个混淆矩阵来计算以下情况的数量：</p>
<ul>
<li>T5和RoBERTa都提供了完美预测</li>
<li>只有T5提供了完美预测</li>
<li>只有RoBERTa提供了完美预测</li>
<li>T5和RoBERTa均没有提供完美预测</li>
</ul>
<p>最后，我们用优势比 (OR) 统计效应来补充 McNemar 检验。</p>
<p>为了回答RQ1.2，不同数据集之间通过比例检验，但是这一次分析是未配对的（即在两个不同的数据集上对比结果），所以在一个矩阵上使用费舍尔精确检验（以及相关优势比），该矩阵包含针对不同方法和不同masking level，使用Java和Android实现的正确和错误预测的数量。</p>
<p>为了按照BLEU-n得分和Levenshtein距离来比较T5和RoBERTa的结果，使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/chikily_yongfeng/article/details/82255575">Wilcoxon 符号秩检验</a>和成对<a target="_blank" rel="noopener" href="https://juejin.cn/s/%E7%BB%9F%E8%AE%A1%E5%AD%A6effect%20size%20of%20lists%E7%9A%84%E4%BD%BF%E7%94%A8">Cliff’s delta effect size</a>。相似的，当数据集按照BLEU-n得分和Levenshtein来进行对比时，由于是未配对的，可以使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/chikily_yongfeng/article/details/82255575">Wilcoxon 秩和检验</a>和未成对<a target="_blank" rel="noopener" href="https://juejin.cn/s/%E7%BB%9F%E8%AE%A1%E5%AD%A6effect%20size%20of%20lists%E7%9A%84%E4%BD%BF%E7%94%A8">Cliff’s delta effect size</a>。</p>
<p>对于T5，也统计地比较了他展示的性能：</p>
<ul>
<li>有/没有预训练</li>
<li>有/没有迁移学习</li>
</ul>
<p>同样的，对于T5的比较，McNemar检验也可以被使用来比较完美预测。</p>
<p>最后，得到了表现最好的模型（即经过预训练和多任务微调的T5模型）并检测预测的置信度是否可以用作预测“质量”的可靠代理。如果是这种情况，这意味着在围绕训练模型构建的推荐系统中，开发人员可以决定仅当其置信度高于特定阈值时才接收推荐。 T5 返回每个预测的分数，范围从负无穷到 0。该分数是预测的对数近似 (ln)。 因此，如果它为0，则意味着预测的可能性为1（即最大置信度，因为ln(1) = 0），而当它趋于负无穷大时，置信度趋于0。</p>
<p>为了通过统计分析证实作者的结果，作者报告了通过构建逻辑回归模型获得的OR，该模型将置信度（自变量）与预测实现完美预测的程度（因变量）相关联。 给定逻辑回归模型中的自变量估计值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>β</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\beta_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，OR 由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><msub><mi>β</mi><mi>i</mi></msub></msup></mrow><annotation encoding="application/x-tex">e^{\beta_{i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.05278em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>​得出，它表示自变量增加一个单位所对应的几率增加。 还确定了模型报告的置信度与屏蔽标记数量的相关程度。在这个程度上，使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39885465/article/details/105539407">肯德尔相关性</a>，它不会像其他非参数相关性那样受到关系存在（出现在我们的数据集中）的影响。</p>
<p>为了解决 RQ3，对于所有数据集，我们将基于 DL 的模型的性能与 n-gram 模型的性能进行比较。 特别是，作者使用标准 n-gram 语言模型进行了第一次大规模比较，并且在较小的数据集上，还使用以下方法将实验技术与最先进的缓存 n-gram 模型进行了比较。 稍后将说明为什么缓存 n-gram 模型太昂贵而无法在整个数据集上运行。</p>
<p>作者尝试了去设计一个公平的比较方式，尽管n-gram模型是设计来依据给定之前的n个token来预测单一的token。因此在mask超过一个token的场景下，我们按照如下方式使用n-gram模型：</p>
<ol>
<li>运行模型来独立预测每个masked token</li>
<li>将所有预测连接起来来产生最终的字符串（例如之前mask过的token）</li>
<li>n-gram模型在基于DL的模型微调的相同的数据集上训练，但是没有masked tokens</li>
</ol>
<p>根据在测试集上生成的完美预测来比较这三种方法。 使用 McNemar 检验和 OR 进行统计比较。</p>
<h1 id="results-discussion"><a class="markdownIt-Anchor" href="#results-discussion"></a> Results Discussion</h1>
<p>首先对比T5和RoBERTa的性能。 然后，展示n-gram模型与基于DL的模型的比较。 最后介绍模型做出的正确预测的定性示例，并讨论了非完美预测的语义等价性。<br />
在解释所取得的结果时，尤其是那些涉及完美（正确）预测的结果时，不可能与之前的代码补全工作中所取得的结果进行直接比较。 这是因为文献中的大多数研究在预测开发人员可能编写的下一个token时都使用代码补全模型进行实验。 正如将要展示的，在这种特定场景中，我们实验的模型可以实现极高的准确性（&gt; 95% 的正确预测）。然而，当预测由多个token甚至多个语句组成的较长序列时，它们的性能会大幅下降。</p>
<h2 id="dl-based-models-performance-comparison-rq1"><a class="markdownIt-Anchor" href="#dl-based-models-performance-comparison-rq1"></a> DL-Based Models Performance Comparison (RQ1)</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/c72435afdc114dd09001/?dl=1'>
<p>图 1 描述了基于深度学习的模型在不同masking方法（从左到右依次为token-masking、construct-masking和block- masking）的完美预测方面所取得的结果。 该图显示了完美预测的百分比（y 轴）与masked token数量（x 轴）。 例如，在token maksing场景中，随机屏蔽具有多个token的每个源代码行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的最后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>个token，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1...</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1...n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>之间的随机数，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>​的token数量，x 的上限为 10。T5的结果以橙色报告，而 RoBERTa的结果为红色； 实线表示在Java数据集上取得的结果，而虚线表示在Android数据集上取得的结果。</p>
<p>图 1 的左侧图显示了仅mask最后一个token（即一个被masked的token）、最后两个token等情况下完美预测的百分比。在处理block-masking场景，由于屏蔽整个块，因此在某些情况下有数十个masked token。 每个点表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">x-5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>之间的token被mask，例如，对于第一个数据点，最多5个token被mask，第二个数据点在5到10 之间等等。</p>
<p>Table 5报告了四种考虑的变体的平均BLEU得分以及T5和RoBERTa的平均标准化Levenshtein距离。在这种情况下，结果会根据masking level和数据集进行分组。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/ad5912b47c23490aae3a/?dl=1'>
<p>图 1和Table 5中的结果是基于深度学习的模型在最简单的场景（即没有预训练的单任务）下实现的。 为了回答 RQ1.3，对最佳模型（即 T5）进行了额外的实验。Table 6中提供了实验T5模型不同变体的完美预测的百分比的结果，即有/没有预训练以及是否使用单任务和多任务微调。Table  6还展示了RoBERTa模型在最简单场景中取得的结果以简化结果的讨论。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/2199f5fe305b4a4cad03/?dl=1'>
<h3 id="impact-of-number-of-masked-tokens-rq11-and-specificity-of-the-dataset-rq12"><a class="markdownIt-Anchor" href="#impact-of-number-of-masked-tokens-rq11-and-specificity-of-the-dataset-rq12"></a> Impact of Number of Masked Tokens (RQ1.1) and Specificity of the Dataset (RQ1.2)</h3>
<p>从图1的分析中有<mark>三个发现</mark>：</p>
<ol>
<li>masked token的数量越多，模型的表现越低</li>
<li>在token-masking场景下，对于RoBERTa模型，在更加具体的数据集（如Android数据集，图中的虚线）上取得的效果比在Java数据集上的效果更好（见Table9的数据）。</li>
<li>T5模型的表现远远超过RoBERTa（见Table7和8中的数据），且对比T5的表现，当masked token的数量增加时，RoBERTa的性能下降的更稳定（？steadily）</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/3d72eca89f7541eeb8b1/?dl=1'>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/345de3c936b448a89e42/?dl=1'>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/9a92ae64979849fbbe8a/?dl=1'>
<p>Table 7展示了使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/orDream/article/details/122540099">McNemar检验</a>和OR来对比T5和RoBERTa在进行完美预测的能力的结果。可以看出，（调整后的）p值始终表明统计上存在显著差异，OR表明T5提供完美预测的几率比RoBERTa高2.94到8.87。</p>
<p>关于BLEU分数和Levenshtein距离（Table5中展示了均值）的对比，Table 8中展示了统计结果（<a target="_blank" rel="noopener" href="https://blog.csdn.net/chikily_yongfeng/article/details/82255575">Wilcoxon 符号秩检验</a>调整的p值和<a target="_blank" rel="noopener" href="https://juejin.cn/s/%E7%BB%9F%E8%AE%A1%E5%AD%A6effect%20size%20of%20lists%E7%9A%84%E4%BD%BF%E7%94%A8">Cliff</a>的d值）。在这种情况下，差异是统计显著的，不同的效应大小（Java 比 Android 而言BLEU分数水平越高）有利于T5（对于 Levenshtein 距离，negative d有利于 T5，因为它是一个距离）。</p>
<ul>
<li>
<p><strong>Token Masking</strong></p>
<p>图1的左部分展示了正如期待的那样，masked token的数量越少，完美预测越高。并不意外的是，模型在仅对<mark>语句中最后一个token被mask的情况下</mark>是非常高效的。事实上，最后的token往往是分号、括号、大括号，因此模型预测最后token是非常容易的。当转入更有挑战性的场景像语句中的最后5个token被mask，RoBERTa在Java数据集上的的完美预测率掉到了10%以下，这和T5模型仍然保持40%以上的完美预测率<mark>存在巨大的差异</mark>。至于数据集方面，两个模型都<mark>在Android数据集上获得了更好的表现</mark>（费舍尔检验p值&lt;0.001且OR&lt;1），Android数据集是更具体，因此更容易受到源码中的规律的影响。但是对于RoBERTa模型，在Java数据集和Android数据集上完美预测率的差距是更明显（x=5时为～20%，而T5为6%）。</p>
<p>从Table 5中，BLEU分数和Levenshtein距离证实了从完美预测中观测到的，即Android数据集上的表现比Java数据集上的更好。根据Wilcoxon秩和检验，除了Block level上的RoBERTa模型，所有的区别都是统计显著的，但是cliff的d值是可以忽略不计/很小的。</p>
</li>
<li>
<p><strong>Construct Masking</strong></p>
<p>在这种场景下（图1中间的图），对于两个数据集，当单一token被mask时，T5和RoBERTa完美预测率分别能达到超过65%和55%。在这种场景下，单一token并不是微不足道的（？trival）因为我们处在一个上下文中，其中单一的token代表着：</p>
<ul>
<li>补全if语句或while/for循环的条件</li>
<li>方法调用的参数</li>
<li>catch方法中捕获的异常</li>
</ul>
<p>当预测由单个token表示时，它通常与 if 条件中使用的布尔值（例如 if(true)、if(valid) 等）或方法调用所需的单个参数相关。</p>
<p>同样的，masked token数量的增加意味着更低的表现，同时在两个数据集上T5的表现要显著的超过RoBERTa尽管差距更小了。最后，正如Table 9中展示的，对于RoBERTa在Android上的效果更好，对于T5能够达到OR$\approx$1。</p>
<p>至于BLEU分数和Levenshtein距离，对比token-level的masking，获得的值更差。这也证实了construct-level的masking，预测场景是更加困难的。平均来看，当分别使用RoBERTa和T5时，开发者可能需要修改预测出的token中的30%-40%来获得参考代码（这在Java和Android观察到的差异是很小的）。</p>
</li>
<li>
<p><strong>Block Masking</strong></p>
<p>这代表了最有挑战的代码预测场景：被masked的部分可能包括整个语句或者是涵盖超过2个语句（设置的最大边界）。当处理小型的masked block（即5个token）时，T5和RoBERTa的表现分别是超过50%和35%。这些blocks很大部分和代码块的返回语句有联系（例如当满足if条件时的返回的值），例如{return false;}, {return null;}等。</p>
<p>对于更长的block，模型的表现显著下降。当考虑拥有6-10个masked token的块，RoBERTa对于大约5%的例子能够生成完美预测，对比之下T5大概能达到大约25%。T5在Android和Java数据集上能够达到完美预测的最大masked token分别是36和39，而RoBERTa的数据在13和15。</p>
<p>在这一级别上，在Java和Android数据集上的区别并不明显，在T5上甚至更加不显著。正如预期的那样，在这种场景下BLEU分数是最低的，并且当使用RoBERTa和T5时，开发者需要分别独立修改预测出的token中的大约50%和30%。</p>
</li>
</ul>
<p><strong>Answer to RQ1.1</strong></p>
<p>当masked tokens的数量增加时，基于深度学习的模型更难产生完美预测。T5模型的性能看上去是符合预期的，同时能通过合适的预训练和多任务微调进一步提升。</p>
<p><strong>Answer to RQ1.2</strong></p>
<p>当观察最优模型（即T5）时，他在两个数据集上的表现是相似的，并没有主要差别。只有在token-masking场景下，RoBERTa模型会出现强烈的差距。</p>
<h3 id="impact-of-pre-training-and-transfer-learning-rq2"><a class="markdownIt-Anchor" href="#impact-of-pre-training-and-transfer-learning-rq2"></a> Impact of Pre-Training and Transfer Learning (RQ2)</h3>
<p>如前所述，训练了7个额外的T5模型来评估预训练和迁移学习对性能的影响。首先向6个先前讨论过的T5模型（无预训练&amp;单任务）加入预训练过程（获得一个没有迁移学习，面向单任务场景的预训练模型），然后使用预训练模型在多任务设置下进行微调，探索迁移学习的影响。</p>
<p>Table 6展示了取得的效果。使用McNemar检验获得的统计对比结果在Table 10中给出。正如其中展示的，预训练对于所有情况都拥有积极的（OR&gt;1）和统计显著的效果。Table 6中，预训练对于T5的准确性拥有积极的影响，在使用测试集的条件下，完美预测率从1%激增到4.7%。预训练的好处在最有挑战性的block-level场景下是更显著的。总的来说，将所有测试数据集作为一个整体考虑，完美预测的百分比从54.1%上升至56.2%。</p>
<p>通过在6个训练数据集上训练单一模型，完美预测的百分比进一步提高，总体能达到59.3%。注意到在所有测试集上都能观察到提升，并且对于token-masking场景，能够达到大约5%。性能上的提升也通过了BLEU分数和Levenshtein距离的结果得到了证实，结果可以在: <a target="_blank" rel="noopener" href="https://github.com/mciniselli/T5_Replication_Package.git%E4%B8%8A%E8%8E%B7%E5%BE%97%E3%80%82">https://github.com/mciniselli/T5_Replication_Package.git上获得。</a></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/3edd75e1f751480c8ea3/?dl=1'>
<p><strong>Answer to RQ2</strong></p>
<p>预训练和多任务微调都对T5的性能拥有积极的影响。总的来说，对于完美预测提升大约为5.2%（即额外36,009个实例被正确预测）。</p>
<h3 id="t5置信度confidence-level"><a class="markdownIt-Anchor" href="#t5置信度confidence-level"></a> T5置信度（Confidence Level）</h3>
<p>对于每个预测，T5会返回一个分数（Score），从-∞到0。这个分数是预测可能性的log近似拟合。例如如果分数为-2，那么可能性大约为0.14，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>0.14</mn><mo stretchy="false">)</mo><mo>≈</mo><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">ln(0.14)\approx -2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">2</span></span></span></span>​，这也意味着模型对于预测正确的置信度为14%。如果分数为0，则意味着模型对于预测有100%的置信度。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/bd0cfe59aa7b47d7b523/?dl=1'>
<p>图3展示了完美预测的百分比和模型置信度之间的关系。橙色的线表示置信区间内完美预测的百分比（例如置信度高于0.9的预测中，90%是正确的），红色的线表示该置信区间内的完美预测的百分比总数的（例如，所有完美预测中 78% 的置信度高于 0.9）。</p>
<p>图3展示了模型置信度和和预测准确性之间的强联系。虽然这个结果可能看起来微不足道，但它具有重要的含义：围绕 T5 模型构建可靠的代码补全工具是可能的。 该工具可以配置为仅在预测的置信度高于给定阈值（例如 0.9）时触发建议。 这将导致极高的代码补全精度。</p>
<p>从统计角度来看，将置信水平与完美预测结果相关联的逻辑回归模型表明存在统计显著性（p 值 &lt; 0.001）相关性，估计值为 6.58，这意味着每增加一个单位置信度，完美预测的几率就会提高720，即置信度增加0.1，完美预测的几率提高72。</p>
<p>图 4分析了所有置信区间中完美预测（黄线）、错误预测（橙线）以及所有预测（红线）的平均长度（以token为单位）。 很明显，预测的长度与置信度相关，因为模型对于较短的预测具有更高的置信度。 事实上，最高置信区间的完美预测中的平均标记数（即3个标记）远低于最低置信区间的完美预测中的平均标记数（即6个标记）。 这证实了之前的研究结果，即该模型更有可能正确预测较短的语句。</p>
<p>从统计角度来看，, this is confirmed by a significant (p-value &lt; 0.001), negative, and moderate Kendall’s correlation (t = -0.36).</p>
<h2 id="comparison-with-an-n-gram-model"><a class="markdownIt-Anchor" href="#comparison-with-an-n-gram-model"></a> Comparison With an N-Gram Model</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://sebugmaker.github.io">Rain Sun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://sebugmaker.github.io/posts/c22f54fd.html">http://sebugmaker.github.io/posts/c22f54fd.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sebugmaker.github.io" target="_blank">Rain's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Code-Completion/">Code Completion</a><a class="post-meta__tags" href="/tags/Transformer/">Transformer</a></div><div class="post_share"><div class="social-share" data-image="https://box.nju.edu.cn/f/49fb0997934545dbae83/?dl=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3a00daf2.html" title="最近听的歌第一期"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/365b81efc4ad4879a819/?dl=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">最近听的歌第一期</div></div></a></div><div class="next-post pull-right"><a href="/posts/6485cb09.html" title="ReACC: A Retrieval-Augmented Code Completion Framework"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/d6b6537b41be4d2fa9c0/?dl=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ReACC: A Retrieval-Augmented Code Completion Framework</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/8618b667f75848d78fe7/?dl=1" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rain Sun</div><div class="author-info__description">Mia San Mia</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SEBugMaker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SEBugMaker" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sunbugmaker@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
    var sentence = document.querySelector("#poem_sentence")
    var author = document.querySelector("#poem_author")
    var dynasty = document.querySelector("#poem_dynasty")

    var sentenceText = result.data.content
    sentenceText = sentenceText.substr(0, sentenceText.length - 1);
    sentence.innerHTML = sentenceText
    dynasty.innerHTML = result.data.origin.dynasty
    author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>简介</span></div><div class="announcement_content">Hi there！我是南京大学软件工程专业的一名学生，欢迎来到我的博客。这里记录了我的学习和生活，希望能给你带来一些帮助。<br> 如果你有什么问题或建议，欢迎在评论区留言或通过邮件询问，我会尽快回复的。谢谢！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87-an-empirical-study-on-the-usage-of-transformer-models-for-code-completion"><span class="toc-number">1.</span> <span class="toc-text"> 代码补全相关论文 An Empirical Study on the Usage of Transformer Models for Code Completion</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#introduction"><span class="toc-number">2.</span> <span class="toc-text"> Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#research-questions-and-context"><span class="toc-number">3.</span> <span class="toc-text"> Research Questions And Context</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#context-selection-datasets"><span class="toc-number">3.1.</span> <span class="toc-text"> Context Selection: Datasets</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fine-tuning-dataset"><span class="toc-number">3.1.1.</span> <span class="toc-text"> Fine-Tuning Dataset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pre-training-dataset"><span class="toc-number">3.1.2.</span> <span class="toc-text"> Pre-Training Dataset</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#context-selection-techniques"><span class="toc-number">3.2.</span> <span class="toc-text"> Context Selection: Techniques</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#roberta"><span class="toc-number">3.2.1.</span> <span class="toc-text"> RoBERTa</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t5"><span class="toc-number">3.2.2.</span> <span class="toc-text"> T5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#n-gram"><span class="toc-number">3.2.3.</span> <span class="toc-text"> n-gram</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#data-collection-and-analysis"><span class="toc-number">4.</span> <span class="toc-text"> Data Collection And Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#training-of-models"><span class="toc-number">4.1.</span> <span class="toc-text"> Training of Models</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#roberta-2"><span class="toc-number">4.1.1.</span> <span class="toc-text"> RoBERTa</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t5-2"><span class="toc-number">4.1.2.</span> <span class="toc-text"> T5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#analysis-of-results"><span class="toc-number">4.2.</span> <span class="toc-text"> Analysis of Results</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#results-discussion"><span class="toc-number">5.</span> <span class="toc-text"> Results Discussion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dl-based-models-performance-comparison-rq1"><span class="toc-number">5.1.</span> <span class="toc-text"> DL-Based Models Performance Comparison (RQ1)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#impact-of-number-of-masked-tokens-rq11-and-specificity-of-the-dataset-rq12"><span class="toc-number">5.1.1.</span> <span class="toc-text"> Impact of Number of Masked Tokens (RQ1.1) and Specificity of the Dataset (RQ1.2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#impact-of-pre-training-and-transfer-learning-rq2"><span class="toc-number">5.1.2.</span> <span class="toc-text"> Impact of Pre-Training and Transfer Learning (RQ2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t5%E7%BD%AE%E4%BF%A1%E5%BA%A6confidence-level"><span class="toc-number">5.1.3.</span> <span class="toc-text"> T5置信度（Confidence Level）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#comparison-with-an-n-gram-model"><span class="toc-number">5.2.</span> <span class="toc-text"> Comparison With an N-Gram Model</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/fb8e5e9b.html" title="Soul Power II Suzhou"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/a8cfbb7f1c6344a79efe/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Soul Power II Suzhou"/></a><div class="content"><a class="title" href="/posts/fb8e5e9b.html" title="Soul Power II Suzhou">Soul Power II Suzhou</a><time datetime="2025-06-03T03:26:38.000Z" title="发表于 2025-06-03 11:26:38">2025-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3040d40b.html" title="登泰山记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/bb980e923d16458e9556/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="登泰山记"/></a><div class="content"><a class="title" href="/posts/3040d40b.html" title="登泰山记">登泰山记</a><time datetime="2025-06-02T16:24:22.000Z" title="发表于 2025-06-03 00:24:22">2025-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a16362a.html" title="最近听的歌第二期"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/6fd2771ec96046808b14/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="最近听的歌第二期"/></a><div class="content"><a class="title" href="/posts/a16362a.html" title="最近听的歌第二期">最近听的歌第二期</a><time datetime="2024-10-13T12:09:09.000Z" title="发表于 2024-10-13 20:09:09">2024-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4cacdc62.html" title="CS224N_hw_a1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/7b57c17be59f47b0808c/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CS224N_hw_a1"/></a><div class="content"><a class="title" href="/posts/4cacdc62.html" title="CS224N_hw_a1">CS224N_hw_a1</a><time datetime="2024-07-24T11:23:24.000Z" title="发表于 2024-07-24 19:23:24">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c739b36b.html" title="tree-sitter生成语法树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/e8109f7d6a184814ad9a/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tree-sitter生成语法树"/></a><div class="content"><a class="title" href="/posts/c739b36b.html" title="tree-sitter生成语法树">tree-sitter生成语法树</a><time datetime="2024-07-08T07:10:29.000Z" title="发表于 2024-07-08 15:10:29">2024-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Rain Sun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://newtwikoo-iota.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://newtwikoo-iota.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="8251277445" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html><div id="sakana-widget" style="position:fixed;bottom:0px;right:0px;"></div><script>function initSakanaWidget() {
  new SakanaWidget().mount('#sakana-widget');
}</script><script async="" onload="initSakanaWidget()" src="https://cdn.jsdelivr.net/npm/sakana-widget@2.2.1/lib/sakana.min.js"></script>