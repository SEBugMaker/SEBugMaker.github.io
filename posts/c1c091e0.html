<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>软件系统设计复习 | Rain's Blog</title><meta name="author" content="Rain Sun"><meta name="copyright" content="Rain Sun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="24软件系统设计 孙顾燚 - v3.0 总体来说考试的简答题还是考察的基础知识，部分题目需要结合知识思考 详细设计部分的设计题不会非常难，但是今年的架构设计题直接gg了 由于博客的markdown不支持渲染[!important]，所以博客上看这篇文章怪怪的  24考试回忆 代码违背了什么设计原则，如何修改 设计原则之间的联系 ASR是什么？ASR来源 checklist 7个categories">
<meta property="og:type" content="article">
<meta property="og:title" content="软件系统设计复习">
<meta property="og:url" content="http://sebugmaker.github.io/posts/c1c091e0.html">
<meta property="og:site_name" content="Rain&#39;s Blog">
<meta property="og:description" content="24软件系统设计 孙顾燚 - v3.0 总体来说考试的简答题还是考察的基础知识，部分题目需要结合知识思考 详细设计部分的设计题不会非常难，但是今年的架构设计题直接gg了 由于博客的markdown不支持渲染[!important]，所以博客上看这篇文章怪怪的  24考试回忆 代码违背了什么设计原则，如何修改 设计原则之间的联系 ASR是什么？ASR来源 checklist 7个categories">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://box.nju.edu.cn/f/a8416f815322466ca6a0/?dl=1">
<meta property="article:published_time" content="2024-06-24T08:28:17.000Z">
<meta property="article:modified_time" content="2024-07-04T14:53:15.760Z">
<meta property="article:author" content="Rain Sun">
<meta property="article:tag" content="软件系统设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://box.nju.edu.cn/f/a8416f815322466ca6a0/?dl=1"><link rel="shortcut icon" href="https://box.nju.edu.cn/f/02da4b126cc04fd4951f/?dl=1"><link rel="canonical" href="http://sebugmaker.github.io/posts/c1c091e0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件系统设计复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-04 22:53:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/myhead.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body>
    <div id='loader'>
        
            <div class="loading-left-bg"></div>
            <div class="loading-right-bg"></div>
            <div class="spinner-box">
                <div class="configure-border-1">
                    <div class="configure-core"></div>
                </div>
                <div class="configure-border-2">
                    <div class="configure-core"></div>
                </div>
                <div class="loading-word">加载中...</div>
            </div>
        
    </div>

    <script>
        var endLoading = function () {
            document.body.style.overflow = 'auto';
            document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
<div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/8618b667f75848d78fe7/?dl=1" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://box.nju.edu.cn/f/a8416f815322466ca6a0/?dl=1')"><nav id="nav"><span id="blog-info"><a href="/" title="Rain's Blog"><span class="site-name">Rain's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件系统设计复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-24T08:28:17.000Z" title="发表于 2024-06-24 16:28:17">2024-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-04T14:53:15.760Z" title="更新于 2024-07-04 22:53:15">2024-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>78分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="软件系统设计复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="24软件系统设计"><a href="#24软件系统设计" class="headerlink" title="24软件系统设计"></a>24软件系统设计</h1><blockquote>
<p>孙顾燚 - v3.0</p>
<p>总体来说考试的简答题还是考察的基础知识，部分题目需要结合知识思考</p>
<p>详细设计部分的设计题不会非常难，但是今年的架构设计题直接gg了</p>
<p>由于博客的markdown不支持渲染[!important]，所以博客上看这篇文章怪怪的</p>
</blockquote>
<h1 id="24考试回忆"><a href="#24考试回忆" class="headerlink" title="24考试回忆"></a>24考试回忆</h1><ul>
<li>代码违背了什么设计原则，如何修改</li>
<li>设计原则之间的联系</li>
<li>ASR是什么？ASR来源</li>
<li>checklist 7个categories</li>
<li>SOA基本原则，对质量属性的影响</li>
<li>微服务部署模式的上下文，需求，模式，优缺点</li>
<li>Risks，Senstivity Points，Trade-Off Points分别是什么？各举一个例子。</li>
<li>一个在线购物平台，用了策略模式但是有问题，分析问题出在哪里，如何修改</li>
<li>装饰器能否作为组合模式的变种？（忘了位置了，也可能反过来</li>
<li>架构设计大题，需要画不同的views</li>
</ul>
<h1 id="架构部分-zh部分"><a href="#架构部分-zh部分" class="headerlink" title="架构部分 - zh部分"></a>架构部分 - zh部分</h1><blockquote>
<p>  [!IMPORTANT]</p>
<p>【2019】Architecture，structure和Design的区别？</p>
<ol>
<li>Design 包含 Architecture，Architecture 包含 Structure</li>
<li>结构是静态的、逻辑的，是关于系统如何构成的</li>
<li>Architecture除包含structure ，还会包含组件之间的相关的关系结构，并定义一些动态的行为。</li>
<li>体系结构是关于软件设计的，所有体系结构都是设计，但是不是所有的设计都是体系结构，体系结构是软件设计的一个部分</li>
</ol>
</blockquote>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="架构定义"><a href="#架构定义" class="headerlink" title="架构定义"></a>架构定义</h3><ol>
<li>定义1：程序或计算系统的软件体系结构是系统的一个或多个结构，其中包括软件组件，这些组件的外部可见属性以及它们之间的关系。[软件工程学院(SEI)] </li>
<li>定义2：系统的基本组织，体现在其组件，它们之间的相互关系以及环境以及支配其<strong>设计和演进的原则</strong>。[IEEE 1471-2000有关软件密集型系统的体系结构描述的推荐做法]</li>
</ol>
<h3 id="软件架构师在做什么-What-Does-a-Software-Architect-Do"><a href="#软件架构师在做什么-What-Does-a-Software-Architect-Do" class="headerlink" title="软件架构师在做什么 What Does a Software Architect Do?"></a>软件架构师在做什么 What Does a Software Architect Do?</h3><ol>
<li>联络人 Liaison<ol>
<li>在客户、技术团队和商业/需求分析师之间 Among clients, technical team and business/requirements analysts</li>
<li>包含管理和市场分析 With management or marketing</li>
</ol>
</li>
<li>软件工程：软件工程的最佳实践 Software Engineering:Software engineering best practices</li>
<li>技术知识：深入理解技术领域 Technology Knowledge:Deep understanding of technology domain</li>
<li>风险管理：Risk Management<ol>
<li>与设计、技术决策相关的风险 Risks associated with the design, technology choices</li>
<li>更多？More?</li>
</ol>
</li>
</ol>
<h3 id="架构来源"><a href="#架构来源" class="headerlink" title="架构来源"></a>架构来源</h3><blockquote>
<p>NSRs, ASRs, 质量需求, stakeholder, Organisations, Technical Environments</p>
<p>  [!IMPORTANT]</p>
<p>【2015】【2019】软件架构来自哪里？列举五种可能的软件架构的来源 Where do software architecture come from? List five possible sources of software architecture.</p>
<ol>
<li><p>NFRs</p>
</li>
<li><p>ASRs</p>
</li>
<li>质量需求</li>
<li>涉众，组织</li>
<li>技术环境</li>
<li>业务目标</li>
<li>商业与技术决策组合</li>
</ol>
</blockquote>
<h3 id="视图-4-1-views"><a href="#视图-4-1-views" class="headerlink" title="视图 4+1 views"></a>视图 4+1 views</h3><blockquote>
<p>逻辑，过程，物理，开发 + 用例场景</p>
<p>  [!IMPORTANT]</p>
<p>【高频 2015 2017 2019】为什么软件系统架构需要使用不同视图来文档化？给出4种示例视图的名称和目的。Why should a software architecture be documented using different differenet views? Give the name and purposes of 4 example views.</p>
<p>原因</p>
<ol>
<li>不同视图支持不同的目标和用户，突出不同的系统元素和关系</li>
<li><p>不同视图将不同质量属性暴露出不同的程度</p>
<p>【2017】【2019】描述 4+1 视图 Describe 4+1 view(掌握绘图)：答案如上</p>
</li>
</ol>
</blockquote>
<ol>
<li>逻辑视图：描述了体系结构中在体系结构上明显重要的元素以及他们之间的关系 Logical view: describes architecturally significant elements of the architecture and the relationships between them</li>
<li>过程视图：描述了体系结构中的并发和交流元素 Process view: describes the concurrency and communications elements of an architecture.</li>
<li>物理视图：描述了主要过程和部件是如何映射到应用硬件上的 Physical view: depicts how the major processes and components are mapped on to the applications hardware.</li>
<li>开发视图：描述了软件部件是如何在软件内部组织的，比如配置管理工具 Development view: captures the internal organization of the software components as held in e.g., a configuration management tool.</li>
<li>体系结构用例：描述了体系结构的需求，关系到了超过一个常规的视图。是四个视图在某一个场景下进行描述Architecture use cases: capture the requirements for the architecture; related to more than one particular view</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/4%2B1_Architectural_View_Model.svg/2560px-4%2B1_Architectural_View_Model.svg.png'></p>
<h3 id="体系结构活动-amp-软件体系结构过程-Software-Architecture-Process"><a href="#体系结构活动-amp-软件体系结构过程-Software-Architecture-Process" class="headerlink" title="体系结构活动 &amp; 软件体系结构过程 Software Architecture Process"></a>体系结构活动 &amp; 软件体系结构过程 Software Architecture Process</h3><blockquote>
<p>  [!IMPORTANT]</p>
<p>【2015】【2017】简要描述软件架构过程中的一般活动，以及每个活动的主要输入和输出。Briefly describe the general activities in a software architecture process, and the major inputs and outputs at each activity.</p>
<p>长答案</p>
<ol>
<li>创建商业案例 输入：问题域，输出：商业案例</li>
<li>了解用户需求 输入：用户的模糊需求 输出：架构攸关的需求</li>
<li>创建或选择体系结构 输入：策略、模式和备选场景 输出：被选中的策略、模式和场景</li>
<li>沟通体系结构 输入：架构设计文档 输出：</li>
<li>分析和评估体系结构 输入：架构设计文档 输出：</li>
<li>实现体系结构 输入：架构设计文档 输出：架构设计的具体实现</li>
<li>保证体系结构的一致性 输入：架构设计的具体实现 输出：保持一致的架构设计具体实现</li>
</ol>
<p>短答案</p>
<ol>
<li><p>识别ASRs</p>
<ul>
<li><p>输入：无</p>
</li>
<li><p>输出：优化的质量属性场景</p>
</li>
</ul>
</li>
<li><p>架构设计</p>
<ul>
<li><p>输入：优化的质量属性场景、需求和约束、模式和决策</p>
</li>
<li><p>输出：一组候选视图的草图（模式决定）</p>
</li>
</ul>
</li>
<li><p>架构文档化</p>
<ul>
<li><p>输入：一组模式决定的草图（由模式决定）</p>
</li>
<li><p>输出：View &amp; Beyond</p>
</li>
</ul>
</li>
<li><p>架构评估</p>
<ul>
<li><p>输入：View &amp; Beyond、优化的质量属性场景</p>
</li>
<li><p>输出：View &amp; Beyond</p>
</li>
</ul>
</li>
</ol>
<p>其他</p>
<ol>
<li>通过StackHolder获取到ASRs（架构攸关需求）</li>
<li><p>通过分析得到Prioritized Quality Attribute Scenarios(高优先级质量属性解决方案)和Requirements，Constraints(需求和约束)</p>
</li>
<li><p>将上述部分，结合模式和策略，综合可以得到架构的设计</p>
</li>
<li>根据架构的设计得到由模式决定的候选视图的示意图，之后完成文档化</li>
<li>选择、组合视图，将文档进行进一步的评估，这一部分需要StackHolder的参与、也需要Prioritized Quality Attribute Scenarios和文档等作为参考。</li>
</ol>
</blockquote>
<p><strong>活动</strong></p>
<ol>
<li>创建系统的商业案例 Creating the business casenfor the System</li>
<li>理解需求 Understanding the requirements</li>
<li>创建和选择体系结构 Creating and selecting architecture</li>
<li>沟通体系结构(涉众，包括开发商) Communicating the architecture (stakeholders including developers)</li>
<li>分析或评估体系结构 Analysing or evaluating the architecture<ol>
<li>整体的方法论 Overall methodologies</li>
<li>具体技术的质量 Quality specific techniques</li>
</ol>
</li>
<li>实现体系结构Implementing the architecture</li>
<li>保证和体系结构的一致性Ensuring contormance to an architecture</li>
</ol>
<p><strong>过程</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec12/6.png'></p>
<h3 id="软件体系结构和体系结构知识领域-Software-Design-amp-Architecture-Knowledge-Areas"><a href="#软件体系结构和体系结构知识领域-Software-Design-amp-Architecture-Knowledge-Areas" class="headerlink" title="软件体系结构和体系结构知识领域 Software Design &amp; Architecture Knowledge Areas"></a>软件体系结构和体系结构知识领域 Software Design &amp; Architecture Knowledge Areas</h3><ol>
<li>软件设计基本原理 Software Design Basic Concepts<ol>
<li>整体设计原理 General design concepts</li>
<li>上下文：软件发展生命周期-需求、设计、编码和测试 Context: software development life cycle - requirements, design, construction and testing</li>
<li>设计过程：决策、活动、可运行产品 Design process(role, activity, work product)</li>
<li>软件设计的使能技术 Enabling techniques for software design</li>
</ol>
</li>
<li>核心问题(技术)：一致性、事件控制和处理、分发、异常处理、交互系统、持久化 Key Issues (technical): concurrency, control and handling of events, distribution, exception handling, interactive systems, persistence</li>
<li>软件结构和体系结构 Software Structure and Architecture<ol>
<li>体系结构结构和视点 Architecture Structures and viewpoints</li>
<li>体系结构风格和模式(宏观体系结构) Architectural styles and patterns (macro-architecture)</li>
<li>设计模式(微观体系结构) Design patterns (micro-architecture)</li>
</ol>
</li>
<li>软件设计方法Software Design Methods<ol>
<li>体系结构方法，比如属性驱动的设计 Architecture Methods (e .g., Attribute- Driven Design)</li>
<li>设计方法，比如动态系统发展方法 Design Methods (e.g., Dynamic System Development Method)</li>
</ol>
</li>
<li>软件设计的质量分析和评估 Software Design Quality Analysis and Evaluation<ol>
<li>质量属性 Quality attributes</li>
<li>质量分析和评估方法、技术和工具 Quality analysis and evaluation methods, techniques and tools<ol>
<li>设计回顾：比如SEI的体系结构权衡分析方法 Design reviews (e.g. SEI’s Architecture Trade-off Analysis Method)</li>
<li>静态分析和动态分析 Static analysis and dynamic analysis</li>
<li>模拟和原型 Simulation and prototyping</li>
</ol>
</li>
<li>度量 Measures:<ol>
<li>矩阵：体系结构级别 Metrics: Architecture level</li>
<li>技术特有度量指标 Technique specific measures</li>
</ol>
</li>
</ol>
</li>
<li>设计建模和展示 Design Modeling and Representation<ol>
<li>体系结构和设计符号(体系结构描述语言，Architecture Description Languages，ADL)Architecture and Design Notations (Architecture Description Languages(ADL))</li>
<li>UML Unified Modelling Language (UML)</li>
<li>设计文档(意见或其他) Design Documentation (Views &amp; Beyond)</li>
<li>其他：在活动、关注点和领域上的不同，比如ACME，Rapide。 Others: differ in ability, focus and domain (e.g. ACME, Rapide)</li>
</ol>
</li>
</ol>
<h2 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h2><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><blockquote>
<p>Functional requirements，Quality requirements（NFRs），Constraints</p>
<p>  [!IMPORTANT]</p>
<p>【2018】Software requirements, Quality attributes, ASRs 的区别和联系</p>
<ol>
<li>软件需求包括功能性需求和非功能性需求（又称质量需求）</li>
<li><p>质量属性是由软件的业务目标所决定，在功能性需求的基础上提供的整个系统的合乎需求的特性，是非功能需求的一种反应。</p>
</li>
<li><p>ASRs架构攸关需求是对于体系结构有着深远影响的需求，肯定是软件需求的一部分。</p>
</li>
</ol>
</blockquote>
<h4 id="功能性需求-Functional-Requirements"><a href="#功能性需求-Functional-Requirements" class="headerlink" title="功能性需求 Functional Requirements"></a>功能性需求 Functional Requirements</h4><ol>
<li>功能性需求定义了<strong>系统必须做什么</strong>并且强调了<strong>系统如何提供价值</strong>给涉众 Functional requirements state what the system must do and address how the system provides value to the stakeholders.</li>
<li>功能性需求意味着<strong>系统的行为</strong> Functional requirements means the behaviour of the system.</li>
<li>功能是系统<strong>完成其预期工作</strong>的能力，例如，使学生能够在线注册。Functionality is the ability of the system to do the work for which it was intended, e.g., enable students to enrol online.</li>
<li>通过使用<strong>许多可能的结构</strong>可以实现功能。Functionality may be achieved through the use of any<br>number of possible structures.</li>
<li>功能在很大程度上与结构无关，因为它可以作为单个整体系统存在而没有任何内部结构。Functionality is <strong>largely independent of structure</strong>, because it could exist as a single monolithic system without any internal structure.</li>
</ol>
<h4 id="质量需求-Quality-Requirements"><a href="#质量需求-Quality-Requirements" class="headerlink" title="质量需求 Quality Requirements"></a>质量需求 Quality Requirements</h4><ol>
<li>质量需求是系统应<strong>在其功能要求之上</strong>提供的整个系统的<strong>合乎需要的特性</strong>(又称质量属性) Quality requirements are desirable characteristics of the overall system (aka. quality attrilbutes) that system should provide on the top of its functional requirements.</li>
<li>质量要求是功能要求或整个产品的<strong>资格</strong>。软件体系结构限制了分配 Quality requirements are qualifications of the functional requirements or of the overall product.</li>
<li>如果质量属性很重要，则将<strong>功能</strong>(映射)到各种<strong>结构</strong>上。Software architecture constrains the allocatio (mapping) of the functionality onto various structures if quality attributes are important.</li>
</ol>
<h5 id="非功能性需求-Non-functional-Requirements"><a href="#非功能性需求-Non-functional-Requirements" class="headerlink" title="非功能性需求 Non-functional Requirements"></a>非功能性需求 Non-functional Requirements</h5><ol>
<li><strong>非功能</strong>要求或<strong>体系结构</strong>要求是用于<strong>质量属性</strong>的替代术语 Non-functional requirements or architectural requirements are alternative terms used for quality attributes.</li>
<li>无法正确使用功能，然后尝试适应非功能性要求(<strong>不具备翻新质量</strong>)。It is not possible to get the functionality right and then try to accommodate non-functional requirements (NO retro-fitting quality).</li>
<li>在任何设计决策中都必须考虑非功能性要求。Non-functional requirements must be taken into account during any design decision.</li>
<li>非功能性需求分为两大类：There are two broad categories ot non-functional requirements:<ol>
<li>在执行过程中==<strong>可观察</strong>(<strong>外部</strong>)==：系统满足其行为要求的程度如何？ 例如性能，安全性，可用性，可用性等。Observable (External) during execution: How well a system satisties its behavioural requirements? e.g., performance, security, availability, usability etc.</li>
<li>执行期间==<strong>不可观察</strong>(<strong>内部</strong>)==：系统的维护，集成或测试有多容易？ 例如，可修改性，可移植性，可重用性，可测试性等。Not observable (Internal) during execution: How easily a system can be maintained, integrated, or tested? e.g., modifiability, portability, reusability, testability etc.</li>
</ol>
</li>
<li>约束了限定的边界，之后的架构是在这个边界内找到最优的解。</li>
</ol>
<h4 id="约束-Constraints"><a href="#约束-Constraints" class="headerlink" title="约束 Constraints"></a>约束 Constraints</h4><ol>
<li>约束是具有<strong>零自由度</strong>的设计决策。A constraint is a design decision with <strong>ZERO</strong> degrees of freedom.</li>
<li>约束是已经做出的<strong>预先</strong>指定的设计决策。Constraints are pre-specified design decisions that have been already made.</li>
<li>通过<strong>接受</strong>设计决策并将其与其他受影响的设计决策进行<strong>协调</strong>，可以满足约束条件。Constraints are satisfied by accepting the design decision and reconciling it with other affected design decisions.</li>
</ol>
<h3 id="质量属性-1"><a href="#质量属性-1" class="headerlink" title="质量属性"></a>质量属性</h3><blockquote>
<p>内部 vs. 外部</p>
<p>质量属性方案建模 Modeling Quality Attribute Scenarios 重要</p>
<p>质量属性：Availability，Interoperability，……</p>
<p>Tactics 策略(原子级别的最小的决定)</p>
<p>Checklist for architectures design desicion - 设计覆盖的7个方面</p>
</blockquote>
<h4 id="质量属性方案建模-Modeling-Quality-Attribute-Scenarios"><a href="#质量属性方案建模-Modeling-Quality-Attribute-Scenarios" class="headerlink" title="质量属性方案建模 Modeling Quality Attribute Scenarios"></a>质量属性方案建模 Modeling Quality Attribute Scenarios</h4><blockquote>
<p>  [!IMPORTANT]</p>
<p>【必考】如何进行质量属性方案建模？请使用”刺激-相应”图的格式进行建模 How to model quality attribute scenarios? Graphically model one quality attributes in “stimulus-response” format:</p>
<ul>
<li><p>【2015】availiability and Performance</p>
</li>
<li><p>【2017】【2018】availiability and modifiability</p>
</li>
<li><p>【2019】interoperability and modifiability</p>
</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/5.png'></p>
<ol>
<li>刺激(Stimulus)：到达系统时需要考虑的<strong>条件</strong> Stimulus: A condition that needs to be considered when it arrives at a system.</li>
<li>刺激源(Source of Stimulus)：产生刺激的<strong>实体</strong>(人，系统或任何促动器) Source of Stimulus: An entity (human, system, or any actuator) that generates the stimulus.可能是输入、消息等等，对当前的状态有一个变化。</li>
<li>应对(Response)：刺激措施到来之后开展的<strong>活动</strong> Response: The activity undertaken after the arrival of the stimulus.</li>
<li>响应度量(Response Measure)：对刺激的响应应以某种方式进行<strong>测量</strong>，以便可以<strong>测试</strong>需求。Response Measure: The response to the stimulus should be measurable in some fashion so that the requirement can be testable.多长时间系统有反馈</li>
<li>环境(Environment)：发生刺激时系统的状况，例如过载，运行等 Environment: A system’s condition when a stimulus occurs, e.g. overloaded, running etc.</li>
<li>工件(Artifact)：需求适用的<strong>整个</strong>系统或系统的一部分。Artifact: The whole system or the portion of the system to which the requirement applies.可能是一个软件制品</li>
<li>只有定义好这6个元素，就能锁定架构的一个场景，之后可以用来进行架构的设计</li>
<li>刺激和响应发生在一个环境中：系统正常运行、系统过载、系统受到攻击、系统网络等出现了故障。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/7463b2c9d9824b88b92a/?dl=1'></p>
<h4 id="质量属性-2"><a href="#质量属性-2" class="headerlink" title="质量属性"></a>质量属性</h4><blockquote>
<p>  [!IMPORTANT]</p>
<p><strong>7.</strong> Please define “Availability” as a quality attribute. What do MTBF and MTTR stand for? How to calculate the availability of a system(e.g.SLA) as the probability?请给出质量属性中的“可用性的概念。MTBF 和 MTTR 分别代表什么？如何计算系统的可用性（例如 SLA）作为概率？</p>
<p>可用性是大多数 IT 应用程序的关键要求 Key requirement for most IT applications</p>
<p>度量方式：以所需的可用时间比例来衡量，例如 Measured by the proportion of the required time it is useable, e.g.</p>
<p>可将可用性计算为在指定的时间间隔内它将在要求的范围内提供指定服务的概率。Availability can be calculated as the probability that it will provide the specified services within required bounds over a specitied time interval.</p>
<ol>
<li>MTBF（平均无故障时间） MTBF (mean time between failures)</li>
<li>MTTR（平均维修时间） MTTR (mean time to repair)</li>
</ol>
<script type="math/tex; mode=display">
\frac{MTBF}{MTBF+MTTR}</script></blockquote>
<p>课上讲过的参考spricoder的博客</p>
<ol>
<li>Adaptability</li>
<li>Extensibility</li>
<li>Availability</li>
<li>Modularity</li>
<li>Configurability</li>
<li>Portability</li>
<li>Flexibility</li>
<li>Reusability</li>
<li>Interoperability</li>
<li>Testability</li>
<li>Performance</li>
<li>Auditability</li>
<li>Reliability</li>
<li>Maintainability</li>
<li>Responsiveness</li>
<li>Manageability</li>
<li>Recoverability</li>
<li>Sustainability</li>
<li>Scalability</li>
<li>Supportability</li>
<li>Stability</li>
<li>Usability</li>
<li>Security</li>
</ol>
<h4 id="Tactics-策略-原子级别的最小的决定"><a href="#Tactics-策略-原子级别的最小的决定" class="headerlink" title="Tactics 策略(原子级别的最小的决定)"></a>Tactics 策略(原子级别的最小的决定)</h4><ol>
<li>风格或样式运用策略来提供预期的收益 Style or pattern applies tactics to provide the promised benefit.</li>
<li>策略是影响质量属性响应<strong>控制</strong>的<strong>设计决策</strong>，例如冗余。A tactic is a design decision, .e.g. redundancy, that influences the control of a quality attribute response.</li>
<li>策略的<strong>集合</strong>称为体系结构策略。A collection of tactics is called an architectural strategy.</li>
<li>系统设计包括一组设计决策，其中一些决策可帮助控制<strong>质量</strong>属性响应；其他确保系统<strong>功能</strong>的实现 A system design consists of a collection of design decisions: some of these decisions help control the quality attribute response; others ensure achievement of system functionality.</li>
<li>像模式一样，策略也可以由其他策略组成，例如，冗余可以由数据的冗余，计算的冗余组成。设计人员根据需求选择一个或另一个 Like patterns, tactics may also be composed of other tactics, e.g., redundancy may be composed of redundancy of data, redundancy of computation-Designer chooses one or other depending upon requirements.</li>
<li>策略可以用作<strong>策略等级</strong> Tactics can be used as hierarchy of tactics.</li>
</ol>
<h4 id="Checklist-for-Design-and-Analysis"><a href="#Checklist-for-Design-and-Analysis" class="headerlink" title="Checklist for Design and Analysis"></a>Checklist for Design and Analysis</h4><blockquote>
<p>Responsibilities, Coordination, Data, Resources, Elements mapping, Binding time, Technology</p>
</blockquote>
<p><strong>以Usbility为例</strong></p>
<p>需要覆盖7个方面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/45.png'></p>
<h3 id="架构攸关的需求-Architecturally-Significant-Requirements"><a href="#架构攸关的需求-Architecturally-Significant-Requirements" class="headerlink" title="架构攸关的需求 Architecturally Significant Requirements"></a>架构攸关的需求 Architecturally Significant Requirements</h3><blockquote>
<p>How to gather and identify ASRs：需求、Workshop、Business goals、Utility tree</p>
<p>  [!IMPORTANT]</p>
<p>【2017】【2019】什么是ASR？列出提取和识别ASR的四种来源和方法。What are ASR? List four sources and methods for extracting and identifying ASRs</p>
<ol>
<li><p>ASRs 架构攸关需求是对体系结构产生深远影响的需求</p>
</li>
<li><p>四种来源和方法：</p>
<ul>
<li><p>从需求文档中收集ASR：MoScoW方法和用户故事</p>
</li>
<li><p>通过采访涉众来收集ASR：质量属性工作坊(QAW)</p>
</li>
<li><p>通过了解业务目标来收集ASR：</p>
</li>
<li><p>通过质量属性实体树(Utility Tree)来管理ASR：通过方案量化描述需求后，逐渐对质量属性进行分解细化，直到包含量化指标为止。</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="从需求文档中收集ASR-Gathering-ASRs-from-Requirements-Documents"><a href="#从需求文档中收集ASR-Gathering-ASRs-from-Requirements-Documents" class="headerlink" title="从需求文档中收集ASR Gathering ASRs from Requirements Documents"></a>从需求文档中收集ASR Gathering ASRs from Requirements Documents</h4><ol>
<li><p>无论是使用”MoSCoW”样式指定需求还是作为”用户故事”的集合来指定需求，这些都不能帮助您确定质量属性。Whether requirements are specifed using the “MoSCoW” style or as a collection of “user stories”, neither of these is much help in nailing down quality attributes.</p>
</li>
<li><p>MoSCoW样式：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cheny_com/article/details/6358456">MoSCoW的样式说明</a>：使用四个级别来定义一个需求的优先级程度</p>
</li>
<li><p>需求文档通常会以两种方式使架构师失败：Requirements documents often fail an architect in two ways:</p>
<ol>
<li>需求规范中的大多数内容都不会影响体系结构。Most of what is in a requirements specification does not affect the achitecture.<ol>
<li>系统应模块化 The system shall be modular</li>
<li>系统应显示出高可用性 The system shall exhibit high usability</li>
<li>系统应满足用户的性能期望 The system shall meet users’ performance expectations</li>
</ol>
</li>
<li>对架构师有用的大部分内容甚至都没有出现在最佳需求文档中 Much of what is useful to an architect is not in even the best requirements document.<ol>
<li>在收购环境中，需求文档代表的是收购方的利益，而不是开发商的利益。In an acquisition context, the requirements document represents the interests of the acquirer, not that of the developer.</li>
</ol>
</li>
</ol>
</li>
<li><p>如果某项要求影响了<strong>关键体系结构设计决策</strong>的制定，那么根据定义，它就是ASR。If a requirement affects the making of a critical architectural design decision, it is by definition an ASR.</p>
</li>
</ol>
<h4 id="通过和涉众面谈来收集ASR-Gathering-ASRs-by-Interviewing-Stakeholders"><a href="#通过和涉众面谈来收集ASR-Gathering-ASRs-by-Interviewing-Stakeholders" class="headerlink" title="通过和涉众面谈来收集ASR Gathering ASRs by Interviewing Stakeholders"></a>通过和涉众面谈来收集ASR Gathering ASRs by Interviewing Stakeholders</h4><ol>
<li>质量属性工作坊(QAW) Quality Attribute Workshop (QAW)<ol>
<li>QAW演示和介绍 QAW presentation and introductions</li>
<li>业务任务介绍 Business mission presentation</li>
<li>架构计划介绍 Architectual plan presentation</li>
<li>架构驱动程序的识别：就精简的架构驱动程序列表达成共识，其中包括总体需求，业务驱动程序，约束和质量属性。Identification of architectural drivers: to reach a consensus on a ditilled list of architectural drivers that includes overall requirements, business drivers, constraints, and quality attributes.</li>
<li>场景集思广益：每个利益相关者都表达一个场景，表示他/她对系统的关注。Scenario brainstorming: each stakeholder expresses a scenario representing his/ her concerns with respect to the system.</li>
<li>方案合并(合并类似方案) Scenario consolidation (merging similar scenarios)</li>
<li>方案优先级(通过投票) Scenario prioritization(by voting)</li>
<li>方案细化：对最重要的方案进行细化和阐述。Scenario refinement: the top scenarios are refined and elaborated.</li>
</ol>
</li>
<li>QAW的结果包括架构驱动程序列表和利益相关者(作为一个小组优先考虑)的一组(2A方案)。The results of QAW include a list of architectural drivers and a set of QA scenarios that the stakeholders (as a group prioritized).</li>
</ol>
<h4 id="通过Utility树来获取ASR-Capturing-ASRs-in-a-Utility-Tree"><a href="#通过Utility树来获取ASR-Capturing-ASRs-in-a-Utility-Tree" class="headerlink" title="通过Utility树来获取ASR Capturing ASRs in a Utility Tree"></a>通过Utility树来获取ASR Capturing ASRs in a Utility Tree</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/48.png'></p>
<ol>
<li>将scenario使用量化的方式来描述，之后才可以使用测试等方式来确定是否实现了要求。</li>
<li>逐渐对质量需求进行分解，分解到含有量化指标为止。</li>
<li>然后将分解的结果进行细化</li>
</ol>
<h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><h3 id="Architectural-Pattern"><a href="#Architectural-Pattern" class="headerlink" title="Architectural Pattern"></a>Architectural Pattern</h3><p>架构模式是一组架构设计决策，适用于重复出现的设计问题，并进行了参数化处理以解决出现该问题的不同软件开发环境。An architectural pattern is a set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears</p>
<p>架构模式建立了以下之间的关系：Architecture pattern establishes a relationship between:</p>
<ol>
<li><strong>背景</strong>：世界上经常发生的常见情况，会引起问题 A context: A recurring, common situation in the world that gives rise to a problem.</li>
<li>一个<strong>问题</strong>：在给定的上下文中出现的问题，经过适当概括 A problem: The problem, appropriately generalized, that arises in the given context.</li>
<li><strong>解决方案</strong>：针对问题的成功架构解决方案，并进行了适当抽象 A solution: A successful architecture resolution to the problem, appropriately abstracted.<ul>
<li>元素</li>
<li>关系</li>
<li>约束</li>
</ul>
</li>
</ol>
<h3 id="Module-Patterns"><a href="#Module-Patterns" class="headerlink" title="Module Patterns"></a>Module Patterns</h3><blockquote>
<p>Layered pattern（micro-kernel pattern）</p>
<p>  [!IMPORTANT]</p>
<p>Explain the context, benefits and limitations of Layered Architecture Style.</p>
<p>分层模式定义了层（提供一组内聚服务的模块分组）和层之间的单向允许使用关系。该模式通常通过将表示层的框堆叠在一起来以图显示。<br>优点：<br>可以将复杂的问题分成几个部分；</p>
<p>具有很高的可扩展性和可重用性；</p>
<p>组件之间的连接可以通过相邻性来显示，并且“上”和“下”很重要。<br>缺点：<br>添加层会增加系统的前期成本和复杂性；</p>
<p>层会导致性能下降；</p>
<p>如果分层设计不正确，它实际上可能会妨碍系统，因为它不提供较低级别的抽象；</p>
<p>如果出现许多层桥接实例，系统可能无法满足严格分层有助于实现的可移植性和可修改性目标；</p>
</blockquote>
<h4 id="分层模式-Layered-Pattern"><a href="#分层模式-Layered-Pattern" class="headerlink" title="分层模式 Layered Pattern"></a>分层模式 Layered Pattern</h4><p>对应4+1视图中的逻辑视图</p>
<h3 id="Component-Connector-Patterns"><a href="#Component-Connector-Patterns" class="headerlink" title="Component-Connector Patterns"></a>Component-Connector Patterns</h3><blockquote>
<p>Broker pattern, Model-view-controller pattern, Pipe-and-filter pattern, Client-server pattern, Peer-to-peer pattern, Service-oriented pattern, Publish-subscribe pattern, Share-data pattern</p>
<p>  [!IMPORTANT]</p>
<p>【2015】【2019】解释代理架构模式的上下文、好处和局限性。Explain the context, benefits and limitations of Broker Architecture Pattern</p>
<ol>
<li><p>上下文：多个同步或异步交互的远程对象组成的系统，broker模式已定义了运行时组件broker，它协调多个客户机和服务器之间的通讯。</p>
</li>
<li><p>好处：提高了Client和Server之间的交互性、提高可伸缩性和可扩展性、解决了单体应用的性能瓶颈、大规模集群的性能提高，但是单点性能会下降。</p>
</li>
<li><p>局限性：代理增加了前期复杂度、可能成为通信的屏障、可能成为攻击的目标、难以测试。</p>
</li>
<li><p>SOA延续了broker的思想，查找服务和使用服务都要通过broker，而SOA只在查找式通过register，分散了broker的职责，降低了单点风险</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2018】Layered pattern 和 Multi-tier pattern 的区别</p>
<ol>
<li>Layered Pattern是Module Style，而Multi-tier Pattern 是Allocation Style</li>
<li><p>Layered Pattern是将任务拆解成一个个处于特定抽象级别的子层次，每层为下一层提供更高层次的服务，核心是关注点分离。</p>
</li>
<li><p>Multi-tier Patten中的层是逻辑的组合，没有层次模式的强依赖关系，在不同部署环境中分层不同但是软件完成的内容一致。</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>What is the nature of component connector style?以MVC pattern举例</p>
<p>MVC模式将系统功能分为三个组件：模型、视图和在模型和视图之间进⾏中介的控制器</p>
<p>模型是应⽤程序数据或状态的表⽰，它包含（或提供）应⽤程序逻辑。</p>
<p>视图是⽣成表⽰的⽤⼾界⾯组件或者允许某种形式的⽤⼾输⼊</p>
<p>控制器管理模型和视图之间的交互。</p>
</blockquote>
<h4 id="代理模式-Broker-Pattern"><a href="#代理模式-Broker-Pattern" class="headerlink" title="代理模式 Broker Pattern"></a>代理模式 Broker Pattern</h4><ol>
<li>Broker可以理解为中间人，撮合双方达成交易。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/7.png'></p>
<ol>
<li>优点<ol>
<li>Interoperability：根本目的，提高Server-Client之间的交互性</li>
<li>Scaliability：可伸缩和扩展</li>
<li>Modifiabiliy：</li>
<li>两面性：<ol>
<li>Security：代理对象屏蔽了系统内部的具体实现</li>
<li>Reliability：服务降级和实例重启</li>
<li>Availability：</li>
</ol>
</li>
</ol>
</li>
<li>缺点<ol>
<li>Security：成为被攻击的对象</li>
<li>Reliabiliy：可靠性会降低</li>
</ol>
</li>
<li>两面性：<ol>
<li>Performance：整体大集群的性能可能会提高(QPS等提高)，但是局部单点性能会下降，多次网络请求、多次匹配，有可能会抵消。</li>
</ol>
</li>
</ol>
<h4 id="模型-视图-控制器模式-Model-View-Controller-Pattern-MVC"><a href="#模型-视图-控制器模式-Model-View-Controller-Pattern-MVC" class="headerlink" title="模型-视图-控制器模式 Model-View-Controller Pattern(MVC)"></a>模型-视图-控制器模式 Model-View-Controller Pattern(MVC)</h4><ol>
<li>使用运行时、动态、相互之间的关系来审视，集成到了开发框架中，也是分层架构的变种(会强调各模块之间的约束关系，model不可以直接返回到controller)<ol>
<li>model 业务逻辑</li>
<li>view 处理用户展示，接收用户操作</li>
<li>controller 对用户操作进行处理，将信息通知给model</li>
</ol>
</li>
<li>model -&gt; controller 不会产生通信</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/9.png'></p>
<h4 id="Pipe-and-Filter-Pattern-管道和过滤模式"><a href="#Pipe-and-Filter-Pattern-管道和过滤模式" class="headerlink" title="Pipe-and-Filter Pattern 管道和过滤模式"></a>Pipe-and-Filter Pattern 管道和过滤模式</h4><ol>
<li>filter：相当于component，起到数据处理、计算作用，每个filter有input和多个output，数据处理后传递给后续的部分。</li>
<li>pipe：连接filter，相当于connector，将output导入到其他的filter的input中去，不会孤立存在。</li>
<li>管道和过滤模式不会孤立存在，应用在顺序处理结构，有一系列的数据结构filter，体现依赖关系。</li>
<li>场景应用在科学计算的场景中，需要避免出现环形的filter，不适用于有很多交互产生的场景。</li>
</ol>
<h4 id="Client-Server-Pattern-客户端-服务端模式"><a href="#Client-Server-Pattern-客户端-服务端模式" class="headerlink" title="Client-Server Pattern 客户端-服务端模式"></a>Client-Server Pattern 客户端-服务端模式</h4><ol>
<li>包含两类不同的component</li>
<li>请求发起client、server接收请求，这里没有broker，不能动态改变client和server的关系，相对更固定，但是一个client可以连接多个server</li>
<li>一个component在一个关系中可以是client，也可能是server，非绝对，但是成对的关系相对固定。</li>
<li>会受到负载的限制。</li>
<li>Server可能有性能瓶颈，但是可以通过事先规划避免。</li>
<li>Server可能单点失效，但是broker可以控制</li>
</ol>
<h4 id="Peer-to-Peer-Pattern-点对点模式"><a href="#Peer-to-Peer-Pattern-点对点模式" class="headerlink" title="Peer-to-Peer Pattern 点对点模式"></a>Peer-to-Peer Pattern 点对点模式</h4><ol>
<li>这一刻是提供者，下一刻就是消费者，是对等的。</li>
<li>不单单提供服务，还能提供物流(对于整个网络)</li>
<li>对每一个peer可能会给他一个规定对的连接数</li>
</ol>
<h4 id="Service-Oriented-Pattern-面向服务的模式"><a href="#Service-Oriented-Pattern-面向服务的模式" class="headerlink" title="Service-Oriented Pattern 面向服务的模式"></a>Service-Oriented Pattern 面向服务的模式</h4><ol>
<li>broker架构的延续。</li>
<li>component包含服务提供者、服务消费者。</li>
<li>除了这些component还有ESB、企业服务组件、连接处理，包括发现、注册。</li>
<li>Registry of Services</li>
<li>Orchestration Server 不同的Service按照一定的顺序进行编排，提供更高级的(申请贷款流程)</li>
<li>Connectors：<ol>
<li>SOAP：</li>
<li>REST：</li>
<li>Asynchronous messaging connector</li>
</ol>
</li>
</ol>
<blockquote>
<p>  [!IMPORTANT]</p>
<p>【2015】简要描述面向服务架构 (SOA) 的基本原则，并讨论 SOA 对互操作性、可伸缩性和安全性等质量属性的影响 Briefly describe the fundamental principles of Service Oriented Architecture(SOA) and discuss the impact of SOA on quality attributes like interoperability, scalability and security</p>
<ol>
<li>SOA的基本原则<ol>
<li>服务契约:服务按照描述文档所定义的服务契约行事</li>
<li>服务封装:除了服务契约所描述内容，服务将对外部隐藏实现逻辑</li>
<li>服务重用:将逻辑分布在不同的服务中，以提高服务的重用性</li>
<li>服务组合:一组服务可以协调工作，组合起来形成定制组合业务需求</li>
<li>服务自治:服务对所封装的逻辑具有控制权</li>
<li>服务无状态:服务将一个活动所需保存的资讯最小化</li>
</ol>
</li>
<li>SOA对互操作性的影响<ol>
<li>SOA具有更高的互操作性：符合开放标准，可以更好的重用服务</li>
<li>支持服务的自动识别、发现、注册和调用等等</li>
</ol>
</li>
<li>SOA对可伸缩性的影响<ol>
<li>SOA具有更高的可伸缩性：服务自身高内聚、服务间松耦合，最小化维护的影响</li>
<li>但是SOA也会带来系统复杂度较高的问题</li>
</ol>
</li>
<li><p>SOA对安全性的影响</p>
<ol>
<li>中间件可能会成为性能的瓶颈</li>
<li>ESB等中间件都可以成为被攻击的目标</li>
<li>多服务导致攻击的跟踪、溯源和防御成为困难。</li>
</ol>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2019】微服务和SOA的区别，相同点</p>
<ol>
<li><p>相同点：微服务和SOA都是分布式架构，微服务是SOA的一种扩展，都包含了服务契约、服务封装、服务重用、服务组合、服务自治和服务无状态等基本特点。</p>
</li>
<li><p>微服务去掉了SOA架构中的ESB，采用轻量级通信机制(HTTP、REST)进行服务之间的通信。</p>
</li>
<li>微服务的管理和部署结合DevOps实现自动化，可以对服务进行自动化部署和监控预警。</li>
<li>微服务引入了API网关、对客户端屏蔽访问各项服务的问题。</li>
<li>微服务引入了熔断器：避免出现服务失效或网络问题等导致的级联故障。</li>
</ol>
</blockquote>
<h4 id="Publish-Subscribe-Pattern-发布-订阅模式"><a href="#Publish-Subscribe-Pattern-发布-订阅模式" class="headerlink" title="Publish-Subscribe Pattern 发布-订阅模式"></a>Publish-Subscribe Pattern 发布-订阅模式</h4><ol>
<li>subscribe注册对于publiser进行注册</li>
<li>某一个publiser发布自己的消息可能订阅其他消息（朋友圈微博）</li>
</ol>
<h4 id="Shared-Data-Pattern-共享数据模式3"><a href="#Shared-Data-Pattern-共享数据模式3" class="headerlink" title="Shared-Data Pattern 共享数据模式3"></a>Shared-Data Pattern 共享数据模式3</h4><ol>
<li>中间安全数据会被很多人共享登录访问</li>
</ol>
<h3 id="Allocation-Patterns"><a href="#Allocation-Patterns" class="headerlink" title="Allocation Patterns"></a>Allocation Patterns</h3><blockquote>
<p>Map-reduce pattern，Multi-tier pattern</p>
</blockquote>
<h4 id="Map-Reduce-Pattern"><a href="#Map-Reduce-Pattern" class="headerlink" title="Map-Reduce Pattern"></a>Map-Reduce Pattern</h4><ol>
<li>软件和外部环境的关系 部署</li>
<li>map对数据进行抽取所需要的信息信息转换</li>
<li>可以有多个map 处理数据工作内容不一样</li>
<li>相互独立可以运行</li>
<li>reduce进行合并产出想要的答案</li>
</ol>
<h4 id="Multi-Tier-Pattern-多层模式"><a href="#Multi-Tier-Pattern-多层模式" class="headerlink" title="Multi-Tier Pattern 多层模式"></a>Multi-Tier Pattern 多层模式</h4><ol>
<li>部署的环境划分</li>
<li>layer是真实存在的</li>
<li>这里是逻辑的组合没有和层的强依赖关系</li>
<li>不同的部署环境里面分层不同但是软件完成内容一样</li>
</ol>
<h3 id="Patterns-VS-Tactics"><a href="#Patterns-VS-Tactics" class="headerlink" title="Patterns VS Tactics"></a>Patterns VS Tactics</h3><blockquote>
<p>  [!IMPORTANT]</p>
<p>【2015】描述架构设计中架构模式和决策之间的关系。给出可以在架构设计过程中使用的任何四种决策的名称，并描述每种决策的目的。Describe the relationships between architectual patterns and tactics in architecture design. Give name of any four tactics that can be used during architecture design and describe the purpose of each of them</p>
<ol>
<li><p>架构模式与决策之间的关系</p>
<ol>
<li><p>决策比模式更简单，仅有单一的结构或机制来应对单一的架构驱动</p>
</li>
<li><p>决策是构成架构模式的重要组成部分</p>
</li>
<li><p>架构模式通常将许多个决策组合在一起。</p>
</li>
<li><p>大多数架构模式都包含不同的决策，这些决策可能有共同的目的或者常被用于实现不同的质量属性。</p>
</li>
<li>决策和架构模式共同构成了软件设计时的工具。</li>
</ol>
</li>
<li><p>四种决策的名称</p>
<p>ping/echo</p>
<p>heartbeat</p>
<p>软件升级</p>
<p>增加内聚</p>
<p>降低耦合</p>
<p>重写配置</p>
<p>⾃检（⾃我测试）</p>
<p>异常检测</p>
<p>延迟绑定</p>
<p>识别攻击者</p>
<p>控制输入</p>
<p>限制复杂度</p>
<p>减少单点失效</p>
</li>
</ol>
</blockquote>
<ol>
<li>策略比模式简单。他们使用<strong>单一的结构或机制</strong>来应对<strong>单一的架构力量</strong> Tactics are simpler than patterns; they use a single structure or mechanism to address a single architectural force.</li>
<li>模式通常将多个设计决策组合到一个包中 Patterns typically combine multiple design decisions into a package.</li>
<li>模式和策略共同构成了软件设计师的主要工具 Patterns and tactics together constitute the software architect’ s primary tools.</li>
<li><strong>战术是设计的“构建块”</strong>，可从中创建建筑模式 Tactics are “building blocks” of design from which architectural patterns are created.</li>
<li>大多数模式包含几种不同的策略，这些策略可能 Most patterns consist of several different tactics that may:<ol>
<li>都有共同的目的 all serve a common purpose,</li>
<li>经常被选择来承诺不同的质量属性 be often chosen to promise different quality attributes</li>
</ol>
</li>
<li>示例：分层图案 Example: layered pattern<ol>
<li>提高语义连贯性 Increase semantic coherence</li>
<li>限制依赖 Restrict dependencies</li>
</ol>
</li>
<li>tactic是设计最小粒度tactic进行组合一个tactic是为了某一个质量属性也会影响其他属性（正面、负面）</li>
<li>针对某一个质量属性Modifiablity 相关的tactic 和pattern之间的关系是否涉及到</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec14/26.png'></p>
<h2 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h2><blockquote>
<p>  [!IMPORTANT]</p>
<p>【2017】<strong>软件设计的三个变化维度，每个维度的变化点。不同的绑定时间如何影响可修改性和可测试性</strong>。</p>
<ol>
<li><p>三个变化维度：</p>
<ul>
<li><p>面向对象 OOP，强调重用性、灵活性和扩展性。</p>
</li>
<li><p>面向切面 AOP，满足扩展的需求，可以在程序中自由的扩展功能</p>
</li>
<li><p>面向服务 SOA，是系统发布功能的一种方式，且基于这种方式下不同的系统之间可以有效的沟通、协作。</p>
</li>
</ul>
</li>
<li><p>设计时，开发时，测试时，发布时，运行时：可修改性降低，可测试性升高</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2018】<strong>软件架构的关注点有哪些</strong>？利益相关方有哪些？</p>
<ol>
<li><p>软件架构的关注点</p>
<ol>
<li><p>利益相关者 Stakeholders addressed</p>
</li>
<li><p>解决的问题 Concerns addressed</p>
</li>
<li><p>语言，建模技巧 Language, modeling techniques</p>
</li>
<li><p>决策，模式 Tactics, Pattern</p>
</li>
</ol>
</li>
<li><p>利益相关方有哪些？</p>
<ol>
<li>顾客 Customer</li>
<li>用户 User</li>
<li>建筑师 Architect</li>
<li>需求工程师 Requirements engineer</li>
<li>设计师 Designer</li>
<li>实施者 Implementer</li>
<li>测试师，集成师 Tester, integrator</li>
<li>维护者 Maintainer</li>
<li>产品经理 Product manager</li>
<li>质量保证人 Quality assurance people</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="General-Design-Strategy"><a href="#General-Design-Strategy" class="headerlink" title="General Design Strategy"></a>General Design Strategy</h3><blockquote>
<p>  [!IMPORTANT]</p>
<p>【2017】【2019】在设计软件时应用了哪些通用设计策略？为每个策略提供一个带有软件架构的简明工作示例。What are generic design strategies applied in designing software? Give a concise working example with software architecture for each strategy.</p>
<ol>
<li><p>抽象：使用抽象让设计师关注本身结构而不关心实现，比如将系统抽象为组件和连接件或抽象为模块。</p>
</li>
<li><p>分解：针对某一个系统关注点分解后处理，比如将整个系统分解或将某个模块分解。</p>
</li>
<li>分而治之：将每个模块分别处理</li>
<li>生成与测试：将一个特定的设计看作是一个假设；根据测试路径生成测试用例。</li>
<li>迭代与细化：使用迭代的方法，ADD方法多次迭代直到满足所有ASR</li>
<li>复用元素：重用在设计过程中出现了可以复用的元素，重用现有架构</li>
</ol>
<p>Abstraction，Decomposition，Divide VS. conquer，Generation and test，Reuse</p>
</blockquote>
<ol>
<li>Abstraction</li>
<li>Generate &amp; Test</li>
<li>Decomposition</li>
<li>Reusable Elements</li>
<li>Iteration &amp; Refinement</li>
<li>Divide &amp; Conquer</li>
</ol>
<h3 id="Categories-of-design-desicions"><a href="#Categories-of-design-desicions" class="headerlink" title="Categories of design desicions"></a>Categories of design desicions</h3><blockquote>
<p>Responsibilities, Coordination, Data, Resources, Elements mapping, Binding time, Technology</p>
</blockquote>
<h3 id="Attribute-Driven-Design-2-0"><a href="#Attribute-Driven-Design-2-0" class="headerlink" title="Attribute-Driven Design 2.0"></a>Attribute-Driven Design 2.0</h3><blockquote>
<ul>
<li><p>Inputs to and outputs of ADD</p>
</li>
<li><p>8-step process:</p>
<ol>
<li>confirm requirements, 2. choose an element to decompose, 3. identify ASRs, 4. choose a design satisfying ASRs, 5. instantiate elements &amp; allocate responsibilities, 6. define interface, 7. verify &amp; refine requirements, 8. repeat step 2-7 until all ASRs satisfied</li>
</ol>
</li>
<li><p>Step4:</p>
<p>4.1 identify concerns, 4.2 list alternatives, 4.3 select patterns/tactics, 4.4 determine relations, 4.5 capture views, 4.6 resolve inconsistencies</p>
<p>[!IMPORTANT]</p>
</li>
</ul>
<p>【2018】描述ADD过程</p>
<ol>
<li><p>确定有足够的需求信息</p>
</li>
<li><p>选择要分解的系统要素</p>
</li>
<li><p>确定所选的元素的ASR</p>
</li>
<li><p>选择符合ASR的设计</p>
<ol>
<li>找出设计问题</li>
<li><p>列出子关注点替代模式/决策</p>
</li>
<li><p>从清单中选择模式/决策</p>
</li>
<li>确定模式/决策与ASR之间的关系</li>
<li>记录初步的架构视图</li>
<li>评估并解决不一致的问题</li>
</ol>
</li>
<li><p>实例化架构元素并分配职责</p>
</li>
<li><p>实例化元素定义接口</p>
</li>
<li><p>验证和完善需求</p>
</li>
<li><p>重复进行2-7步直到满足所有的ASR</p>
</li>
</ol>
</blockquote>
<h4 id="ADD的步骤概述"><a href="#ADD的步骤概述" class="headerlink" title="ADD的步骤概述"></a>ADD的步骤概述</h4><h5 id="步骤1：确认有足够的需求信息"><a href="#步骤1：确认有足够的需求信息" class="headerlink" title="步骤1：确认有足够的需求信息"></a>步骤1：确认有足够的需求信息</h5><ol>
<li>系统的涉众已根据业务和任务目标确定了需求的优先级。The system’s stakeholders have prioritized the requirements according to business and mission goals.</li>
<li>您可以确定设计期间要重点关注的系统元素。You determine which system elements to focus on during the design.</li>
<li>您确定是否有关于系统质量属性要求的足够信息：“刺激反应”形式（图）。You determine if there is sufficient information about the quality attribute requirements of the system: stimulus-response form.</li>
</ol>
<h5 id="步骤2：选择要分解的系统元素"><a href="#步骤2：选择要分解的系统元素" class="headerlink" title="步骤2：选择要分解的系统元素"></a>步骤2：选择要分解的系统元素</h5><ol>
<li>如果是第一次作为“未开发”开发的一部分，则将所有需求分配给系统。If the first time as part of a greenfield development, all requirements are assigned to the system.</li>
<li>完善部分设计的系统时，系统已划分为多个元素，并为其分配了要求。从这些元素中选择一个作为聚焦点。When refining a partially designed system, the system has been partitioned into elements with requirements assigned to them. Choose one of these elements as the focus.</li>
<li>Ploughed field：耕种过的地</li>
</ol>
<h5 id="步骤3：确定所选元素的ASR"><a href="#步骤3：确定所选元素的ASR" class="headerlink" title="步骤3：确定所选元素的ASR"></a>步骤3：确定所选元素的ASR</h5><p>根据对每个需求的高影响，中影响或低影响，根据对架构的相对影响第二次对这些相同需求进行排名。Rank these same requirements a second time based on their relative impact on the architecture as assigning high impact,” medium impact,” or” low impact” to each requirement.</p>
<p>(H，H) (H，M) (H，L) (M，H) (M，M) (M，L) (L，H) (L，M) (L，L)</p>
<ol>
<li>第一个字母表示要求对涉众的重要性 The first letter indicates the importance of requirements to stakeholders</li>
<li>第二个字母表示需求对体系结构的潜在影响 The second letter indicates the potential impact of requirements on the architecture</li>
</ol>
<h5 id="步骤4：选择符合ASR的设计"><a href="#步骤4：选择符合ASR的设计" class="headerlink" title="步骤4：选择符合ASR的设计"></a>步骤4：选择符合ASR的设计</h5><ul>
<li><p>Step 4.1: Identify design concerns - 找出设计问题</p>
<ol>
<li>如何解决设计中的 ASR？How to address ASRs in your design?</li>
<li>如何将问题划分成几个子问题。</li>
</ol>
</li>
<li><p>Step 4.2: List alternative patterns/tactics for subordinate concerns - 列出子关注点替代模式/决策</p>
<p>对于列表中的每个模式，您应该 For each pattern on your list, you should</p>
<ol>
<li>识别每个模式的区分参数，以帮助您在模式和战术中进行选择 identify each pattern s discriminating parameters to help you choose among the patterns and tactics</li>
<li>估计区分参数的值 estimate the values of the discriminating parameters</li>
</ol>
</li>
<li><p>Step 4.3: Select patterns/tactics from the list - 从清单中选择模式/决策</p>
<ol>
<li>使用每种模式时需要进行哪些权衡？ What tradeoffs are expected when using each pattern?</li>
<li>模式之间的结合程度如何？ How well do the patterns combine with each other?</li>
<li>是否有任何模式互斥？ Are any patterns mutually exclusive?</li>
</ol>
</li>
<li><p>Step 4.4: Determine relationship between patterns/ tactics and ASRs - 确定模式/决策与ASR之间的关系</p>
<ol>
<li>考虑到目前为止确定的模式/策略，我决定它们之间的关系。Consider the patterns/ tactics identified so far and decide how they relate to each other. The combination of the selected patterns may result in a new pattern.</li>
<li>所选图案的组合可以产生新的图案。</li>
</ol>
</li>
<li><p>Step 4.5: Capture preliminary architectural view - 记录初步的架构视图</p>
<ol>
<li>通过开始捕获不同的架构视图来描述您选择的模式。Describe the patterns you have selected by starting to capture different architectural views.</li>
<li>在此阶段，您无需创建完整记录的架构视图（You don’t need to create fully documented architectural views at this stage)</li>
</ol>
</li>
<li><p>Step 4.6: Evaluate and resolve inconsistencies - 评估并解决不一致的问题</p>
<ol>
<li>根据体系结构驱动程序评估设计。Evaluate the design against the architectural drivers.</li>
<li>确定是否有未考虑的体系结构驱动程序。Determine if there are any architectural drivers that were not considered.</li>
<li>评估替代模式或应用其他策略。Evaluate alternative patterns or apply additional tactics.</li>
<li>将当前元素的设计与体系结构中其他元素的设计进行评估，并解决所有不一致之处。Evaluate the design of the current element against the design of other elements in the architecture and resolve any inconsistencies.</li>
</ol>
</li>
</ul>
<h5 id="步骤5：实例化架构元素并分配职责"><a href="#步骤5：实例化架构元素并分配职责" class="headerlink" title="步骤5：实例化架构元素并分配职责"></a>步骤5：实例化架构元素并分配职责</h5><ol>
<li>实例化您选择的每种元素的一个实例。Instantiate one instance of every type of element you chose.</li>
<li>根据子元素的类型分配职责。Assign responsibilities to child elements according to their type.</li>
<li>在其子级之间分配与父级元素相关联的责任。Allocate responsibilities associated with the parent element among its children.</li>
<li>分析并记录您所做的设计决策。Analyze and document the design decisions you have made.</li>
</ol>
<h5 id="步骤6：为实例化元素定义接口"><a href="#步骤6：为实例化元素定义接口" class="headerlink" title="步骤6：为实例化元素定义接口"></a>步骤6：为实例化元素定义接口</h5><ol>
<li>接口描述了 PROVIDES 和 REQUIRES 假设，即软件元素之间相互联系。Interfaces describe the PROVIDES and REQUIRES assumptions that software elements make about one another.<ol>
<li>练习涉及您实例化的元素的功能要求。Exercise the functional requirements that involve the elements you instantiated.</li>
<li>观察由一个元素产生并由另一元素消耗的任何信息。Observe any information that is produced by one element and consumed by another.</li>
</ol>
</li>
</ol>
<h5 id="步骤7：验证和完善需求，并使其成为实例化元素的约束"><a href="#步骤7：验证和完善需求，并使其成为实例化元素的约束" class="headerlink" title="步骤7：验证和完善需求，并使其成为实例化元素的约束"></a>步骤7：验证和完善需求，并使其成为实例化元素的约束</h5><ol>
<li>验证分配给父元素的所有需求是否已分配给一个或多个子元素。Verify that all requirements assigned to the : parent element have been allocated to one or more child elements.</li>
<li>将分配给子元素的所有职责转换为各个元素的功能需求。Translate any responsibilities assigned to child elements into functional requirements for the individual elements.</li>
</ol>
<h5 id="步骤8：重复进行，直到满足所有ASR"><a href="#步骤8：重复进行，直到满足所有ASR" class="headerlink" title="步骤8：重复进行，直到满足所有ASR"></a>步骤8：重复进行，直到满足所有ASR</h5><h4 id="Inputs-amp-Outputs-to-ADD"><a href="#Inputs-amp-Outputs-to-ADD" class="headerlink" title="Inputs &amp; Outputs to ADD"></a>Inputs &amp; Outputs to ADD</h4><ul>
<li><p>Input ：: Requirements?</p>
<p>文档提供的信息是不充分的。</p>
</li>
<li><p>Output</p>
<ol>
<li>软件元素：履行各种角色和职责，具有预定属性并与其他软件元素相关以组成系统架构的计算或开发工件 software element: a computational or developmental artifact that fulills various roles and responsibilities, has defined properties, and re elates to other software elements to compose the architecture of a system</li>
<li>角色：一组相关职责 role: a set of related responsibilities</li>
<li>责任：软件元素提供的功能，数据或信息 responsibility: the functionality, data, or information that a software element provides</li>
<li>属性：有关软件元素的附加信息 property: additional information about a software element</li>
<li>关系：两个软件元素如何相互关联或交互的定义 relationship: a definition of how two software elements are associated with or interact with one another</li>
</ol>
</li>
</ul>
<h2 id="Document-Architecture"><a href="#Document-Architecture" class="headerlink" title="Document Architecture"></a>Document Architecture</h2><blockquote>
<p>Views：</p>
<ul>
<li>Styles (viewpoints), patterns and views</li>
<li>Structural views: module views, component-and -connector views, allocation views</li>
<li>Quality views</li>
</ul>
<p>Documenting views: 1. build stakeholder/ view table, 2. combine views, 3. prioritise &amp; stage</p>
<p>Info. beyond views: documentation info &amp; architecture info (mapping between views)</p>
<p>Documentation package: views + beyond</p>
<p>  [!IMPORTANT]</p>
<p>软件架构风格</p>
<ol>
<li><p>module Styles：认为体系结构是由模块组成。模块是实现单元的集合，它提供了一组一致的职责。</p>
</li>
<li><p>C &amp; C Styles 认为体系结构是由组件(主要的处理单元和数据存储)、连接件(组件之间的交互路径)组成的。</p>
</li>
<li><p>Allocation Styles 认为体系结构是由软件元素(软件元素具有环境所需的属性)和环境元素(环境元素有提供给软件的属性)组成的，展示了软件如何与环境关联</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2017】【2019】典型的软件架构文档包中应该包含哪些内容？简要描述每个组件及其用途。What should be included in a typical software architecture documentation package? Briefly describe each component and its purpose.</p>
<ol>
<li>包含View和Beyond</li>
<li>Beyond部分：<ol>
<li>文档路线图：包含了范围和总结、简单摘要等。</li>
<li>视图的文档组织方式：描述了本文档中视图是如何组织的。</li>
<li>系统概述：从整体上描述了当前架构的简要说明、业务目标(驱动因素)等等。</li>
<li>视图之间的映射关系：描述了不同视图之间的映射关系。</li>
<li>系统原理：从整体上描述了当前架构的设计原理。</li>
<li>目录-索引、词汇表、首字母缩略词表。</li>
</ol>
</li>
<li>View部分<ol>
<li>styles and views(体系结构风格和视图)</li>
<li>Structural views<ul>
<li>module views</li>
<li>C &amp; C views</li>
<li>Allocation views</li>
</ul>
</li>
<li>Quality Views</li>
</ol>
</li>
<li><p>每一个View的内容</p>
<ol>
<li>主要介绍：显示视图的元素和关系，以及图例</li>
<li>元素介绍，详细介绍第一部分中描述的元素、元素属性、关系属性和元素接口和行为。</li>
<li>上下文图：描述系统如何与环境相关</li>
<li>可变性指南：告知视图中可能出现的变化</li>
<li>基本原理：解释设计如何映射在视图中，以及其合理性。</li>
</ol>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【高频 2015 2017】将以下每个问题（左侧）与解决该问题的架构风格/视图（右侧）对应起来。列出每个样式类别的四个视图。Map each of the following questions (on the left) with thearchitectural style/view (on the right) that addresses the question. List four views of each category of style.</p>
<ul>
<li><p>Module Styles：分解视图、使用视图、泛化视图、分层视图、领域视图、数据模型视图</p>
</li>
<li><p>Component-Connector Styles：管道-过滤器视图、客户端-服务器视图、点对点视图、面向服务视图、发布-订阅视图</p>
</li>
<li><p>Allocation Styles：部署视图、安装视图、工作分配视图、其他分配视图。</p>
</li>
</ul>
</blockquote>
<h3 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h3><h4 id="Styles-viewpoints-patterns-and-views"><a href="#Styles-viewpoints-patterns-and-views" class="headerlink" title="Styles (viewpoints), patterns and views"></a>Styles (viewpoints), patterns and views</h4><h5 id="Three-Categories-of-Styles"><a href="#Three-Categories-of-Styles" class="headerlink" title="Three Categories of Styles"></a>Three Categories of Styles</h5><div class="table-container">
<table>
<thead>
<tr>
<th>Views</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module Views</td>
<td>它是如何构建为一组实现单元的？How it is structured as a set of implementation units?</td>
<td>分解视图、使用视图、泛化视图、分层视图、领域视图、数据模型视图</td>
</tr>
<tr>
<td>Component-connector(C&amp;C) styles</td>
<td>它是如何构建为一组具有运行时行为和交互的元素的？How it is structured as a set of elements that have runtime behavior and interactions?</td>
<td>管道-过滤器视图、客户端-服务器视图、点对点视图、面向服务视图、发布-订阅视图</td>
</tr>
<tr>
<td>Allocation style</td>
<td>它与环境中的非软件结构有何关系？How it relates to non-software structures in its environment?</td>
<td>部署视图、安装视图、工作分配视图、其他分配视图</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Styles-vs-Patterns"><a href="#Styles-vs-Patterns" class="headerlink" title="Styles vs. Patterns"></a>Styles vs. Patterns</h5><ol>
<li>架构风格是元素和关系类型的特殊化，以及关于如何使用它们的一组约束 An architecture style is a”specialization of element and relation types, together with a set of constraints on how they can be used” (Bass, Clements, and Kazman 2003)</li>
<li>架构模式表达了软件系统的基本结构组织模式 An architecture pattern”expresses a fundamental structural organization schema for software systems”(Buschmann et al. 1996)</li>
<li>架构模式的一个重要部分是关注问题和上下文，以及如何在该上下文中解决问题。An essential part of an architecture pattern is its focus on the problem and context as well as how to solve the problem in that context.</li>
<li>架构风格侧重于架构方法，对特定风格何时有用或无用提供更轻量级的指导。An architecture style focuses on the architecture approach, with more lightweight guidance on when a particular style may or may not be useful.</li>
<li>架构模式：{问题，上下文} —&gt; 架构方法 Architecture pattern: {problem, context} —&gt; architecture approach</li>
<li>架构风格：架构方式 Architecture style: architecture approach</li>
<li>风格描述通常不包括详细的问题/上下文信息；架构模式可以。A style description does not generally include detailed problem/context information; architecture patterns do.</li>
<li>微服务知识定义了 element，和 element 通过什么方式进行交互。</li>
</ol>
<h5 id="Architectural-Views"><a href="#Architectural-Views" class="headerlink" title="Architectural Views"></a>Architectural Views</h5><ol>
<li>视图是一组系统元素和它们之间关系的表示——不是所有的系统元素，而是特定类型的那些元素 A view is a representation of a set of system elements and relations among them - not all system elements, but those of a particular type.</li>
<li>视图让我们将系统的实体划分为有趣且易于管理的系统表示 Views let us divide the system’s entity into interesting and manageable representations of the system.</li>
<li>不同的视图支持不同的目标和用户，突出不同的系统元素和关系 Different views support different goals and users, and highlight different system elements and relations</li>
<li>不同的视图在不同程度上暴露了不同的质量属性。 Different views expose different quality attributes to different degrees.</li>
</ol>
<h4 id="Structural-view"><a href="#Structural-view" class="headerlink" title="Structural view"></a>Structural view</h4><ol>
<li><p>Module Views</p>
<p>模块是提供一组连贯职责的实现单元 A module is an implementation unit that provides a coherent set of responsibility.</p>
<p>==没有至少一个模块视图，任何软件架构的文档都不可能是完整的== It is unlikely that the documentation of any software architecture can be complete without at least one module view.</p>
<ul>
<li>视图示例</li>
</ul>
<ol>
<li><p>分解视图 Decomposition view</p>
</li>
<li><p>使用视图 Uses view</p>
</li>
<li><p>泛化视图 Generalization view</p>
</li>
<li><p>分层视图 Layered view</p>
</li>
<li><p>领域视图 Aspects View</p>
</li>
<li><p>数据模型视图 Data model view</p>
</li>
</ol>
</li>
<li><p>Component-Connector Views</p>
<p>组件和连接器视图显示具有==某些运行时存在的元素==，例如进程、对象、客户端、服务器和数据存储（称为“组件”）。 Component-and-connector views show elements that have some runtime presence, e.g, processes, objects, clients, servers, and data stores (being termed ‘components).</p>
<p>附件指示哪些连接器连接到哪些组件 Attachments indicate which connectors are attached to which components.</p>
<p>通过将连接器的端点连接到组件的端口来显示附件。 Attachment is shown by connecting the endpoints of the connector to the ports of components.</p>
<ul>
<li>视图示例</li>
</ul>
<ol>
<li>管道和过滤器视图 Pipe-and-filter view</li>
<li>客户端-服务器视图 Client-server view</li>
<li>点对点视图 Peer-to-peer view</li>
<li>面向服务的架构 (SOA) 视图 Service-oriented architecture (SOA) view</li>
<li>发布订阅视图 Publish-subscribe view</li>
<li>共享数据视图 Shared-data view</li>
<li>多层视图 Multi-tier view</li>
</ol>
</li>
<li><p>Allocation Views</p>
<ol>
<li>分配视图描述了软件单元到软件开发或执行环境元素的映射 Allocation views describe the mapping of software units to elements of an environment in which the software is developed or in which it executes.</li>
<li>分配视图的通常目标是将软件元素所需的属性与环境元素提供的属性进行比较，以确定分配是否成功 The usual goal of an allocation view is to compare the properties required by the software element with the properties provided by the environmental elements to determine whether the allocation will be successful or not.</li>
<li>分配视图可以描绘静态或动态视图 Allocation views can depict static or dynamic views</li>
</ol>
<ul>
<li>视图实例</li>
</ul>
<ol>
<li>部署视图 Deployment view</li>
<li>安装视图 Install view</li>
<li>工作分配视图 Work assignment view</li>
<li>其他分配视图 Other allocation views</li>
</ol>
</li>
</ol>
<h4 id="Quality-views"><a href="#Quality-views" class="headerlink" title="Quality views"></a>Quality views</h4><ol>
<li>安全视图 Security view</li>
<li>性能视图 Performance view</li>
<li>可靠性视图 Reliability view</li>
<li>通信视图 Communication View</li>
<li>异常（错误处理）视图 Exception(error-handling) view</li>
</ol>
<h3 id="Documenting-views"><a href="#Documenting-views" class="headerlink" title="Documenting views"></a>Documenting views</h3><ol>
<li>步骤 1：构建涉众/视图表 Step-1: Build a stakeholder/view table</li>
<li>步骤 2：合并视图 Step-2: Combine views<ol>
<li>2.1 识别上表中的边缘视图 2.1 Identify marginal views in the above table</li>
<li>2.2 通过关联一个视图中的元素和另一个视图中的元素，将每个边缘视图与另一个具有更强选区的视图相结合 2.2 Combine each marginal views with another view with stronger constituency by associating between elements in one view and elements in the other</li>
</ol>
</li>
<li>步骤 3：确定优先级和阶段 Step-3: Prioritize and stage<ol>
<li>分解视图 decomposition view</li>
<li>80/20 原则 80/20 principle</li>
<li>按顺序完成所有视图？complete all views in sequence?</li>
</ol>
</li>
</ol>
<h3 id="Beyond-Information-Beyond-Views"><a href="#Beyond-Information-Beyond-Views" class="headerlink" title="Beyond (Information Beyond Views)"></a>Beyond (Information Beyond Views)</h3><ol>
<li><p>Documentation info</p>
<p>第 1 部分：文档路线图说明文档中的信息以及在哪里可以找到它 Section-1: Documentation Roadmap tells what in formation is in the documentation and where to find it</p>
<ol>
<li>范围和总结 Scope and summary</li>
<li>文档的组织方式 How the documentation is organized<ol>
<li>简短的概要 short synopsis</li>
<li>带注释的目录 annotated table of contents</li>
</ol>
</li>
<li>查看概览 View overview</li>
<li>利益相关者如何使用文档 How stakeholders can use the documentation</li>
</ol>
</li>
<li><p>Architecture info (mapping between views)</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-05-Document/13.png'></p>
<h4 id="Documentation-package-views-beyond"><a href="#Documentation-package-views-beyond" class="headerlink" title="Documentation package: views + beyond"></a>Documentation package: views + beyond</h4><h2 id="架构评估"><a href="#架构评估" class="headerlink" title="架构评估"></a>架构评估</h2><blockquote>
<p>架构分析 &amp; 评估方法</p>
<p>ATAM：Architecture Tradeoff Analysis Method</p>
<ul>
<li><p>Stakeholders involved in ATAM</p>
</li>
<li><p>Inputs to and Outputs of ATAM: Risks (Non-risks, Risk themes), Sensitivity points, Trade-off points</p>
</li>
<li><p>Phase 0: Partnership &amp; preparation; Phase 3: Follow-up </p>
</li>
<li><p>Phase 1: Evaluation - 1</p>
<p>1.present ATAM, 2. present business drivers, 3. present architecture, 4. identify architectural approaches, 5. generate utility tree, 6. analyse architectural approaches</p>
</li>
<li><p>Phase 2: Evaluation - 2</p>
<p>1.present ATAM &amp; results, 7. brainstorm &amp; prioritize, 8. analyse architectural approaches, 9. present results</p>
</li>
</ul>
</blockquote>
<h3 id="架构分析-amp-评估方法"><a href="#架构分析-amp-评估方法" class="headerlink" title="架构分析 &amp; 评估方法"></a>架构分析 &amp; 评估方法</h3><ol>
<li>一种有助于提出正确问题来评估架构的系统方法 A systematic approach to evaluate architecture needs a method that helps ask right questions<ol>
<li>来发现风险 to discover risks</li>
<li>来识别错误的架构决定 to identify wrong architectural choices</li>
<li>确保质量问题得到解决 to ensure quality issues have been addressed</li>
</ol>
</li>
<li>这里有很多用来评估软件架构的方法 There are a number of methods to evaluate software architecture:<ol>
<li>Software Architecture Analysis Method (SAAM)</li>
<li>Architecture Level Modifiability Analysis (ALMA)</li>
<li>Performance Assessment of Software Architecture (PASA)</li>
<li>Architecture Trade-off Analysis Method (ATAM)</li>
</ol>
</li>
<li>所有这些方法都是基于场景的方法，因为质量属性是使用场景定义的 All these methods are scenario-based approaches as quality attributes are defined using scenarios</li>
<li>场景被映射到架构组件上，以评估架构能力，以满足所需的质量属性 Scenarios are mapped on architectural components to evaluate architectural capability to fulfill desired quality attributes</li>
</ol>
<blockquote>
<p>  [!IMPORTANT]</p>
<p>【2018】【2019】Risks，Senstivity Points，Trade-Off Points分别是什么？各举一个例子。</p>
<ol>
<li><p>识别风险：发现可能对所需质量属性产生负面影响的架构决策，例如使用分层模式可能带来性能损耗。</p>
</li>
<li><p>发现权衡：影响多个质量属性的架构决策，例如使用分层模式可能会带来性能损耗，但是也会解耦增加系统的可修改性。</p>
</li>
<li><p>发现敏感点：特定质量属性对其敏感的架构决策，比如在对性能敏感的系统中，决定使用缓存中间件。</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2015】【2017】描述架构权衡分析方法 (ATAM) 过程的每个阶段生成的输出。Describe the outputs generated from each phase of Architecture Tradeoff Analysis Method(ATAM) process.</p>
<ol>
<li>阶段-0：准备和建立团队(输入是架构设计文档)<ol>
<li>评估计划</li>
</ol>
</li>
<li>阶段-1：评估-1<ol>
<li>架构的简明介绍</li>
<li>业务目标（驱动因素）的阐释</li>
<li>作为场景实现的特定质量属性要求的优先级列表</li>
<li>Utility Tree 效用树</li>
<li>风险和无风险点</li>
<li>敏感和权衡点</li>
</ol>
</li>
<li>阶段-2：评估-2<ol>
<li>涉众们的优先级场景列表</li>
<li>风险主题和业务驱动因素各自受到的威胁</li>
</ol>
</li>
<li>阶段-3：后续<ol>
<li>最终的评估报告</li>
</ol>
</li>
<li><p>ATAM的整体输出</p>
<ol>
<li>架构的简明介绍</li>
<li>业务目标（驱动因素）的阐释</li>
<li>表现为质量属性场景的优先质量属性要求</li>
<li>质量属性效用树(Utility Tree)</li>
<li>风险和非风险组</li>
<li>风险主题组(共同的潜在问题或系统性缺陷将风险分组为风险主题)</li>
<li>将架构映射到质量属性</li>
<li>敏感点和权衡点</li>
<li>最终的评估报告</li>
</ol>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2019】描述在ATAM的每一个过程中 有哪些Stack holder和他们的职责</p>
<ol>
<li><p>阶段-0：准备和建立团队</p>
<ol>
<li>参与者：评估团队领导和关键项目决策者</li>
<li>职责：根据架构设计文档生成评估计划，==包括谁参加评估、如何何时何地开展评估、最后评估报告会被呈递给谁。==</li>
</ol>
</li>
<li><p>阶段-1：评估-1</p>
<ol>
<li><p>参与者：==评估团队和项目决策者==</p>
</li>
<li><p>职责：</p>
<ol>
<li><p>第一步，评估负责人介绍ATAM方法</p>
</li>
<li><p>第二步，项目经理或客户从业务角度介绍业务驱动因素</p>
</li>
<li>第三步，首席架构师介绍体系结构</li>
<li>第四步，评估团队确定架构方法</li>
<li>第五步，评估团队和项目决策者生成质量属性效用树(Utiltiy Tree)</li>
<li>第六步，评估团队分析架构方法</li>
</ol>
</li>
</ol>
</li>
<li><p>阶段-2：评估-2</p>
<ol>
<li>参与者：==评估团队、项目决策者和项目涉众==</li>
<li>职责：<ol>
<li>第一步，评估负责人介绍ATAM方法和之前已经取得的成果</li>
<li>第七步，涉众头脑风暴并确定场景优先级</li>
<li>第八步，评估团队分析架构方法，类似第六步</li>
<li>第九步，评估团队展示评估结果，并呈递给涉众</li>
</ol>
</li>
</ol>
</li>
<li><p>阶段-3：后续</p>
<ol>
<li>参与者：评估团队、主要涉众</li>
<li>职责：评估团队制作最终评估报告，发给主要涉众审核通过后，将报告呈递给委托评估的人。</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="ATAM：Architecture-Tradeoff-Analysis-Method"><a href="#ATAM：Architecture-Tradeoff-Analysis-Method" class="headerlink" title="ATAM：Architecture Tradeoff Analysis Method"></a>ATAM：Architecture Tradeoff Analysis Method</h3><p>ATAM 方法分为 4 个阶段完成</p>
<h4 id="Inputs-to-and-Outputs-of-ATAM"><a href="#Inputs-to-and-Outputs-of-ATAM" class="headerlink" title="Inputs to and Outputs of ATAM"></a>Inputs to and Outputs of ATAM</h4><p><strong>Summary of ATAM Outputs</strong></p>
<ol>
<li>架构的简明展示 A concise presentation of the architecture</li>
<li>业务目标的阐述 Articulation of the business goals</li>
<li>表示为质量属性场景的优先质量属性要求 Prioritized quality attribute requirements expressed as quality attribute scenarios</li>
<li>引用树 A utility tree</li>
<li>一组风险和非风险 A set of risks and nonrisks</li>
<li>一组风险主题 A set of riskthemes</li>
<li>将架构决策映射到质量要求 Mapping of architectural decisions to quality requirements</li>
<li>一组确定的敏感度和权衡点 A set of identified sensitivity and tradeoff points</li>
<li>最终的评估报告 Final evaluation report</li>
</ol>
<h4 id="Phase-0-Partnership-amp-Preparation"><a href="#Phase-0-Partnership-amp-Preparation" class="headerlink" title="Phase 0 - Partnership &amp; Preparation"></a>Phase 0 - Partnership &amp; Preparation</h4><ol>
<li>参与者：评估团队领导和关键项目决策者 Participants: evaluation team leadership and key project decision makers</li>
<li>输入：架构设计文档 Inputs: the architecture documentation</li>
<li>输出：评估计划 Outputs: the evaluation plan<ol>
<li><strong>谁？</strong>涉众的初步名单 Who? a preliminary list of stakeholders</li>
<li>逻辑：<strong>什么时候？什么地点和如何？</strong> Logistics: When? Where? and How?</li>
<li>什么时候评估报告被送给<strong>谁</strong>？When the evaluation report is to be delivered to whom?</li>
<li>评估报告中应该包含<strong>什么</strong>信息？What information to be included in the evaluation report?</li>
</ol>
</li>
</ol>
<h4 id="Phase-1-Evaluation-1"><a href="#Phase-1-Evaluation-1" class="headerlink" title="Phase 1 -  Evaluation (1)"></a>Phase 1 -  Evaluation (1)</h4><ol>
<li>参与者：==评估团队和项目决策者== Participants: evaluation team and project decision makers</li>
<li>步骤 1-6 Step 1-6</li>
<li>输出 Outputs:<ol>
<li>架构的简明介绍 a concise presentation of the architecture</li>
<li>业务目标（驱动因素）的阐述 articulation of the business goals (drivers)</li>
<li>作为场景实现的特定质量属性要求的优先列表 a prioritized list of specific quality attribute requlrements realized as scenarios</li>
<li>效用树 utility tree</li>
<li>风险和无风险 risks and nonrisks</li>
<li>敏感点和权衡点 sensitivity points and tradeoff points</li>
</ol>
</li>
</ol>
<h5 id="Step1-Present-the-ATAM"><a href="#Step1-Present-the-ATAM" class="headerlink" title="Step1 - Present the ATAM"></a>Step1 - Present the ATAM</h5><p>评估负责人向集合的项目代表（“决策者”）简要介绍 ATAM，让他们了解评估的过程和输出 The evaluation leader presents the ATAM in brief to assembled project representatives (‘decision makers’) for their understanding of the process and outputs of the evaluation</p>
<h5 id="Step2-Present-the-Business-Drivers"><a href="#Step2-Present-the-Business-Drivers" class="headerlink" title="Step2 - Present the Business Drivers"></a>Step2 - Present the Business Drivers</h5><p>项目经理或系统的客户从业务角度呈现系统概览，描述 Project manager or system’s customer presents a system overview from a business perspective, describing 1. 它最重要的功能需求 its most important functional requirements 2. 其技术、管理、经济或政治限制 its technical, managerial, economic, or political constraints 3. 其商业目标和上下文 its business goals and context 4. 其主要涉众 its major stakeholders 5. 架构驱动因素（塑造架构的主要质量属性目标）the architectural drivers (major quality attribute goals that shape the architecture)</p>
<h5 id="Step3-Present-the-architecture"><a href="#Step3-Present-the-architecture" class="headerlink" title="Step3 - Present the architecture"></a>Step3 - Present the architecture</h5><ol>
<li>首席架构师在适当的细节级别上进行了描述架构的演示： The lead architect makes a presentation describing the architecture at an appropriate level of detail:<ol>
<li>技术限制，例如规定使用的操作系统、硬件或中间件 technical constraints such as an OS, hardware, or middleware prescribed for use</li>
<li>系统必须与之交互的其他系统 other systems with which the system must interact</li>
<li>用于满足质量属性要求的架构方法 architectural approaches used to meet quality attribute requirements</li>
</ol>
</li>
<li>架构演示（大约 20 张幻灯片；60 分钟）Architecture Presentation (Approximately 20 slides; 60 Minutes)<ol>
<li>推动架构要求、与这些要求相关联的可测量数量，以及满足这些要求的任何现有标准/模型/方法（2-3 张幻灯片） Driving architectural requirements, the measurable quantities you associate with these requirements, and any existing standards/ models/ approaches for meeting these (2-3 slides)<ol>
<li>重要的架构信息（4-8 张幻灯片）：Important architectural information (4-8 slides):<ol>
<li>语境图 - 系统在其存在的语境中。系统将与之交互的人类或其他系统。 Context diagram-the system within the context in which it will exist. Humans or other systems with which the system will interact.</li>
<li>模块或层视图 - 描述系统功能分解的模块（可以是子系统或层），以及填充这些的对象、过程、函数以及它们之间的关系（例如，过程调用、方法调用、 回调，遏制）。Module or layer view- the modules (which may be subsystems or layers) that describe the system s decomposition of functionality, along with the objects, procedures, functions that populate these, and the relations among them (e.g, procedure call, method invocation, callback, containment).</li>
<li>组件和连接器视图进程、线程以及连接它们的同步、数据流和事件。Component-and-connector view-processes, threads along with the synchronization, data flow, and events that connect them.</li>
<li>部署视图 - CPU、存储、外部设备/传感器以及连接它们的网络和通信设备。 还显示了在各种处理器上执行的进程。Deployment view- CPUs, storage, external devices/ sensors along with the networks and communication devices that connect them. Also shown are the processes that execute on the various processors.</li>
</ol>
</li>
<li>采用的架构方法、模式或策略，包括它们解决的质量属性以及这些方法如何解决这些属性的描述（3-6 张幻灯片）：Architectural approaches, patterns, or tactics employed, including what quality attributes they address and a description of how the approaches address those attributes (3-6 slides):<ol>
<li>商业现货（COTS）产品的使用以及它们的选择/集成方式（1-2 张幻灯片）。Use of commercial off-the-shelf (COTS) products and how they are chosen/integrated (1-2 slides).</li>
<li>跟踪 1 到 3 个最重要的用例场景。 如果可能，包括每个场景消耗的运行时资源（1-3 张幻灯片）。Trace of 1 to 3 of the most important use case scenarios. If possible, include the runtime resources consumed for each scenario (1-3 slides).</li>
<li>跟踪 1 到 3 个最重要的变化场景。 如果可能，根据更改的模块或界面（1-3 张幻灯片）描述更改影响（更改的估计大小/难度） Trace of1 to 3 of the most important change scenarios. If possible, describe the change impact (estimated size/ difficulty of the change) in terms of the changed modules or interfaces (1-3 slides).</li>
<li>与满足驱动架构要求相关的架构问题/风险（2-3 张幻灯片）。Architectural issues/risks with respect to meeting the driving architectural requirements (2-3 slides).</li>
<li>词汇表（1 张 PPT）Glossary (1 slide).</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="Step4-Identify-Architectural-Approaches"><a href="#Step4-Identify-Architectural-Approaches" class="headerlink" title="Step4 - Identify Architectural Approaches"></a>Step4 - Identify Architectural Approaches</h5><ol>
<li>ATAM 专注于通过理解架构方法来分析架构。ATAM focuses on analyzing an architecture by understanding its architectural approaches.</li>
<li>在这一步，评估团队：By this step, the evaluation team<ol>
<li>研究了架构文档 have studied the architecture documentation</li>
<li>听取了架构师的展示 have heard the architect’s presentation</li>
<li>向架构师询问了设计系统时使用的模式和策略 have asked the architect about patterns and tactics used in designing the system</li>
</ol>
</li>
<li>评估团队对已确定的架构方法（风格、模式和策略）进行编目。The evaluation team catalogs the architectural approaches (styles, patterns and tactics) that have been identified.</li>
</ol>
<h5 id="Step5-Generate-Quality-Attribute-Utility-Tree"><a href="#Step5-Generate-Quality-Attribute-Utility-Tree" class="headerlink" title="Step5 - Generate Quality Attribute Utility Tree"></a>Step5 - Generate Quality Attribute Utility Tree</h5><ol>
<li>这是指导其余分析的关键步骤。 This is a crucial step that guides the remainder of the analysis.</li>
<li>评估团队与项目决策者合作，确定、确定和优化系统最重要的质量属性目标。The evaluation team works with the project decision makers to identify, prioritize and refine the system’s most important quality attribute goals.</li>
<li>质量属性目标通过质量属性效用树详细阐述，该树通过精确定义相关质量属性需求使需求具体化。The quality attribute goals are articulated in detail via quality attribute utility tree that makes the requirements concrete by defining precisely the relevant quality attribute requirements.</li>
</ol>
<h5 id="Step6-Analyze-Architectural-Approaches"><a href="#Step6-Analyze-Architectural-Approaches" class="headerlink" title="Step6 - Analyze Architectural Approaches"></a>Step6 - Analyze Architectural Approaches</h5><ol>
<li>目标是让评估团队确信该方法的实例化适合满足特定于属性的要求。The goal is for the evaluation team to be convinced that the instantiation of the approach is appropriate for meeting the attribute-specific requirements.</li>
<li>评估团队通过要求架构师解释架构如何相互支持，一次检查排名最高的场景（来自实用程序树）。The evaluation team examines that the highest-ranked scenarios(from the utility tree) one at a time by asking the architect to explain how the architecture supports each other.</li>
<li>评估团队记录相关的架构决策，并通过讨论识别和分类其风险、非风险、敏感点和权衡。The evaluation team documents the relevant architectural decisions and identifies and catalogs their risks, nonrisks, sensitivity points, and tradeoffs through a discussion.</li>
<li>分析是为了引出足够的架构信息，以在已经做出的架构决策和需要满足的质量属性之间建立某种联系。The analysis is to elicit sufficient architectural information to establish some link between the architectural decisions that have been made and quality attributes that need to be satisfied.</li>
<li>在这一步结束时，评估团队应该清楚地了解整个架构的最重要方面、关键设计决策的基本原理以及风险、非风险、敏感点和权衡点的列表。At the end of this step, the evaluation team should have a clear picture of the most important aspects of the entire architecture, the rationale for key design decisions, and a list of risks, nonrisks, sensitivity points, and tradeoff points.</li>
</ol>
<h4 id="Phase-2-Evaluation-2"><a href="#Phase-2-Evaluation-2" class="headerlink" title="Phase 2 - Evaluation (2)"></a>Phase 2 - Evaluation (2)</h4><ol>
<li>参与者：评估团队，项目决策者和架构涉众 Participants: evaluation team, project decision makers, and architecture stakeholders</li>
<li>步骤(1) 7-9 Step (1) 7~9</li>
<li>输出：Outputs:<ol>
<li>涉众社区的优先场景列表 a list of prioritized scenarios from the stakeholder community</li>
<li>风险主题和业务驱动因素受到每一个威胁 risk themes and business drivers threatened by each one</li>
</ol>
</li>
</ol>
<h5 id="Step-1-Present-the-ATAM-amp-Previous-Results"><a href="#Step-1-Present-the-ATAM-amp-Previous-Results" class="headerlink" title="Step-1: Present the ATAM &amp; Previous Results"></a>Step-1: Present the ATAM &amp; Previous Results</h5><ol>
<li>重复步骤 1，以便利益相关者了解方法和他们将扮演的角色。 Step 1 is repeated so that the stakeholders understand the method and the roles they are to play.</li>
<li>评估负责人总结第 2 步到第 6 步的结果，并分享输出（效用树除外）。The evaluation leader recaps the results of steps 2 through 6, and shares the outputs (except the utility tree).</li>
</ol>
<h5 id="Step-7-Brainstorm-amp-Prioritize-Scenarios"><a href="#Step-7-Brainstorm-amp-Prioritize-Scenarios" class="headerlink" title="Step-7: Brainstorm &amp; Prioritize Scenarios"></a>Step-7: Brainstorm &amp; Prioritize Scenarios</h5><ol>
<li>此步骤的目的是把握更大的利益相关者社区的脉搏，以了解系统成功对他们意味着什么。The purpose of this step is to take the pulse of the larger stakeholder community to understand what system success means to them.</li>
<li>评估团队要求利益相关者集思广益，就其个人角色而言，在操作上有意义的场景。The evaluation team asks the stakeholders to brainstorm scenarios that are operationally meaningful with respect to their individual roles.</li>
<li>一旦收集了场景，就会要求利益相关者对他们认为代表行为或质量问题的场景进行优先级排序和合并。Once the scenarios have been collected, stakeholders are asked to prioritize and merge scenarios they feel represent the behavior or quality concern.</li>
<li>将优先场景列表与实用程序树中的场景进行比较。The list of prioritized scenarios is compared with those from the utility tree.</li>
<li>如果差异很大，则额外的情景可能被识别为风险。If the discrepancy is significant, the additional scenario may be identified as a risk.</li>
</ol>
<h5 id="Step-8-Analyze-Architectual-Approaches"><a href="#Step-8-Analyze-Architectual-Approaches" class="headerlink" title="Step-8: Analyze Architectual Approaches"></a>Step-8: Analyze Architectual Approaches</h5><ol>
<li>在此步骤中，评估团队执行与步骤 6 中相同的活动，使用排名最高的（例如前 5 到 10）但新生成的场景。In this step, the evaluation team performs the same activities as in Step 6, using the highest ranked (e.g. top 5 to 10), but newly generated scenarios.</li>
<li>架构师解释了相关的架构决策如何有助于实现每个决策。 The architect explains how relevant architectural decisions contribute to realizing each one.</li>
</ol>
<h5 id="Step-9-Present-Results"><a href="#Step-9-Present-Results" class="headerlink" title="Step-9: Present Results"></a>Step-9: Present Results</h5><ol>
<li>评估团队根据共同的潜在问题或系统性缺陷将风险分组为风险主题。The evaluation team groups the risks into risk themes, based on common underlying concern or systemic deficiency.</li>
<li>然后，确定的风险主题与步骤 2 中列出的特定业务驱动因素相关。The identified risk themes are then related to specific business drivers listed in Step 2.</li>
<li>从评估中收集的信息被总结并呈现给所有利益相关者：The collected information from evaluation is summarized and presented to all stakeholders:<ol>
<li>记录的架构方法 The architectural approaches documented</li>
<li>集思广益的场景集及其优先级 The set of scenarios and their prioritization from brainstorming</li>
<li>实用树 The utility tree</li>
<li>发现的风险和记录的非风险 The risks discovered and nonrisks documented</li>
<li>发现的敏感因素和权衡因素 The sensitivity points and tradeoff points found</li>
<li>风险主题和受威胁的业务驱动因素 Risk themes and the business drivers threatened by each one</li>
</ol>
</li>
</ol>
<h4 id="Phase-3-Follow-up"><a href="#Phase-3-Follow-up" class="headerlink" title="Phase 3 - Follow-up"></a>Phase 3 - Follow-up</h4><ol>
<li>参与者：评估团队和主要涉众（评估客户） Participants: evaluation team and key stakeholders (evaluation clients)</li>
<li>输出：最终评估报告 Outputs: the final evaluation report</li>
<li>评估团队制作一份书面最终报告，分发给主要涉众以供审核。The evaluation team produces a written final report that is circulated to key stakeholders for revlew.</li>
<li>审查结束后，将报告提交给委托评估的人。After the review, the report is delivered to whom commissioned the evaluation.</li>
</ol>
<h1 id="微服务部分"><a href="#微服务部分" class="headerlink" title="微服务部分"></a>微服务部分</h1><blockquote>
<p>  [!IMPORTANT]</p>
<p>微服务部署模式</p>
<p>上下文</p>
<ul>
<li>微服务架构包含一组服务 </li>
<li>每个服务都部署为一组服务实例，以实现吞吐量和可用性</li>
</ul>
<p>问题</p>
<ul>
<li>如何大规模部署微服务？</li>
</ul>
<p>需求</p>
<ul>
<li>服务使用各种语言、框架和框架版本编写 </li>
<li>需要快速构建、独立部署和扩展服务 </li>
<li>服务实例需要相互隔离 </li>
<li>需要监控每个服务实例的行为、部署可靠 </li>
<li>需要限制服务消耗的资源（CPU 和内存） </li>
<li><p>尽可能经济高效地部署应用程序</p>
<p>[!IMPORTANT]</p>
</li>
</ul>
<p>微服务部署模式</p>
<ul>
<li><p>单主机部署多个服务实例</p>
</li>
<li><p>单主机部署单个服务实例 </p>
</li>
<li>将服务部署到虚拟机 </li>
<li>将服务部署到容器 </li>
<li>服务部署平台 </li>
<li>无服务器部署</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/4a65c0f466d94d0a870d/?dl=1'></p>
<p>微服务可观测性模式</p>
<p>上下文</p>
<ul>
<li>多台机器上、多个服务和服务实例 </li>
<li>请求跨越多服务实例，每个服务通过执行一 个或多个操作来处理请求 </li>
<li>以标准化格式将操作信息写入日志文件，跟 踪用户行为和代码异常 </li>
<li>服务实例可能无法处理请求但仍在运行</li>
</ul>
<p>问题： </p>
<ul>
<li>如何理解用户和应用程序的行为并解决问题？ </li>
<li>如何检测正在运行的服务实例无法处理请求？</li>
</ul>
<p>模式列表： </p>
<ul>
<li>日志聚合 </li>
<li>审计日志 </li>
<li>应用程序指标 </li>
<li>分布式跟踪 </li>
<li>异常跟踪 </li>
<li><p>健康检查API</p>
<p>[!IMPORTANT]</p>
</li>
</ul>
<p>微服务的6个特性</p>
<p>1、拆分服务—组件化（通过进程间通信的⽅式变成独⽴单元）；</p>
<p>2、微服务中，团队围绕业务组织；</p>
<p>3、服务与服务之间遵循⾯向对象的⾼内聚低耦合；</p>
<p>4、拆分后的分布式系统，服务数量变多，可能带来⼀致性等问题，具有去中⼼化的特性；</p>
<p>5、⾃动化的管理，依赖基础设施服务（主要是运维层⾯）；</p>
<p>6、设计过程中针对质量属性的策略，核⼼是故障，保障服务等设计；</p>
<p>  [!IMPORTANT]</p>
<p>如何将应用拆分为微服务？</p>
<p>需求： </p>
<ul>
<li>高内聚：实现一组密切相关的功能 </li>
<li>松耦合：封装内部细节，API交互 </li>
<li>单一职责原则（SRP） </li>
<li>共同封闭原则（CCP） </li>
<li>双披萨团队开发 </li>
<li>团队自治</li>
</ul>
<p>拆分模式列表：</p>
<ul>
<li>根据业务能力进行服务拆分 </li>
<li>根据子域进行服务拆分 <ul>
<li>领域驱动设计方法论的核心</li>
</ul>
</li>
<li><p>根据动静态调用关系拆分</p>
<p>[!IMPORTANT]</p>
</li>
</ul>
<p>微服务架构通信模式</p>
<p>问题： </p>
<ul>
<li>如何避免由于服务故障或网络中断所引起的故障蔓延到其他服务？ </li>
<li>客户端如何在网络上发现服务实例的位置？ </li>
<li>如何处理外部客户端与服务之间的通讯？</li>
</ul>
<p>模式列表： </p>
<ul>
<li>断路器（Circuit Breaker）模式 </li>
<li>应用层服务发现模式 </li>
<li>平台层服务发现模式 </li>
<li><p>API Gateway模式</p>
<p>[!IMPORTANT]</p>
</li>
</ul>
<p>领域驱动设计⾥⾯的战略设计和战术设计的区别、各据俩个例⼦</p>
<p><strong>战略设计：</strong>通过 DDD 的理论，对业务进行领域划分构建领域模型，梳理出相应的限界上下文，通过统一的领域语言从战略层面进行领域划分以及构建领域模型。在构建领域模型的过程中需要梳理出对应的聚合、实体、以及值对象。</p>
<p><strong>战术设计：</strong>以领域模型为战术设计的输入，以限界上下文作为微服务划分的边界进行微服务拆分，在每个微服务中进行领域分层，实现领域模型对于代码的映射，从而实现 DDD 的真正落地实施。</p>
<p> [!IMPORTANT]</p>
<p>企业架构设计的⼀般设计过程</p>
<ol>
<li>业务架构设计<ul>
<li>战略设计：确定战略⽬标和主要措施，分解识别业务⽬标，拆分能⼒需求，形成战略能⼒聚类，形成组织设计（谁来⼲）</li>
<li>业务设计与分析：通过流程模型、产品模型、数据模型组成并扩展为业务模型，定义了以提⾼⽣成效率和避免操作性错误为核⼼的⽤户体验模型，并对业务组件进⾏业务需求分析形成业务架构</li>
</ul>
</li>
<li>应⽤架构设计：设计应⽤构件和应⽤，进⾏应⽤分析，服务拆分等⽅法，识别并定义⽤例</li>
<li>技术架构设计：包括物理构建设计和技术平台设计</li>
<li>安全架构设计：满⾜安全要求的设计。选择安全⼯具</li>
</ol>
</blockquote>
<h2 id="微服务定义"><a href="#微服务定义" class="headerlink" title="微服务定义"></a>微服务定义</h2><p>微服务架构是把应用程序功能性分解为一组服务的架构风格，每一个服务都是由一组专注、内聚的功能职责组成。</p>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><p>上面有👆</p>
<h2 id="SOA-🆚-MSA"><a href="#SOA-🆚-MSA" class="headerlink" title="SOA 🆚 MSA"></a>SOA 🆚 MSA</h2><p><del>怎么感觉DevOps见过这图</del></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/a957d5d11a854587956d/?dl=1'></p>
<h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><ol>
<li>定义系统操作 <ul>
<li>将需求提炼为系统必须处理的关键请求（系统操作） <ul>
<li>定义架构的第一步 </li>
<li>描述服务之间协作方式的架构场景 </li>
<li>如更新/检索数据等 </li>
</ul>
</li>
<li>由抽象的领域模型定义 <ul>
<li>领域模型从需求派生</li>
</ul>
</li>
<li>输入：需求，用户故事/相关用户场景/源代码恢复等</li>
<li>步骤一：创建领域模型</li>
<li>步骤二：确定系统操作</li>
</ul>
</li>
<li>定义微服务（围绕业务概念而非技术）<ul>
<li>根据业务能力进行服务拆分 </li>
<li>根据子域进行服务拆分 </li>
<li>根据动静态调用关系进行服务拆分</li>
</ul>
</li>
<li>定义服务API和协作方式<ul>
<li>将标识的系统操作分配给服务 </li>
<li>独立或与其他服务协作（涉及通信方式）实现操作</li>
</ul>
</li>
</ol>
<h2 id="重构策略"><a href="#重构策略" class="headerlink" title="重构策略"></a>重构策略</h2><p>策略1. 将新功能实现为微服务：</p>
<ul>
<li>API Gateway：新功能的请求路由到新服务，遗留系统请求路由到单体 </li>
<li>集成胶水（Integration Glue）代码： 将服务与单体结合，访问单体所有数据， 并能调用单体实现的功能</li>
</ul>
<p>策略2. 提取业务能力到服务中：</p>
<h1 id="详细设计部分-pmx部分"><a href="#详细设计部分-pmx部分" class="headerlink" title="详细设计部分 - pmx部分"></a>详细设计部分 - pmx部分</h1><blockquote>
<p>简答题+设计题</p>
<p>设计题</p>
<ul>
<li><p>要给出设计方案，类图、代码……</p>
</li>
<li><p>问题描述 -&gt; 前提条件 -&gt; 解法 -&gt; 「效果/优缺点/已知应用，关联解法，其他相关模式」</p>
</li>
</ul>
<p>简答题</p>
<ul>
<li><p>设计原则之间的关系</p>
</li>
<li><p>设计模式体现了什么原则</p>
</li>
<li><p>模式和模式的变体，模式与模式之间的异同点</p>
</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/464e4be2490048679f57/?dl=1'></p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><p>模式名称</p>
</li>
<li><p>问题</p>
</li>
<li>解决方案<ul>
<li>角色&amp;角色的关系</li>
</ul>
</li>
<li>效果<ul>
<li>作为题目中约束条件的一部分</li>
</ul>
</li>
</ul>
<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><ul>
<li><p>按范围、按目的分</p>
</li>
<li><p>关注模式之间的组合</p>
</li>
</ul>
<h2 id="相关简答题"><a href="#相关简答题" class="headerlink" title="相关简答题"></a>相关简答题</h2><blockquote>
<p>  [!IMPORTANT]</p>
<p>【2017】请至少说出三个面向对象的原则，并解释它们如何应用于策略模式？ Please name at least three Object-Oriented principles, and explain how they are applied in Strategy pattern?</p>
<ol>
<li>单一职责原则</li>
<li>开闭原则</li>
<li>里氏代换原则</li>
<li><p>合成复用原则</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2019】设计模式是什么？举例说明类模式和对象模式的区别？</p>
<ol>
<li><p>什么是设计模式：</p>
<ol>
<li>设计模式是对被用来在特定场景下解决一般设计问题的类和互相通信的对象的描述，包括模式名称、问题、解决方案和效果四部分。</li>
<li>(PPT)设计模式<strong>(Design Pattern)</strong>是<strong>一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</li>
</ol>
</li>
<li><p>设计模式分类</p>
<ol>
<li><p>根据其目的(模式是用来做什么的)可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种：</p>
<ol>
<li>创建型模式主要用于创建对象。</li>
<li>结构型模式主要用于处理类或对象的组合。</li>
<li>行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。</li>
</ol>
</li>
<li><p>根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种：</p>
<ol>
<li><p>类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。</p>
</li>
<li><p>对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。</p>
</li>
</ol>
</li>
</ol>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2019】防御式编程是什么？断言和错误处理的区别？</p>
<ol>
<li><p>可以预见到（至少预先推测到）问题所在，断定代码中每个阶段可能出现的错误，并作出相应的防范措施，来防止类似的意外的发生。</p>
</li>
<li><p>断言和错误处理的区别</p>
<ol>
<li><p>断言是在开发期间使用的、让程序在运行时进行自检的代码，是对开发人员的警告，通常是一个子程序或宏。断言不可以有副作用。</p>
</li>
<li><p>错误处理是对预先已经考虑到的错误(如用户错误、程序错误、意外情况等等)按照流程进行处理。</p>
</li>
</ol>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2019】设计模式对MVC的影响？</p>
<ol>
<li><p>MVC模式使用了运行时、动态和相互之间的关系集成到开发框架中，是分层模式的变种。</p>
<ol>
<li><p>分为model（业务逻辑）、view（处理用户展示，接收用户操作）、controller（对用户操作进行处理，将信息通知给model）（强调模块间约束关系，model不可以直接返回到controller）</p>
</li>
<li><p>优点：耦合性低，重用性高，生命周期成本低，部署快，可维护性高，方便管理</p>
</li>
<li>缺点：没有明确定义，不适于中小型应用程序，增加实现复杂度，视图和控制器过于紧密，视图对模型访问低效。</li>
</ol>
</li>
<li><p>四人书中，MVC模式是观察者模式、策略模式和组合模式的演化，可能涉及到工厂模式和装饰器模式</p>
<ol>
<li>基于推送-订阅模式</li>
<li>观察者：model发生变化通知controller，然后更新view</li>
<li>策略模式：controllers帮助views对不同用户的输入做不同的响应。</li>
<li>组合模式：一组views</li>
</ol>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2019】策略模式和状态模式的区别？</p>
<ol>
<li><p>在状态模式中，具体状态类的方法参数中包含上下文对象，需要在状态处理完成后完成状态切换。</p>
</li>
<li><p>在策略模式中，直接对上下文类调用set方法设置策略即可，不涉及到策略的切换。</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2019】最小知识原则在设计模式中的应用？</p>
<ol>
<li>中介者模式</li>
<li><p>外观模式</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2022】Please explain the Liskov Substitution Principle and how it contributes to the Open-Closed Principle.请解释里氏替换原则以及它如何对开闭原则作出贡献。</p>
<ol>
<li>LSP要求子类能够完全替代父类，而不会破坏原有系统的行为</li>
<li><p>LSP对于开闭原则（Open-Closed Principle，OCP）的贡献在于，它确保了代码的可扩展性。OCP要求软件实体应该对扩展开放，对修改关闭。当我们遵循LSP时，可以通过添加新的子类来扩展系统的功能，而无需修改已有的代码。因为子类完全替代父类，所以可以将新的子类对象传递给原有代码，而不会影响原有代码的正确性。这样，我们可以通过增加新的子类来实现系统的扩展，同时保持原有代码的稳定性和一致性</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2022】【2023】观察者设计模式中有两种方法用于向观察者传播数据：推模型（Push Model）和拉模型（Pull Model）。为什么有些情况下一个模型会比另一个模型更可取？每个模型的权衡是什么？</p>
<p>推模型和拉模型的选择取决于应用程序的需求和设计考虑。下面是每个模型的优势和权衡：</p>
<p>推模型：</p>
<ul>
<li>优势：<ol>
<li>简单直接：数据由主题（被观察者）直接推送给观察者，观察者不需要主动请求数据。</li>
<li>即时性：数据推送是实时的，观察者可以立即收到最新的数据更新。</li>
</ol>
</li>
<li>权衡：<ol>
<li><strong>无法控制数据量</strong>：在推模型中，主题通常将所有数据推送给所有观察者，无论观察者是否需要这些数据。这可能会导致数据传输过程中的浪费。</li>
<li>安全性和隐私问题：如果数据包含敏感信息，推模型可能会引发安全和隐私问题，因为数据在推送过程中可能会被截获或访问到。</li>
</ol>
</li>
</ul>
<p>拉模型：</p>
<ul>
<li>优势：<ol>
<li>灵活性：观察者可以根据需要主动拉取所需的数据，可以减少不必要的数据传输。</li>
<li>数据控制：观察者可以根据具体情况控制拉取数据的频率和量，从而减少网络带宽和资源消耗。</li>
</ol>
</li>
<li><p>权衡：</p>
<ol>
<li><strong>延迟性</strong>：拉模型需要观察者主动发起请求才能获取数据，可能会引入一定的延迟。</li>
<li>实时性限制：观察者只能获取其主动请求的数据更新，无法立即获知所有最新的数据。</li>
</ol>
<p>[!IMPORTANT]</p>
</li>
</ul>
<p>【2022】What is the difference between the categories of Creational Patterns and Structural<br>Patterns</p>
<ol>
<li><p>创建型模式（Creational Patterns）和结构型模式（Structural Patterns）是面向对象设计中的两个主要模式分类。</p>
<p>创建型模式关注<strong>对象的创建机制和实例化过程</strong>，主要用于解决对象的创建和初始化的问题。这些模式将对象的创建与使用代码解耦，使得系统更加灵活和可扩展。创建型模式的例子包括工厂模式、抽象工厂模式、单例模式、建造者模式和原型模式等。</p>
<p>结构型模式关注<strong>对象之间的组合和关联关系</strong>，主要用于描述对象和类之间的静态结构和组织方式。这些模式通过定义类和对象之间的关系，提供了一种实现系统组件之间协作的方式。结构型模式的例子包括适配器模式、装饰器模式、代理模式、组合模式、外观模式、桥接模式和享元模式等。</p>
<p>行为型模式关注<strong>对象之间的交互和职责分配</strong>，可以减少对象间的耦合度，提高系统的灵活性和可扩展性。行为型模式的例子包括观察者模式、策略模式、模板方法模式、命令模式、迭代器模式、状态模式、访问者模式和解释器模式等。</p>
<p>[!IMPORTANT]</p>
</li>
</ol>
<p>【2023】装饰者模式为什么比用子类扩展功能有更好的灵活性？</p>
<p><strong>运行时灵活性</strong></p>
<p>​    •    <strong>子类扩展</strong>：功能的扩展是在编译时确定的，一旦一个类被定义并编译，就不能在运行时更改其行为。</p>
<p>​    •    <strong>装饰者模式</strong>：可以在运行时动态地添加、删除或更改功能。通过将一个对象包裹在多个装饰者对象中，可以在运行时灵活地组合不同的功能。</p>
<p><strong>2. 减少类的数量</strong></p>
<p>​    •    <strong>子类扩展</strong>：每增加一个新的功能组合，都需要创建一个新的子类，这会导致类爆炸（类的数量急剧增加）。</p>
<p>​    •    <strong>装饰者模式</strong>：通过组合现有的装饰者，可以减少类的数量。每个装饰者只负责一个功能，可以在不同的对象间重复使用。</p>
<p><strong>3. 单一职责原则</strong></p>
<p>​    •    <strong>子类扩展</strong>：子类通常承担了多种功能的职责，违反单一职责原则，使代码复杂且难以维护。</p>
<p>​    •    <strong>装饰者模式</strong>：每个装饰者类只增加特定的功能，使得代码更加模块化和清晰，符合单一职责原则。</p>
<p><strong>4. 组合方式多样</strong></p>
<p>​    •    <strong>子类扩展</strong>：通过继承添加功能是线性的，只能在一个类层次结构中进行扩展。</p>
<p>​    •    <strong>装饰者模式</strong>：装饰者可以以任意组合的方式叠加使用，不同的装饰者可以以不同的顺序应用，从而实现多种功能的组合，增加了系统的灵活性和可扩展性。</p>
<p>  [!IMPORTANT]</p>
<p>【2023】为什么最小知识原则可以帮助构建高内聚、低耦合的系统？用代码举一个违背的例子</p>
<p>最小知识原则（Principle of Least Knowledge），也称为迪米特法则（Law of Demeter），建议对象只应与其直接关系的对象交互，而不应该依赖于间接关系的对象。这个原则的主要目的是减少对象之间的耦合，从而提高系统的内聚性和可维护性。</p>
<p>  [!IMPORTANT]</p>
<p>【2022】【2023】What is the benefit of decoupling the Receiver from the Invoker in the Command Pattern?</p>
<p>在命令模式（Command Pattern）中，将接收者（Receiver）与调用者（Invoker）解耦合有以下几个好处：</p>
<ol>
<li><p><strong>提高灵活性和可扩展性</strong>：</p>
<ul>
<li>通过将动作封装成独立的命令对象，可以轻松地添加新的命令，而不需要修改现有的代码。这种方式使得系统在需要扩展时更加灵活。</li>
</ul>
</li>
<li><p><strong>降低耦合度</strong>：</p>
<ul>
<li>调用者与接收者之间的直接依赖被去除，改为通过命令对象进行交互。这种方式降低了对象之间的耦合度，使得系统更加模块化和易于维护。</li>
</ul>
</li>
<li><p><strong>支持撤销（Undo）和重做（Redo）功能</strong>：</p>
<ul>
<li>命令对象可以存储有关操作的状态信息，这使得实现操作的撤销和重做变得更加容易。</li>
</ul>
</li>
<li><p><strong>支持请求的排队和日志记录</strong>：</p>
<ul>
<li>命令对象可以被排队、记录日志或持久化，这样可以在以后重新执行这些命令。这对于需要可靠性和审计跟踪的系统特别有用。</li>
</ul>
</li>
<li><p><strong>简化调用者的代码</strong>：</p>
<ul>
<li>调用者只需要与命令对象打交道，而不需要了解具体的接收者和操作的实现细节，从而简化了调用者的代码逻辑。</li>
</ul>
</li>
<li><p><strong>促进单一职责原则</strong>：</p>
<ul>
<li>命令模式将发起操作的责任（Invoker）和实际执行操作的责任（Receiver）分离，符合单一职责原则（Single Responsibility Principle），使得每个类都有清晰的职责分工。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h2><ol>
<li>防御式编程：可以预见到（或至少预先推测到）问题所在，断定代码中每个阶段可能出现的错误，并作出相应的防范措施，来防止类似意外的发生。</li>
<li>断言：在开发期间使用的、让程序在运行时进行自检的代码，是对开发人员的警告，通常是一个子程序或宏。断言不可以有副作用。</li>
<li>异常：是将代码中的错误或异常事件传递给调用方代码的一种特殊手段，谨慎使用可以降低复杂度。</li>
<li>错误处理：根据软件类别平衡正确性和健壮性（哪个优先级更高）</li>
<li>隔离程序：隔离程序是以防御式编程为目的而进行隔离的一种方法，将某些接口选定为“安全”区域的边界，对穿越安全区域边界的数据进行合法性检验（集中工作在特定的模块中降成本）</li>
<li>辅助调试代码：辅助进行代码调试的代码，帮助快速检查错误，应该尽早地引入辅助调试代码。</li>
<li>攻击式编程：主动暴露出可能出现的错误，在开发阶段将其暴露显现出来，而在产品代码运行时让他能够自我恢复。</li>
</ol>
<h2 id="表驱动"><a href="#表驱动" class="headerlink" title="表驱动"></a>表驱动</h2><p>表驱动法：一种编程模式</p>
<ol>
<li>目的：表驱动法适用于复杂逻辑，将复杂逻辑从代码中独立出来方便单独维护</li>
<li>原理：从表里面查找信息而不使用逻辑语句 (if 和 else)</li>
<li>具体实现<ol>
<li>直接访问表：直接通过索引值可以从表中找到对应的条目</li>
<li>索引访问表：首先从索引表中找到数据表的地址，然后再从数据表中找到对应的条目 ( 节省空间、管理廉价、容易维护 )</li>
<li>阶梯访问表：根据每项命中的阶梯层次来确定其归属</li>
</ol>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://sebugmaker.github.io">Rain Sun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://sebugmaker.github.io/posts/c1c091e0.html">http://sebugmaker.github.io/posts/c1c091e0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sebugmaker.github.io" target="_blank">Rain's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">软件系统设计</a></div><div class="post_share"><div class="social-share" data-image="https://box.nju.edu.cn/f/a8416f815322466ca6a0/?dl=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/7e934d0c.html" title="BM25简易实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/c9762c29c1924645b1ef/?dl=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BM25简易实现</div></div></a></div><div class="next-post pull-right"><a href="/posts/eb3d82ea.html" title="数据库复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/65d5936759cc46bdab99/?dl=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据库复习</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/8618b667f75848d78fe7/?dl=1" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rain Sun</div><div class="author-info__description">Mia San Mia</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SEBugMaker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SEBugMaker" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sunbugmaker@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
    var sentence = document.querySelector("#poem_sentence")
    var author = document.querySelector("#poem_author")
    var dynasty = document.querySelector("#poem_dynasty")

    var sentenceText = result.data.content
    sentenceText = sentenceText.substr(0, sentenceText.length - 1);
    sentence.innerHTML = sentenceText
    dynasty.innerHTML = result.data.origin.dynasty
    author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#24%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">24软件系统设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24%E8%80%83%E8%AF%95%E5%9B%9E%E5%BF%86"><span class="toc-number">2.</span> <span class="toc-text">24考试回忆</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E9%83%A8%E5%88%86-zh%E9%83%A8%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">架构部分 - zh部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Intro"><span class="toc-number">3.1.</span> <span class="toc-text">Intro</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">架构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88-What-Does-a-Software-Architect-Do"><span class="toc-number">3.1.2.</span> <span class="toc-text">软件架构师在做什么 What Does a Software Architect Do?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%9D%A5%E6%BA%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">架构来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE-4-1-views"><span class="toc-number">3.1.4.</span> <span class="toc-text">视图 4+1 views</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%B4%BB%E5%8A%A8-amp-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%BF%87%E7%A8%8B-Software-Architecture-Process"><span class="toc-number">3.1.5.</span> <span class="toc-text">体系结构活动 &amp; 软件体系结构过程 Software Architecture Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E9%A2%86%E5%9F%9F-Software-Design-amp-Architecture-Knowledge-Areas"><span class="toc-number">3.1.6.</span> <span class="toc-text">软件体系结构和体系结构知识领域 Software Design &amp; Architecture Knowledge Areas</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">质量属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82"><span class="toc-number">3.2.1.</span> <span class="toc-text">软件需求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82-Functional-Requirements"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">功能性需求 Functional Requirements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E9%9C%80%E6%B1%82-Quality-Requirements"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">质量需求 Quality Requirements</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82-Non-functional-Requirements"><span class="toc-number">3.2.1.2.1.</span> <span class="toc-text">非功能性需求 Non-functional Requirements</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F-Constraints"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">约束 Constraints</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">质量属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E6%96%B9%E6%A1%88%E5%BB%BA%E6%A8%A1-Modeling-Quality-Attribute-Scenarios"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">质量属性方案建模 Modeling Quality Attribute Scenarios</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-2"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">质量属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tactics-%E7%AD%96%E7%95%A5-%E5%8E%9F%E5%AD%90%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E5%86%B3%E5%AE%9A"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">Tactics 策略(原子级别的最小的决定)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Checklist-for-Design-and-Analysis"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">Checklist for Design and Analysis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%94%B8%E5%85%B3%E7%9A%84%E9%9C%80%E6%B1%82-Architecturally-Significant-Requirements"><span class="toc-number">3.2.3.</span> <span class="toc-text">架构攸关的需求 Architecturally Significant Requirements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%E4%B8%AD%E6%94%B6%E9%9B%86ASR-Gathering-ASRs-from-Requirements-Documents"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">从需求文档中收集ASR Gathering ASRs from Requirements Documents</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%92%8C%E6%B6%89%E4%BC%97%E9%9D%A2%E8%B0%88%E6%9D%A5%E6%94%B6%E9%9B%86ASR-Gathering-ASRs-by-Interviewing-Stakeholders"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">通过和涉众面谈来收集ASR Gathering ASRs by Interviewing Stakeholders</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Utility%E6%A0%91%E6%9D%A5%E8%8E%B7%E5%8F%96ASR-Capturing-ASRs-in-a-Utility-Tree"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">通过Utility树来获取ASR Capturing ASRs in a Utility Tree</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">架构模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Architectural-Pattern"><span class="toc-number">3.3.1.</span> <span class="toc-text">Architectural Pattern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Module-Patterns"><span class="toc-number">3.3.2.</span> <span class="toc-text">Module Patterns</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%A8%A1%E5%BC%8F-Layered-Pattern"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">分层模式 Layered Pattern</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Component-Connector-Patterns"><span class="toc-number">3.3.3.</span> <span class="toc-text">Component-Connector Patterns</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Broker-Pattern"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">代理模式 Broker Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F-Model-View-Controller-Pattern-MVC"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">模型-视图-控制器模式 Model-View-Controller Pattern(MVC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipe-and-Filter-Pattern-%E7%AE%A1%E9%81%93%E5%92%8C%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">Pipe-and-Filter Pattern 管道和过滤模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Client-Server-Pattern-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.3.4.</span> <span class="toc-text">Client-Server Pattern 客户端-服务端模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peer-to-Peer-Pattern-%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.3.5.</span> <span class="toc-text">Peer-to-Peer Pattern 点对点模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service-Oriented-Pattern-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.3.6.</span> <span class="toc-text">Service-Oriented Pattern 面向服务的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Publish-Subscribe-Pattern-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.3.7.</span> <span class="toc-text">Publish-Subscribe Pattern 发布-订阅模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shared-Data-Pattern-%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F3"><span class="toc-number">3.3.3.8.</span> <span class="toc-text">Shared-Data Pattern 共享数据模式3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocation-Patterns"><span class="toc-number">3.3.4.</span> <span class="toc-text">Allocation Patterns</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-Reduce-Pattern"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">Map-Reduce Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multi-Tier-Pattern-%E5%A4%9A%E5%B1%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">Multi-Tier Pattern 多层模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Patterns-VS-Tactics"><span class="toc-number">3.3.5.</span> <span class="toc-text">Patterns VS Tactics</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">设计架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#General-Design-Strategy"><span class="toc-number">3.4.1.</span> <span class="toc-text">General Design Strategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Categories-of-design-desicions"><span class="toc-number">3.4.2.</span> <span class="toc-text">Categories of design desicions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Attribute-Driven-Design-2-0"><span class="toc-number">3.4.3.</span> <span class="toc-text">Attribute-Driven Design 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ADD%E7%9A%84%E6%AD%A5%E9%AA%A4%E6%A6%82%E8%BF%B0"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">ADD的步骤概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E7%A1%AE%E8%AE%A4%E6%9C%89%E8%B6%B3%E5%A4%9F%E7%9A%84%E9%9C%80%E6%B1%82%E4%BF%A1%E6%81%AF"><span class="toc-number">3.4.3.1.1.</span> <span class="toc-text">步骤1：确认有足够的需求信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E9%80%89%E6%8B%A9%E8%A6%81%E5%88%86%E8%A7%A3%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%85%83%E7%B4%A0"><span class="toc-number">3.4.3.1.2.</span> <span class="toc-text">步骤2：选择要分解的系统元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E7%A1%AE%E5%AE%9A%E6%89%80%E9%80%89%E5%85%83%E7%B4%A0%E7%9A%84ASR"><span class="toc-number">3.4.3.1.3.</span> <span class="toc-text">步骤3：确定所选元素的ASR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A44%EF%BC%9A%E9%80%89%E6%8B%A9%E7%AC%A6%E5%90%88ASR%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.4.3.1.4.</span> <span class="toc-text">步骤4：选择符合ASR的设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A45%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%9E%B6%E6%9E%84%E5%85%83%E7%B4%A0%E5%B9%B6%E5%88%86%E9%85%8D%E8%81%8C%E8%B4%A3"><span class="toc-number">3.4.3.1.5.</span> <span class="toc-text">步骤5：实例化架构元素并分配职责</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A46%EF%BC%9A%E4%B8%BA%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%85%83%E7%B4%A0%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.3.1.6.</span> <span class="toc-text">步骤6：为实例化元素定义接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A47%EF%BC%9A%E9%AA%8C%E8%AF%81%E5%92%8C%E5%AE%8C%E5%96%84%E9%9C%80%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%BD%BF%E5%85%B6%E6%88%90%E4%B8%BA%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%85%83%E7%B4%A0%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.4.3.1.7.</span> <span class="toc-text">步骤7：验证和完善需求，并使其成为实例化元素的约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A48%EF%BC%9A%E9%87%8D%E5%A4%8D%E8%BF%9B%E8%A1%8C%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%BB%A1%E8%B6%B3%E6%89%80%E6%9C%89ASR"><span class="toc-number">3.4.3.1.8.</span> <span class="toc-text">步骤8：重复进行，直到满足所有ASR</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inputs-amp-Outputs-to-ADD"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">Inputs &amp; Outputs to ADD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Document-Architecture"><span class="toc-number">3.5.</span> <span class="toc-text">Document Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Views"><span class="toc-number">3.5.1.</span> <span class="toc-text">Views</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Styles-viewpoints-patterns-and-views"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">Styles (viewpoints), patterns and views</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Three-Categories-of-Styles"><span class="toc-number">3.5.1.1.1.</span> <span class="toc-text">Three Categories of Styles</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Styles-vs-Patterns"><span class="toc-number">3.5.1.1.2.</span> <span class="toc-text">Styles vs. Patterns</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Architectural-Views"><span class="toc-number">3.5.1.1.3.</span> <span class="toc-text">Architectural Views</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Structural-view"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">Structural view</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Quality-views"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">Quality views</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Documenting-views"><span class="toc-number">3.5.2.</span> <span class="toc-text">Documenting views</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Beyond-Information-Beyond-Views"><span class="toc-number">3.5.3.</span> <span class="toc-text">Beyond (Information Beyond Views)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Documentation-package-views-beyond"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">Documentation package: views + beyond</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0"><span class="toc-number">3.6.</span> <span class="toc-text">架构评估</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90-amp-%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.1.</span> <span class="toc-text">架构分析 &amp; 评估方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ATAM%EF%BC%9AArchitecture-Tradeoff-Analysis-Method"><span class="toc-number">3.6.2.</span> <span class="toc-text">ATAM：Architecture Tradeoff Analysis Method</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Inputs-to-and-Outputs-of-ATAM"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">Inputs to and Outputs of ATAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phase-0-Partnership-amp-Preparation"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">Phase 0 - Partnership &amp; Preparation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phase-1-Evaluation-1"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">Phase 1 -  Evaluation (1)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Step1-Present-the-ATAM"><span class="toc-number">3.6.2.3.1.</span> <span class="toc-text">Step1 - Present the ATAM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step2-Present-the-Business-Drivers"><span class="toc-number">3.6.2.3.2.</span> <span class="toc-text">Step2 - Present the Business Drivers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step3-Present-the-architecture"><span class="toc-number">3.6.2.3.3.</span> <span class="toc-text">Step3 - Present the architecture</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step4-Identify-Architectural-Approaches"><span class="toc-number">3.6.2.3.4.</span> <span class="toc-text">Step4 - Identify Architectural Approaches</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step5-Generate-Quality-Attribute-Utility-Tree"><span class="toc-number">3.6.2.3.5.</span> <span class="toc-text">Step5 - Generate Quality Attribute Utility Tree</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step6-Analyze-Architectural-Approaches"><span class="toc-number">3.6.2.3.6.</span> <span class="toc-text">Step6 - Analyze Architectural Approaches</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phase-2-Evaluation-2"><span class="toc-number">3.6.2.4.</span> <span class="toc-text">Phase 2 - Evaluation (2)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Step-1-Present-the-ATAM-amp-Previous-Results"><span class="toc-number">3.6.2.4.1.</span> <span class="toc-text">Step-1: Present the ATAM &amp; Previous Results</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step-7-Brainstorm-amp-Prioritize-Scenarios"><span class="toc-number">3.6.2.4.2.</span> <span class="toc-text">Step-7: Brainstorm &amp; Prioritize Scenarios</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step-8-Analyze-Architectual-Approaches"><span class="toc-number">3.6.2.4.3.</span> <span class="toc-text">Step-8: Analyze Architectual Approaches</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step-9-Present-Results"><span class="toc-number">3.6.2.4.4.</span> <span class="toc-text">Step-9: Present Results</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phase-3-Follow-up"><span class="toc-number">3.6.2.5.</span> <span class="toc-text">Phase 3 - Follow-up</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E5%88%86"><span class="toc-number">4.</span> <span class="toc-text">微服务部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">微服务定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">主要特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOA-%F0%9F%86%9A-MSA"><span class="toc-number">4.3.</span> <span class="toc-text">SOA 🆚 MSA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.4.</span> <span class="toc-text">关键步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E7%AD%96%E7%95%A5"><span class="toc-number">4.5.</span> <span class="toc-text">重构策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E9%83%A8%E5%88%86-pmx%E9%83%A8%E5%88%86"><span class="toc-number">5.</span> <span class="toc-text">详细设计部分 - pmx部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">5.1.</span> <span class="toc-text">设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">5.2.1.</span> <span class="toc-text">设计模式分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%AE%80%E7%AD%94%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">相关简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">防御式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8"><span class="toc-number">5.5.</span> <span class="toc-text">表驱动</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7e934d0c.html" title="BM25简易实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/c9762c29c1924645b1ef/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BM25简易实现"/></a><div class="content"><a class="title" href="/posts/7e934d0c.html" title="BM25简易实现">BM25简易实现</a><time datetime="2024-07-06T08:40:44.000Z" title="发表于 2024-07-06 16:40:44">2024-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1c091e0.html" title="软件系统设计复习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/a8416f815322466ca6a0/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件系统设计复习"/></a><div class="content"><a class="title" href="/posts/c1c091e0.html" title="软件系统设计复习">软件系统设计复习</a><time datetime="2024-06-24T08:28:17.000Z" title="发表于 2024-06-24 16:28:17">2024-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eb3d82ea.html" title="数据库复习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/65d5936759cc46bdab99/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库复习"/></a><div class="content"><a class="title" href="/posts/eb3d82ea.html" title="数据库复习">数据库复习</a><time datetime="2024-06-11T09:01:46.000Z" title="发表于 2024-06-11 17:01:46">2024-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3a00daf2.html" title="最近听的歌第一期"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/365b81efc4ad4879a819/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="最近听的歌第一期"/></a><div class="content"><a class="title" href="/posts/3a00daf2.html" title="最近听的歌第一期">最近听的歌第一期</a><time datetime="2024-06-10T12:15:23.000Z" title="发表于 2024-06-10 20:15:23">2024-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c22f54fd.html" title="An Empirical Study on the Usage of Transformer Models for Code Completion"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/49fb0997934545dbae83/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="An Empirical Study on the Usage of Transformer Models for Code Completion"/></a><div class="content"><a class="title" href="/posts/c22f54fd.html" title="An Empirical Study on the Usage of Transformer Models for Code Completion">An Empirical Study on the Usage of Transformer Models for Code Completion</a><time datetime="2024-05-24T14:44:39.000Z" title="发表于 2024-05-24 22:44:39">2024-05-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Rain Sun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.rainsgy.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.rainsgy.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="8251277445" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = '9a4f31a8f3de9ac55803';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html><div id="sakana-widget" style="position:fixed;bottom:0px;right:0px;"></div><script>function initSakanaWidget() {
  new SakanaWidget().mount('#sakana-widget');
}</script><script async="" onload="initSakanaWidget()" src="https://cdn.jsdelivr.net/npm/sakana-widget@2.2.1/lib/sakana.min.js"></script>