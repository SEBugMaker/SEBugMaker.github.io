<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>嵌入式系统概论期末复习 | Rain's Blog</title><meta name="author" content="Rain Sun"><meta name="copyright" content="Rain Sun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="嵌入式系统概论复习lecture 1 - 嵌入式系统概述嵌入式系统的定义 “嵌入式系统”实际上是“嵌入式计算机系统”的简称  &#x3D;&#x3D;IEEE&#x3D;&#x3D;（国际电气和电子工程师协会）的定义：嵌入式系统是“用于控制、监视或者辅助操作机器和设备的装置” (Devices used to control, monitor, or assist the operation of equipment, machiner">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式系统概论期末复习">
<meta property="og:url" content="http://sebugmaker.github.io/posts/612fa1e.html">
<meta property="og:site_name" content="Rain&#39;s Blog">
<meta property="og:description" content="嵌入式系统概论复习lecture 1 - 嵌入式系统概述嵌入式系统的定义 “嵌入式系统”实际上是“嵌入式计算机系统”的简称  &#x3D;&#x3D;IEEE&#x3D;&#x3D;（国际电气和电子工程师协会）的定义：嵌入式系统是“用于控制、监视或者辅助操作机器和设备的装置” (Devices used to control, monitor, or assist the operation of equipment, machiner">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://box.nju.edu.cn/f/23f2833d55ac43308a73/?dl=1">
<meta property="article:published_time" content="2023-12-06T12:48:13.000Z">
<meta property="article:modified_time" content="2023-12-31T07:57:36.022Z">
<meta property="article:author" content="Rain Sun">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://box.nju.edu.cn/f/23f2833d55ac43308a73/?dl=1"><link rel="shortcut icon" href="https://box.nju.edu.cn/f/02da4b126cc04fd4951f/?dl=1"><link rel="canonical" href="http://sebugmaker.github.io/posts/612fa1e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '嵌入式系统概论期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-31 15:57:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/myhead.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body>
    <div id='loader'>
        
            <div class="loading-left-bg"></div>
            <div class="loading-right-bg"></div>
            <div class="spinner-box">
                <div class="configure-border-1">
                    <div class="configure-core"></div>
                </div>
                <div class="configure-border-2">
                    <div class="configure-core"></div>
                </div>
                <div class="loading-word">加载中...</div>
            </div>
        
    </div>

    <script>
        var endLoading = function () {
            document.body.style.overflow = 'auto';
            document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
<div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/8618b667f75848d78fe7/?dl=1" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://box.nju.edu.cn/f/23f2833d55ac43308a73/?dl=1')"><nav id="nav"><span id="blog-info"><a href="/" title="Rain's Blog"><span class="site-name">Rain's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">嵌入式系统概论期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-06T12:48:13.000Z" title="发表于 2023-12-06 20:48:13">2023-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-31T07:57:36.022Z" title="更新于 2023-12-31 15:57:36">2023-12-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>85分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="嵌入式系统概论期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="嵌入式系统概论复习"><a href="#嵌入式系统概论复习" class="headerlink" title="嵌入式系统概论复习"></a>嵌入式系统概论复习</h1><h2 id="lecture-1-嵌入式系统概述"><a href="#lecture-1-嵌入式系统概述" class="headerlink" title="lecture 1 - 嵌入式系统概述"></a>lecture 1 - 嵌入式系统概述</h2><h3 id="嵌入式系统的定义"><a href="#嵌入式系统的定义" class="headerlink" title="嵌入式系统的定义"></a>嵌入式系统的定义</h3><ul>
<li><p>“嵌入式系统”实际上是“嵌入式计算机系统”的简称</p>
</li>
<li><p>==IEEE==（国际电气和电子工程师协会）的定义：嵌入式系统是“用于控制、监视或者辅助操作机器和设备的装置” (Devices used to control, monitor, or assist the operation of equipment, machinery or plants)。</p>
<p>该定义是从应用上考虑的，嵌入式系统是软件和硬件的综合体，还可以涵盖机电等附属装置</p>
</li>
<li><p>==国内普遍被认同的定义==：嵌入式系统是“以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统”。</p>
<p>嵌入式系统就是一个具有特定功能或用途的隐藏在某种设备中的计算机软硬件集合体，没有固定的特征形状。</p>
</li>
</ul>
<h3 id="嵌入式系统三要素"><a href="#嵌入式系统三要素" class="headerlink" title="嵌入式系统三要素"></a>嵌入式系统三要素</h3><ul>
<li>嵌入性：嵌入到对象体系中，有对象环境要求</li>
<li>专用型：软、硬件按对象要求设计、裁减</li>
<li>计算机：实现对象的智能化功能</li>
</ul>
<h3 id="无处不在的嵌入式"><a href="#无处不在的嵌入式" class="headerlink" title="无处不在的嵌入式"></a>无处不在的嵌入式</h3><h4 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h4><p>信息物理系统，Cyber-Physical System (CPS)，计算进程和物理进程的统一体，集计算、通信、控制于一体的下一代智能系统，由嵌入式系统、互联网和控制器组成</p>
<h4 id="WSN"><a href="#WSN" class="headerlink" title="WSN"></a>WSN</h4><p>无线感知网络，Wireless sensor network（WSN），是由许多在空间中分布的自动装置组成的一种无线通信计算机网络，这些装置使用传感器协作地监控不同位置的物理或环境状况（比如温度、声音、振动、压力、运动或污染物）。无线传感器网络的发展最初起源于战场监测等军事应用。而现今无线传感器网络被应用于很多民用领域，如环境与生态监测、健康监护、家居自动化以及交通控制等。</p>
<h4 id="IOT"><a href="#IOT" class="headerlink" title="IOT"></a>IOT</h4><p>物联网，Internet of Things (IoT) ，通过射频识别(RFID)、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络概念</p>
<ul>
<li>实现任何时间、任何地点，人、机、物的互联互通</li>
<li>互联、协同</li>
<li>面向生产的物联网技术开发被称为“工业4.0”</li>
</ul>
<h3 id="嵌入式系统组成"><a href="#嵌入式系统组成" class="headerlink" title="嵌入式系统组成"></a>嵌入式系统组成</h3><ul>
<li>==嵌⼊式系统⼀般由嵌⼊式硬件和软件组成==<ul>
<li>硬件以微处理器为核⼼集成存储器和系统专⽤的输⼊/输出设备</li>
<li>软件包括：初始化代码及驱动、嵌⼊式操作系统和应⽤程序等，这些软件有机地结合在⼀起，形成系统特定的⼀体化软件</li>
</ul>
</li>
<li>从上至下依次为：应用软件 - 中间件 - 运行/实时内核 - 驱动 - 系统硬件</li>
</ul>
<h3 id="与通用计算机的区别"><a href="#与通用计算机的区别" class="headerlink" title="与通用计算机的区别"></a>与通用计算机的区别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/3a05f36c6ad54aecbf0d/?dl=1"></p>
<h3 id="嵌入式系统的特点"><a href="#嵌入式系统的特点" class="headerlink" title="嵌入式系统的特点"></a>嵌入式系统的特点</h3><ul>
<li><p>嵌入式系统通常是形式多样、面向特定应用的</p>
<ul>
<li>一般用于特定的任务</li>
<li>通常都具有低功耗、体积小、集成度高等特点</li>
<li>应用程序和操作系统两种软件的一体化程序</li>
</ul>
</li>
<li><p>嵌入式系统得到多种类型的处理器和处理器体系结构的支持</p>
<ul>
<li>可采用多种类型的处理器和处理器体系结构</li>
</ul>
</li>
<li><p>嵌入式系统通常极其关注成本</p>
<ul>
<li>一次性的开发成本NRE(Non-Recurring Engineering)成本</li>
<li>产品成本:硬件BOM、外壳包装和软件版税等</li>
<li>批量产品的总体成本=NRE成本+每个产品成本*产品总量</li>
<li>每个产品的最后成本=总体成本/产品总量=NRE成本/产品总量+每个产品成本</li>
</ul>
</li>
<li><p>嵌入式系统有实时性和可靠性的要求</p>
<ul>
<li>大多数实时系统都是嵌入式系统，嵌入式系统多数有实时性的要求</li>
<li>一般要求具有出错处理和自动复位功能</li>
</ul>
</li>
<li><p>嵌入式系统使用的操作系统一般是适应多种处理器、可剪裁、轻量型、实时可靠、可固化的嵌入式操作系统</p>
<ul>
<li>嵌入式操作系统规模小</li>
</ul>
</li>
<li><p>嵌入式系统开发需要专门工具和特殊方法</p>
<ul>
<li>开发环境包括专门的开发工具（包括设计、编译、调试、测试等工具），采用交叉开发的方式进行</li>
</ul>
</li>
</ul>
<h3 id="嵌入式系统分类"><a href="#嵌入式系统分类" class="headerlink" title="嵌入式系统分类"></a>嵌入式系统分类</h3><ul>
<li><p>按嵌入式处理器的位数来分类</p>
<ul>
<li>4，8位已经大量应用</li>
<li>16位</li>
<li>32位成为主流</li>
<li>64位⾼度复杂的、⾼速的嵌⼊式系统已开始采⽤</li>
</ul>
</li>
<li><p>按应用来分类</p>
<ul>
<li>移动互联网、可穿戴设备、生物仿真、环境工程、信息通讯、智能农业、智慧交通等。</li>
</ul>
</li>
<li><p>按速度分类</p>
<ul>
<li>强实时系统, 其系统响应时间在毫秒或微秒级；</li>
<li>⼀般实时系统, 其系统响应时间在⼏秒的数量级上,其实时性的要求⽐强实时系统要差⼀些；</li>
<li>弱实时系统, 其系统响应时间约为数⼗秒或更⻓。这种系统的响应时间可能随系统负载的轻重⽽变化。</li>
</ul>
</li>
<li><p>按确定性来分类</p>
<ul>
<li>硬实时系统：系统对系统响应时间有严格的要求，如果系统响应时间不能满⾜，就要引起系统崩溃或致命的错误。</li>
<li>软实时系统：系统对系统响应时间有要求，但是如果系统响应时间不能满⾜，不会导致系统出现致命的错误或崩溃。</li>
</ul>
</li>
<li><p>按嵌入式系统软件复杂程度来分类</p>
<ul>
<li>循环轮询系统、有限状态机系统、前后台系统、单处理器多任务系统、多处理器多任务系统。</li>
</ul>
</li>
</ul>
<h2 id="lecture-2-嵌⼊式系统设计⽅法"><a href="#lecture-2-嵌⼊式系统设计⽅法" class="headerlink" title="lecture 2 - 嵌⼊式系统设计⽅法"></a>lecture 2 - 嵌⼊式系统设计⽅法</h2><h3 id="嵌入式系统设计所面临的挑战"><a href="#嵌入式系统设计所面临的挑战" class="headerlink" title="嵌入式系统设计所面临的挑战"></a>嵌入式系统设计所面临的挑战</h3><ol>
<li>需要多少硬件？</li>
<li>如何满足时限需求，如何处理多项功能在时间上的协同关系？</li>
<li>如何降低系统的功耗？</li>
<li>如何设计以保证系统可升级？</li>
<li>如何保证系统可靠地工作？</li>
</ol>
<h3 id="传统的嵌入式开发过程"><a href="#传统的嵌入式开发过程" class="headerlink" title="传统的嵌入式开发过程"></a>传统的嵌入式开发过程</h3><p>1.系统在一开始就被划分为软件和硬件两大部分</p>
<p>2.软件和硬件独立进行开发设计</p>
<p>3.经常采用“硬件优先”方法</p>
<p>问题：</p>
<p>1.软硬件之间的交互受到很大限制：凭经验划分软硬件，软硬件之间的相互性能影响很难评估。</p>
<p>2.系统集成滞后，一次性工程费用过高。</p>
<p>3.设计质量差、设计修改难、研制周期不能得到保障。</p>
<h3 id="软硬件协同设计-HW-SW-Co-design"><a href="#软硬件协同设计-HW-SW-Co-design" class="headerlink" title="软硬件协同设计 HW/SW Co-design"></a>软硬件协同设计 HW/SW Co-design</h3><p>1.软硬件协同设计是指对系统中的软硬件部分使用统一的描述和工具进行集成开发，可完成全系统的设计验证并跨越软硬件界面进行系统优化。</p>
<p>2.软硬件协同设计可以通过协同作用来实现系统级目标</p>
<p>3.软硬件协同设计提供分析方法和综合方法提高嵌入式系统设计的可预测性，在告诉设计者性能是否满足的同时，让设计者评估潜在的设计方法。</p>
<p>4.已成为主流技术。</p>
<h3 id="软硬件划分（影响软硬件折衷方案——双重性、速度、灵活性、开销，双重性为前提）"><a href="#软硬件划分（影响软硬件折衷方案——双重性、速度、灵活性、开销，双重性为前提）" class="headerlink" title="软硬件划分（影响软硬件折衷方案——双重性、速度、灵活性、开销，双重性为前提）"></a>软硬件划分（影响软硬件折衷方案——双重性、速度、灵活性、开销，双重性为前提）</h3><p>1.设计中必须决定什么功能由硬件实现，什么功能由软件实现。</p>
<p>2.硬件和软件具有双重性，是划分决策的前提。</p>
<p>3.软硬件变动对系统的决策造成影响。</p>
<p>通常由==软件==实现的部分：操作系统功能（任务调度、资源管理、设备驱动）；协议栈（TCP/IP）；应用软件框架。</p>
<p>通常由==硬件==实现的部分：基本系统，物理接口，基本逻辑电路。</p>
<p>双重部分：算法（加密解密、编码解码、压缩解压）；数学运算（浮点运算、FFT）。</p>
<p>软硬件技术对系统结构的影响：硬软件的设计呈现融合渗透的趋势；系统设计更加趋于协同设计，在增加灵活性的同时增加了风险。</p>
<h2 id="lecture-3-嵌⼊式微处理器"><a href="#lecture-3-嵌⼊式微处理器" class="headerlink" title="lecture 3 - 嵌⼊式微处理器"></a>lecture 3 - 嵌⼊式微处理器</h2><p>硬件平台包含CPU，总线bus，存储器memory，I/O设备等</p>
<p>流行的微处理器：ARM，MIPS，X86</p>
<h3 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h3><ul>
<li>将程序指令存储器和数据存储器和并在一起的存储器结构</li>
<li>程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同</li>
<li>CPU寄存器: 程序计数器(PC)，指令寄存器(IR)，通用寄存器等</li>
</ul>
<h3 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h3><p>==特点==：</p>
<ol>
<li>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</li>
<li>使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联</li>
</ol>
<p>==应用==：</p>
<p>大多数DSP使用哈佛架构来处理流数据</p>
<ul>
<li>更大的内存带宽</li>
<li>更可预测的带宽</li>
</ul>
<p>改进的哈佛结构：</p>
<ol>
<li>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</li>
<li>具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；</li>
<li>两条总线由程序存储器和数据存储器分时共用。</li>
</ol>
<h3 id="RISC-VS-CISC"><a href="#RISC-VS-CISC" class="headerlink" title="RISC VS CISC"></a>RISC VS CISC</h3><p>RISC：精简指令集计算机</p>
<ul>
<li>load/store</li>
<li>流水线指令</li>
</ul>
<p>CISC：复杂指令计算机</p>
<ul>
<li>多种寻址模式</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/612fa1e/3.png" class="">
<h4 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h4><ul>
<li>简单，完全开源且免费</li>
<li>将基准指令和扩展指令分开，可以通过扩展指令做定制化的模块和扩展（基准指令确定后将不会再有变化，这是RISC-V稳定性的重要保障）</li>
<li>32，64，128位指令集</li>
</ul>
<h3 id="嵌入式微处理器的分类"><a href="#嵌入式微处理器的分类" class="headerlink" title="嵌入式微处理器的分类"></a>嵌入式微处理器的分类</h3><ol>
<li>位数<ul>
<li>4，8，26，32，64位</li>
</ul>
</li>
<li>功能<ul>
<li>嵌入式微处理单元（MPU）<ul>
<li>嵌入式微处理器就是和通用计算机的处理器对应的CPU<ul>
<li>功能和微处理器基本一样,是具有32位以上的处理器,具有较高的性能</li>
<li>具有体积小,功耗少,成本低,可靠性高的特点.</li>
<li>有的可提供工业级应用</li>
</ul>
</li>
<li>流行的嵌入式微处理器：ARM，MIPS</li>
</ul>
</li>
<li>嵌入式微控制器（MCU）<ul>
<li>嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中,芯片内部集成ROM/EPROM, RAM, 总线, 总线逻辑, 定时/计数器, Watchdog, I/O, 串行口等各种必要功能和外设.</li>
<li>特点<ul>
<li>一个系列的微控制器具有多种衍生产品</li>
<li>==单片化,体积大大减小,功耗和成本降低,可靠性提高==;</li>
<li>是目前==嵌入式工业的主流==,约占嵌入式系统50%的份额;</li>
<li>多是8位和16位处理器</li>
</ul>
</li>
<li>流行的MCU：通用系列（8051，MC683xx，Cortex-M0/3/4/7），本通用系列（I2C，CAN BUS等）</li>
</ul>
</li>
<li>嵌入式DSP处理器<ul>
<li>嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</li>
<li>应用：数字滤波，频谱分析，FFT</li>
<li>流行的DSP：德州仪器（T1），模拟器件公司（ADI），摩托罗拉公司</li>
</ul>
</li>
<li>嵌入式SoC<ul>
<li>嵌入式SoC是追求产品系统最大包容的集成器件。绝大多数系统构件都在一个系统芯片内部</li>
<li>SoC芯片可以有效地降低电子/信息系统产品的开发成本，缩短开发周期，提高产品的竞争力</li>
<li>特点：<ul>
<li>结构简洁</li>
<li>体积小、功耗小</li>
<li>可靠性高</li>
<li>设计生产效率高</li>
</ul>
</li>
<li>流行的SoC：高通骁龙，海思</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><p>FPGA 是一种以数字电路为主的集成芯片</p>
<p>现场可编程门阵列，具有可编程特性的的集成电路</p>
<h3 id="DSP与FPGA"><a href="#DSP与FPGA" class="headerlink" title="DSP与FPGA"></a>DSP与FPGA</h3><p><img src = "https://box.nju.edu.cn/f/34244935243448949ff7/?dl=1" ></p>
<h3 id="嵌入式微处理器的特点"><a href="#嵌入式微处理器的特点" class="headerlink" title="嵌入式微处理器的特点"></a>嵌入式微处理器的特点</h3><p>==基础==：通用处理器</p>
<p>与通用微处理器的==区别==：</p>
<ul>
<li>体积小、重量轻、可靠性高</li>
<li>功耗低</li>
<li>成本低：片上存储、引脚与封装、代码密度</li>
<li>工作温度、抗电磁干扰、可靠性等方面增强</li>
</ul>
<h3 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h3><ol>
<li><p>典型的RISC结构</p>
<ul>
<li><p>丰富的寄存器</p>
</li>
<li><p>加载/存储体系结构</p>
</li>
<li><p>简单寻址模式</p>
</li>
<li><p>统一和固定长度的指令字段</p>
</li>
</ul>
</li>
<li><p>增强功能</p>
<ul>
<li><p>每条指令控制ALU和移位器</p>
</li>
<li><p>自动递增和自动递减寻址模式</p>
</li>
<li><p>多个加载/存储</p>
</li>
<li><p>条件执行</p>
</li>
</ul>
</li>
<li><p>结果</p>
<ul>
<li><p>高性能</p>
</li>
<li><p>低代码大小</p>
</li>
<li><p>低功耗</p>
</li>
<li><p>低硅面积</p>
</li>
</ul>
</li>
</ol>
<h3 id="选择微处理器的原则"><a href="#选择微处理器的原则" class="headerlink" title="选择微处理器的原则"></a>选择微处理器的原则</h3><ol>
<li>高效、经济地满足任务的计算需求<ul>
<li>速度，ROM和RAM的数量，I/O端口和定时器的数量，尺寸，封装，功耗</li>
<li>易于升级</li>
<li>单位成本</li>
</ul>
</li>
<li>软件开发工具的可用性<ul>
<li>汇编器，调试器，C编译器，仿真器，模拟器，技术支持</li>
</ul>
</li>
<li>广泛的可用性和可靠的微控制器来源</li>
</ol>
<h3 id="选择微处理器的十个步骤"><a href="#选择微处理器的十个步骤" class="headerlink" title="选择微处理器的十个步骤"></a>选择微处理器的十个步骤</h3><p>列出硬件接口、检查软件架构、选择体系结构、确定内存需求、搜索微控制器、检查成本和功率约束、检查零件可用性、选择一个开发包、研究编译器和工具、开始实验</p>
<h2 id="lecture-4-存储器架构"><a href="#lecture-4-存储器架构" class="headerlink" title="lecture 4 - 存储器架构"></a>lecture 4 - 存储器架构</h2><p>对许多应用来说，存储系统对整个系统性能的影响比对数据流水线的影响更大</p>
<p>==复杂性==：</p>
<ol>
<li>在同一个嵌入式系统中，通常需要组合各种存储技术<ul>
<li>至少需要一些非易失性存储和一些易失性存储</li>
<li>多种选择</li>
</ul>
</li>
<li>层次结构往往是必须的</li>
<li>处理器架构的地址空间被分解成若干子空间来提供不同类型的存储器访问</li>
</ol>
<h3 id="易失性存储器"><a href="#易失性存储器" class="headerlink" title="易失性存储器"></a>易失性存储器</h3><p>==断电时内容消失==的存储器</p>
<p>随机存储存储器（RAM）</p>
<p>SRAM</p>
<ol>
<li>静态RAM，SRAM：速度快，面积大</li>
<li>动态RAM，DRAM：保持数据的时间很短，需要定期刷新，比SRAM更不稳定</li>
</ol>
<h4 id="在嵌入式系统中的应用"><a href="#在嵌入式系统中的应用" class="headerlink" title="在嵌入式系统中的应用"></a>在嵌入式系统中的应用</h4><ol>
<li>大多数嵌入式系统都包括一个SRAM，许多ES也会包括DRAM<ul>
<li>因为只利用SRAM不能提供足够大的存储容量</li>
</ul>
</li>
<li>影响程序执行时间<ul>
<li>被访问的存储器地址是映射到SRAM还是DRAM</li>
<li>DRAM可能在忙于刷新时被请求访问，因此DRAM刷新周期会引起访问时间的变化</li>
<li>访问历史也可以影响存取时间</li>
</ul>
</li>
</ol>
<h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><p>不需要持续供电来保留存储在计算设备中的数据或程序代码</p>
<ul>
<li>只读存储器（ROM），或掩模ROM（Mask ROM）：内容在芯片工厂就已经固定</li>
<li>电可擦除可编程ROM（EEPROM）</li>
<li>快闪存储器（Flash）<ul>
<li>有比较快的读取时间，但比SRAM和DRAM慢<ul>
<li>频繁访问的数据在程序使用之前从flash转移到RAM中</li>
</ul>
</li>
<li>写入时间大大超过读取时间，而且写入的次数是有限的<ul>
<li>SLC：速度快寿命长，存储密度低稳定性好，成本高，约10万次擦写寿命，多数应用高端企业级产品</li>
<li>MLC：速度一般寿命一般，成本一般，约3000—10000次擦写寿命，应用民用中高端SSD上</li>
<li>TLC，速度慢，成本最低，使用寿命也最短，约1000次擦写寿命</li>
</ul>
</li>
<li>类型<ul>
<li>NOR：按块擦除，擦除和写入时间较长，但能够像RAM那样访问</li>
<li>NAND：以块为单位，一个数据块是数百或数千比特，擦除和写入速度比较快，按页读取(512-4K字节)</li>
</ul>
</li>
</ul>
</li>
<li>磁盘存储器</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/ba207ba1ffd74d248e49/?dl=1" ></p>
<h4 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h4><p>固件（firmware）一般存储于设备中的电可擦除只读存储器或FLASH芯片中，一般可由用户通过特定的刷新程序进行升级的程序</p>
<p>可固化（ROMable）：可被编程到ROM芯片中的机器语言。作为“只读”芯片不能更新，可固化程序必须使用RAM或磁盘来保存变化的数据。</p>
<ul>
<li>代码将从ROM正确执行，不需要复制到RAM，但是RAM可能更快</li>
<li>代码和数据不能混用，除了常量数据</li>
</ul>
<h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p>精确的分层机构取决于技术参数，也取决于应用领域</p>
<ul>
<li><p>处理器寄存器</p>
</li>
<li><p>缓冲存储器：高速缓存、地址转换高速缓存（TLB，也称快表）以及暂存存储器（SPM）。</p>
</li>
<li><p>工作存储器（或主存储器、主存）：实现了处理器存储地址所涵盖的存储器。通常，其容量在几MB到几GB之间，并且是易失的</p>
</li>
<li><p>flash、磁盘等非易失性存储，也可基于互联网的存储器解决方案（如云）</p>
</li>
</ul>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>==高速缓存的架构对应用程序的执行时间具有很大影响==</p>
<p>高速缓存潜在地提高了存储系统的能效</p>
<p>在设计时预测缓存是否命中是很困难的，并且这对实时性能的精确预测而言也是一个负担</p>
<h4 id="多级cache"><a href="#多级cache" class="headerlink" title="多级cache"></a>多级cache</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/bddb9928b1d34ecaa228/?dl=1"></p>
<h3 id="暂存存储器"><a href="#暂存存储器" class="headerlink" title="暂存存储器"></a>暂存存储器</h3><p>SPM，也叫紧耦合内存TCM</p>
<ul>
<li>SPM和主存统一编址，每当某个简单的地址解码器给出一个SPM地址范围内的地址时，SPM就被访问</li>
<li>SPM通常和处理器集成在一个芯片上</li>
<li>功耗低、速度快</li>
</ul>
<h3 id="存储器访问时间难以预测"><a href="#存储器访问时间难以预测" class="headerlink" title="存储器访问时间难以预测"></a>存储器访问时间难以预测</h3><ul>
<li>==虚拟存储器==（Virtual Memory）：使各种存储技术看起来是一个连续的地址空间</li>
<li>==地址转换==：把地址空间的逻辑地址转换成一种存储技术上的物理地址，转换通常是由一个专门硬件协助完成，称为转换后备缓冲器（Translation Lookaside Buffer，TLB），加速地址转换</li>
</ul>
<p>因此，很难预测或理解访问存储器的时间需要多久，因而嵌入式系统设计人员通常比一般程序员需要更深入地理解存储器系统</p>
<h2 id="lecture-5-基于总线的计算机系统"><a href="#lecture-5-基于总线的计算机系统" class="headerlink" title="lecture 5 - 基于总线的计算机系统"></a>lecture 5 - 基于总线的计算机系统</h2><h3 id="I-O接口与设备"><a href="#I-O接口与设备" class="headerlink" title="I/O接口与设备"></a>I/O接口与设备</h3><p>IO接口为了能够==充当设备与计算机的桥梁==，需要多个寄存器</p>
<ul>
<li>数据寄存器</li>
<li>控制寄存器</li>
<li>状态寄存器</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>从属关系<ul>
<li>系统设备：操作系统启动时已经在系统中注册的标准设备（例如NOR/NAND闪存，触摸面板等）<ul>
<li>这些设备的操作系统中有设备驱动程序和管理程序</li>
<li>用户应用程序只需要调用操作系统提供的标准命令或函数就可以使用这些设备</li>
</ul>
</li>
<li>用户设备：操作系统启动时未在系统中注册的非标准设备（典型的设备包括SD卡、u盘等）<ul>
<li>通常设备驱动程序是由用户提供的。用户必须以某种方式将这些设备的控制权转移到操作系统进行管理</li>
</ul>
</li>
</ul>
</li>
<li>使用<ul>
<li>专用设备：==同一时间只能被一个进程使用==的设备。对于多个并发进程，每个进程使用设备是互斥的。一旦操作系统将设备分配给一个特定的进程，==它将被该进程独占，直到该进程使用后释放它==</li>
<li>共享设备：==可被多个进程同时寻址的设备==。共享设备必须是可寻址的，并且是随机寻址的。共享设备机制可以==提高每个设备的利用率==</li>
<li>虚拟设备：通过==虚拟技术==将一台==独占设备虚拟成多台逻辑设备==，供==多个用户进程同时使用==， 通常把这种经过虚拟的设备称为虚拟设备</li>
</ul>
</li>
</ul>
<h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><ul>
<li>特征<ul>
<li>存储设备：用于存储信息的设备。嵌入式系统中的典型例子包括硬盘、固态硬盘、NOR/NAND闪存</li>
<li>I/O设备<ul>
<li>输入设备:输入设备负责将信息从外部输入到内部系统，如触摸面板、条形码扫描仪等</li>
<li>输出设备:输出设备负责将嵌入式系统处理后的信息输出到外部世界，如液晶显示器、扬声器等</li>
</ul>
</li>
</ul>
</li>
<li>信息传输单元<ul>
<li>块设备：这种类型的设备以==数据块为单位==组织和交换数据<ul>
<li>是一种结构化设备，==典型的设备是硬盘==</li>
<li>在I/O操作中，即使只是一个单字节的读/写，也应该读或写整个数据块</li>
</ul>
</li>
<li>字符设备：这类设备以==字符单位==组织和交换数据<ul>
<li>是一种非结构化设备，字符设备有很多种，==如串口、触摸面板、打印机==等</li>
<li>字符设备的基本特征是==传输速率低且不可寻址==，当字符设备执行I/O操作时，==经常使用中断==</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><p>通常I/O设备由两部分组成，==机械部件==和==电子部件==（电子部分称为设备控制器或适配器）</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>8251 UART，通用异步收发器，包括了RS232、RS449、RS423、RS422和RS485等接口标准规范和总线标准规范，即UART是异步串行通信口的总称，规定了通信口的电气特性、传输速率、连接特性和接口的机械特性等内容</p>
<h4 id="可编程I-O"><a href="#可编程I-O" class="headerlink" title="可编程I/O"></a>可编程I/O</h4><p>在通信过程中选择控制寄存器或数据缓冲区的三种方法</p>
<ul>
<li><p>独立I/O端口</p>
</li>
<li><p>内存映射I / O</p>
</li>
<li><p>混合解决方案，混合模型包括内存映射的I/O数据缓冲区和用于控制寄存器的独立I/O端口</p>
</li>
</ul>
<p>Intel x86提供了in、out指令，大多数其他cpu使用内存映射I/O</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/e99b4953f0f4458884e6/?dl=1'></p>
<h5 id="独立I-O端口"><a href="#独立I-O端口" class="headerlink" title="独立I/O端口"></a>独立I/O端口</h5><p>优点：</p>
<ul>
<li>I/0独立编址，不占用内存空间</li>
<li>使用I/O指令，程序清晰，很容易看出是I/O操作还是存储器操作</li>
<li>译码电路比较简单(因为I/0端口的地址空间一般较小，所用地址线也就较少)</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能用专门的I/0指令，访问端口的方法少</li>
</ul>
<h5 id="内存映射I-O"><a href="#内存映射I-O" class="headerlink" title="内存映射I/O"></a>内存映射I/O</h5><p>优点：</p>
<ul>
<li>在内存映射I/O模式中，设备控制寄存器只是内存中的变量，可以像其他变量一样在C语言中寻址。因此，I/O设备驱动程序可以完全用C语言编写</li>
<li>在这种模式下，不需要特殊的保护机制来阻止用户进程执行I/O操作</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>目前大多数嵌入式处理器都支持内存缓存。缓存设备控制寄存器会导致灾难。为了防止这种情况，必须为硬件提供选择性禁用缓存的功能，这将增加嵌入式系统中硬件和软件的复杂性</p>
</li>
<li><p>如果只有一个地址空间，所有内存模块和所有I/O设备必须检查所有内存引用，以决定响应哪一个，这将严重影响系统性能</p>
</li>
</ul>
<h5 id="ARM-内存映射I-O"><a href="#ARM-内存映射I-O" class="headerlink" title="ARM 内存映射I/O"></a>ARM 内存映射I/O</h5><p>定义设备地址:    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEV1 EQU 0x1000</span><br></pre></td></tr></table></figure>
<p>读/写代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LDR r1,#DEV1 ; set up device adrs</span><br><span class="line"></span><br><span class="line">LDR r0,[r1] ; read DEV1</span><br><span class="line"></span><br><span class="line">LDR r0,#8 ; set up value to write</span><br><span class="line"></span><br><span class="line">STR r0,[r1] ; write value to device</span><br></pre></td></tr></table></figure>
<h3 id="忙等I-O"><a href="#忙等I-O" class="headerlink" title="忙等I/O"></a>忙等I/O</h3><p>最基本的方式：使用指令测试设备忙闲</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">current_char = mystring;</span><br><span class="line"><span class="keyword">while</span> (*current_char != ‘\<span class="number">0</span>’) &#123;</span><br><span class="line">	poke(OUT_CHAR,*current_char);</span><br><span class="line">	<span class="keyword">while</span> (peek(OUT_STATUS) != <span class="number">0</span>);</span><br><span class="line">		current_char++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将字符从输入设备复制到输出设备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">	<span class="comment">/* read */</span></span><br><span class="line">	<span class="keyword">while</span> (peek(IN_STATUS) == <span class="number">0</span>);</span><br><span class="line">	achar = (<span class="type">char</span>)peek(IN_DATA);</span><br><span class="line">	<span class="comment">/* write */</span></span><br><span class="line">	poke(OUT_DATA,achar);</span><br><span class="line">	poke(OUT_STATUS,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (peek(OUT_STATUS) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中断I-O"><a href="#中断I-O" class="headerlink" title="中断I/O"></a>中断I/O</h3><p>==忙/等IO是非常低效==的，==CPU在测试设备时不能做其他工作==，很难同时进行I/O</p>
<p>中断允许设备改变CPU中的控制流，调用子例程来处理设备</p>
<h4 id="中端接口"><a href="#中端接口" class="headerlink" title="中端接口"></a>中端接口</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/f0e8a66421c54361b6a0/?dl=1'></p>
<h4 id="中断行为"><a href="#中断行为" class="headerlink" title="中断行为"></a>中断行为</h4><ul>
<li><p>基于子程序调用机制</p>
</li>
<li><p>中断强制下一条指令是预定义地址的子程序调用</p>
</li>
</ul>
<h4 id="中断物理接口"><a href="#中断物理接口" class="headerlink" title="中断物理接口"></a>中断物理接口</h4><ul>
<li><p>CPU与设备之间通过CPU总线连接</p>
</li>
<li><p>CPU和设备握手</p>
</li>
<li><p>设备发出中断请求</p>
</li>
<li><p>CPU在能够处理中断时确认中断</p>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>字符I/O处理程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">input_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	achar = <span class="built_in">peek</span>(IN_DATA);</span><br><span class="line"></span><br><span class="line">	gotchar = TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">poke</span>(IN_STATUS,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中断驱动的主程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (gotchar) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">poke</span>(OUT_DATA,achar);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">poke</span>(OUT_STATUS,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			gotchar = FALSE;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	other processing....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用缓冲区的中断I/O</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/9fcd612038274693b88f/?dl=1'></p>
</blockquote>
<h3 id="优先级和向量"><a href="#优先级和向量" class="headerlink" title="优先级和向量"></a>优先级和向量</h3><p>有两种机制允许我们使中断更灵活具体</p>
<ul>
<li><p>优先级：决定哪个中断首先得到CPU</p>
</li>
<li><p>向量：决定每种类型的中断调用什么代码</p>
</li>
</ul>
<p>机制是正交的：大多数cpu都提供这两种机制</p>
<h4 id="优先级中断"><a href="#优先级中断" class="headerlink" title="优先级中断"></a>优先级中断</h4><p>==中断优先级==</p>
<ul>
<li>屏蔽：在挂起的中断完成之前，不会识别优先级低于当前优先级的中断</li>
<li>不可屏蔽中断(NMI)：最高优先级，从不被屏蔽（通常用于断电）</li>
</ul>
<h4 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h4><p>允许不同的设备由不同的代码处理：提高灵活性，定义服务于来自设备的请求的中断程序的能力，向量号作为存储在内存中的中断向量表的索引</p>
<p>==中断向量表==</p>
<p>中断向量获取：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/46a4e767e82b41a68d25/?dl=1'></p>
<h3 id="通用中断机制"><a href="#通用中断机制" class="headerlink" title="通用中断机制"></a>通用中断机制</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/a8c73183ff5a4312aedd/?dl=1'></p>
<h4 id="中断序列"><a href="#中断序列" class="headerlink" title="中断序列"></a>中断序列</h4><ul>
<li><p>CPU确认请求</p>
</li>
<li><p>设备发送向量</p>
</li>
<li><p>CPU调用中断处理程序</p>
</li>
<li><p>软件处理请求</p>
</li>
<li><p>CPU恢复前台程序状态</p>
</li>
</ul>
<h3 id="中断开销的来源"><a href="#中断开销的来源" class="headerlink" title="中断开销的来源"></a>中断开销的来源</h3><ul>
<li><p>中断处理程序执行时间</p>
</li>
<li><p>中断机制开销</p>
</li>
<li><p>寄存器保存/恢复</p>
</li>
<li><p>流水线相关的开销</p>
</li>
<li><p>缓存相关的开销</p>
</li>
</ul>
<h3 id="中断设计指南"><a href="#中断设计指南" class="headerlink" title="中断设计指南"></a>中断设计指南</h3><ul>
<li><p>首先，在布局中断映射之前，不要考虑为新的嵌入式系统编写任何代码，列出每个中断，并描述程序应该做什么</p>
</li>
<li><p>上述中断设计图是一份预算，预计在什么情况下中断需要花费的时间</p>
</li>
<li><p>粗略估计每个ISR的复杂度</p>
</li>
<li><p>ISR的基本原则是保持处理程序简短</p>
</li>
<li><p>当然，短是用时间来衡量的，而不是用代码大小来衡量的。避免循环。避免冗长复杂的指令(重复的动作，可怕的数学，等等)</p>
</li>
<li><p>在ISR中尽快重新启用中断。先做硬件关键和不可重入的事情，然后执行中断启用指令。给其他ISR机会去做他们的事情</p>
</li>
</ul>
<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>在嵌入式世界中，例程必须满足以下条件才能重入</p>
<ul>
<li>它以原子方式使用所有共享变量，除非将每个共享变量分配给函数的特定实例</li>
<li>它不调用不可重入的函数：调用函数继承了被调用函数的可重入问题</li>
<li>它不以非原子的方式使用硬件：如果处理一个设备需要多个I/O操作，就会出现重入问题</li>
</ul>
<h4 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h4><p>在计算机世界中，“原子的”是指不能被中断的操作</p>
<h4 id="保持代码可重入性"><a href="#保持代码可重入性" class="headerlink" title="保持代码可重入性"></a>保持代码可重入性</h4><ul>
<li><p>第一条经验法则是避免共享变量。全局变量是没完没了的调试问题和代码失败的根源。使用自动变量或动态分配内存。</p>
</li>
<li><p>最常见的方法是在不可重入代码期间禁用中断。</p>
</li>
<li><p>信号量</p>
</li>
</ul>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线</p>
<p>总线是:==（1）一组传送线路，（2）相关的通信协议==</p>
<h4 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h4><ul>
<li><p>总线协议决定设备如何通信</p>
</li>
<li><p>总线上的设备经历一系列的状态</p>
</li>
<li><p>协议由状态机指定，协议中的每个参与者都有一个状态机</p>
</li>
<li><p>可包含异步逻辑行为</p>
</li>
</ul>
<h4 id="总线复用"><a href="#总线复用" class="headerlink" title="总线复用"></a>总线复用</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/450d9f9424ec4e8bb1e7/?dl=1'></p>
<h4 id="系统总线配置"><a href="#系统总线配置" class="headerlink" title="系统总线配置"></a>系统总线配置</h4><p>多总线允许并行：一个总线连接慢速设备,另一个独立总线连接高速设备</p>
<p>桥连接两个总线</p>
<h2 id="lecture-6-1-嵌⼊式软件系统概述"><a href="#lecture-6-1-嵌⼊式软件系统概述" class="headerlink" title="lecture 6-1 - 嵌⼊式软件系统概述"></a>lecture 6-1 - 嵌⼊式软件系统概述</h2><h3 id="嵌入式软件的特点"><a href="#嵌入式软件的特点" class="headerlink" title="嵌入式软件的特点"></a>嵌入式软件的特点</h3><h4 id="与桌面软件的对比"><a href="#与桌面软件的对比" class="headerlink" title="与桌面软件的对比"></a>与桌面软件的对比</h4><ul>
<li>内存：有限，影响编程语言的选择以及开发工具的使用（比如编译器优化）</li>
<li>CPU处理能力：成本和功耗的考虑，ES不得不采用保守的设计方案，其中的CPU往往只是恰好满足要求。</li>
<li>操作系统：OS（Windows/Linux）、RTOS、专有OS或裸机</li>
<li>实时行为：实时系统不一定会运行得很快，但一定是可预测的—通常的术语叫做确定性；实时性的要求对于OS的选择和程序设计都有影响</li>
<li>开发流程：ES往往没有足够的资源进行软件开发。交叉开发对于工具的选择有很大影响；开发过程也不同，编辑/编译/调试的循环是一样的，但执行程序这一步却非常复杂，需要把代码转移到目标机上或者在某种环境下运行</li>
<li>执行流程：多数嵌入式设备从开机开始就会运行某个程序，该程序会一直运行到系统关机。这个程序可能存储在ROM，也可能是从非易失性存储器转移到RAM中执行</li>
<li>每一个嵌入式设备都是不同的：可能是技术层面的，不同的CPU架构、内存、外设、应用程序和操作系统也可能是商业运作层面的，比如手机开发、生产的商业模式就和核磁共振扫描仪完全不同</li>
<li>嵌入式软件开发工具</li>
<li>软件组件</li>
</ul>
<h3 id="软件-硬件的权衡"><a href="#软件-硬件的权衡" class="headerlink" title="软件/硬件的权衡"></a>软件/硬件的权衡</h3><ul>
<li><p>微处理器的选择</p>
<ul>
<li>可能影响软件效率</li>
</ul>
</li>
<li><p>内存大小和组合</p>
<ul>
<li>尽可能晚的决定存储器可能的确切数量和搭配（rom/ram的混用）</li>
<li>ROM/RAM互换性，调试时使用RAM替换大部分的ROM</li>
</ul>
</li>
<li><p>需认真考虑设计中包含哪些外设</p>
<ul>
<li>需要重点考虑硬件费用</li>
<li>有时可由软件替代[如定时器]</li>
</ul>
</li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul>
<li>在线仿真器ICE<ul>
<li>模拟CPU的功能，可以完全仿真芯片的行为</li>
<li>价格昂贵，难以普及，没有广泛使用</li>
</ul>
</li>
<li>监控调试器<ul>
<li>需要通信通道</li>
<li>因为占用系统资源的问题，在一些严格的场合下不适合使用</li>
</ul>
</li>
<li>片上调试<ul>
<li>价格便宜，易于实现，广泛使用</li>
<li>例如，JTAG是边界扫描测试的一个标准协议，SWD（Serial Wire Debug）仿真器</li>
</ul>
</li>
</ul>
<h3 id="自检"><a href="#自检" class="headerlink" title="自检"></a>自检</h3><ul>
<li>I / O电路<ul>
<li>“loop back”是有用的</li>
</ul>
</li>
<li>板载开关<ul>
<li>用于配置或模式选择</li>
</ul>
</li>
<li>状态显示<ul>
<li>可能是字符或只是LED</li>
<li>LED至少可以有3种状态:开、关、闪烁</li>
</ul>
</li>
</ul>
<h3 id="软件系统层次结构"><a href="#软件系统层次结构" class="headerlink" title="软件系统层次结构"></a>软件系统层次结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/3c336f1033174a33acfc/?dl=1'></p>
<h3 id="为何要为实时系统建立模型"><a href="#为何要为实时系统建立模型" class="headerlink" title="为何要为实时系统建立模型"></a>为何要为实时系统建立模型</h3><ul>
<li><p>辅助测试和完善最终系统</p>
</li>
<li><p>更重要的是，模型利用它所知的系统属性来描述整个系统，并能够被用于对系统特性的进一步研究</p>
</li>
<li><p>实时工程师使用程序模型来开发软件和硬件，以便能将整个实时系统全盘考虑</p>
</li>
<li><p>模型使得工程师能够预测程序的运行，从而满足系统的性能需求和功能需求</p>
</li>
</ul>
<h3 id="模型间的差异"><a href="#模型间的差异" class="headerlink" title="模型间的差异"></a>模型间的差异</h3><ul>
<li><p>一些模型易于编写，但调试不易</p>
</li>
<li><p>难于编写，但调试容易</p>
</li>
<li><p>一些模型使得程序运行得更快，但需要付出更多内存资源消耗的代价</p>
</li>
<li><p>模型准确性与鲁棒性</p>
</li>
</ul>
<h3 id="嵌入式系统的可视化程序模型"><a href="#嵌入式系统的可视化程序模型" class="headerlink" title="嵌入式系统的可视化程序模型"></a>嵌入式系统的可视化程序模型</h3><p>实时系统有两种基本的程序模型</p>
<ul>
<li>将实时应用视为单个执行线程</li>
<li>将实时应用视为多个执行线程</li>
</ul>
<p>取决于需要构建什么类型的系统</p>
<h4 id="单线程程序模型优缺点"><a href="#单线程程序模型优缺点" class="headerlink" title="单线程程序模型优缺点"></a>单线程程序模型优缺点</h4><p>优点</p>
<ul>
<li><p>编程和再编程非常快速简单</p>
</li>
<li><p>改变系统响应特性的同时，往模型上添加新功能插件也相当容易</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>在于应用领域的限制</p>
</li>
<li><p>难以做到安全地再编程</p>
</li>
<li><p>很难应用到不同行为或不同环境的运行系统中去</p>
</li>
</ul>
<h4 id="多线程程序模型的优缺点"><a href="#多线程程序模型的优缺点" class="headerlink" title="多线程程序模型的优缺点"></a>多线程程序模型的优缺点</h4><p>优点</p>
<ul>
<li><p>允许将系统工作划分为几个逻辑阶段，然后编写相互独立的程序来处理各自的工作</p>
</li>
<li><p>所有处理过程并行</p>
</li>
<li><p>如果有更高吞吐量的需求，工程师可以在任务中引入新的通信和协作模型</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li>可能引入资源竞争</li>
</ul>
<h2 id="lecture-6-2-嵌⼊式软件架构综述"><a href="#lecture-6-2-嵌⼊式软件架构综述" class="headerlink" title="lecture 6-2 - 嵌⼊式软件架构综述"></a>lecture 6-2 - 嵌⼊式软件架构综述</h2><h3 id="嵌入式软件架构"><a href="#嵌入式软件架构" class="headerlink" title="嵌入式软件架构"></a>嵌入式软件架构</h3><p>分为两部分：</p>
<ul>
<li>业务逻辑</li>
<li>实时依赖硬件的逻辑</li>
</ul>
<p>抽象层将所需操作的==高级请求==转换为操作所需的==低级命令==</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/4d34e021cb5d43bdb1db/?dl=1'></p>
<h3 id="嵌入式软件架构模式"><a href="#嵌入式软件架构模式" class="headerlink" title="嵌入式软件架构模式"></a>嵌入式软件架构模式</h3><p>对于基于微控制器的系统来说，最常用的模式包括：</p>
<ul>
<li>非结构化单体架构<ul>
<li>很容易构建，但很难维持规模和移植</li>
<li>与应用层的应用程序紧密耦合</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/a371990085834cb99111/?dl=1'></li>
</ul>
</li>
<li>分层架构：当今嵌入式应用程序中最常用的架构<ul>
<li>将应用程序的逻辑划分为若干独立的层，仅通过定义良好的抽象层进行交互</li>
<li>试图通过将应用程序分解为独立的层来改善非结构化单体架构的高耦合性</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/95ba4bd12a3242af9123/?dl=1'></li>
</ul>
</li>
<li><p>事件驱动架构：对于==实时嵌入式应用程序==和与==能耗相关的应用程序==非常有意义</p>
<ul>
<li>通常利用==中断==来立即响应事件</li>
<li>事件驱动的体系结构通常使用==消息队列==、==信号量==和==事件标志==来表示系统中发生了事件</li>
<li>优势：<ul>
<li>具有相对的可扩展性</li>
<li>软件模块通常具有高内聚性</li>
<li>具有低耦合性</li>
</ul>
</li>
<li>缺点：无论何时需要做任何事情，都有==额外的开销和复杂性==</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/12f22d429fe248c89c75/?dl=1'></li>
</ul>
</li>
<li><p>微服务架构：将应用程序构建为为业务领域开发的小型自治服务的集合</p>
<ul>
<li>微服务本质上是低耦合的，使得微服务易于维护和可测试，开发人员可以快速扩展或移植微服务</li>
<li>围绕系统的业务逻辑组织的。业务逻辑(有时称为业务功能)是系统行为的业务规则和用例</li>
<li>缺点：<ul>
<li>在架构上，增加设计的复杂性</li>
<li>其次，由于具有其他体系结构中可能不需要的通信特性，它们可能会增加额外的开销和内存需求</li>
<li>架构的分散性也意味着实时的、确定性的行为可能更具挑战性。实时和响应可能有额外的抖动</li>
<li>可能会增加开发时间和预算</li>
</ul>
</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/cbcef4937543488a9d9f/?dl=1'></li>
</ul>
</li>
</ul>
<h3 id="实时嵌入式软件常用的设计模式"><a href="#实时嵌入式软件常用的设计模式" class="headerlink" title="实时嵌入式软件常用的设计模式"></a>实时嵌入式软件常用的设计模式</h3><p>单核，多核，==发布和订阅==模型，RTOS模式，==处理中断==和低功耗设计</p>
<h3 id="管理外设数据"><a href="#管理外设数据" class="headerlink" title="管理外设数据"></a>管理外设数据</h3><p>主要的设计理念之一是==数据决定设计==。在设计嵌入式软件时，必须遵循数据</p>
<p>可以使用几种不同的设计机制，例如</p>
<ul>
<li>轮询</li>
<li>中断</li>
<li>直接存储器访问(DMA)</li>
</ul>
<p>这些设计机制中的每一种都有==几个设计模式==，可用于确保不会遇到数据丢失</p>
<h4 id="外设轮询"><a href="#外设轮询" class="headerlink" title="外设轮询"></a>外设轮询</h4><p>从外设收集数据的最直接的设计机制是==让应用程序定期轮询外设==，以查看是否有任何数据可供管理和处理</p>
<h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><ul>
<li>优先级 - 无，一切按顺序运行</li>
<li>响应时间 —— 所有任务的总和</li>
<li>变化的影响 —— 显著，修改任务的执行时间或添加任务会影响所有其他任务</li>
</ul>
<p>优点：</p>
<ul>
<li>简单，没有共享数据问题</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>浪费处理周期，在资源受限或低功耗系统中这些周期可能会显著增加</p>
</li>
<li><p>在处理外设时可能会有很多抖动和延迟</p>
</li>
</ul>
<h5 id="watchdog看门狗"><a href="#watchdog看门狗" class="headerlink" title="watchdog看门狗"></a>watchdog看门狗</h5><p>看门狗是一个定时器，要求程序每隔一段时间向其输出一个信号，如果超过了WDT的规定时间，就给MCU发送一个复位信号，使其复位，实 现嵌入式系统在无人状态下的连续工作</p>
<p>看门狗是用于检测单片机程序运行状态的芯片，作用是防止单片机收到干扰后跑飞，导致程序崩溃的情况出现，可以及时将单片机复位，使之 正常运行，工作原理是看门狗的一个接口与单片机的一个I/O控线引脚相连，系统运行后，开启看门狗定时器，如果定时器没有在限定时间内 复位，则表示单片机已经跑飞，此时定时器会将单片机复位</p>
<h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>类似于轮询，但只执行当前状态</p>
<p>每个状态决定下一个状态(非顺序执行)</p>
<ul>
<li><p>优先级 —— 每个状态决定下一个状态的优先级</p>
</li>
<li><p>响应时间——所有任务的总和</p>
</li>
<li><p>变化的影响——显著，修改任务执行时间或添加任务会影响所有其他任务</p>
</li>
<li><p>简单性——没有共享数据问题</p>
</li>
</ul>
<h4 id="中断设计模式"><a href="#中断设计模式" class="headerlink" title="中断设计模式"></a>中断设计模式</h4><p>中断应用程序的正常流程，以允许中断处理程序运行代码来处理系统中发生的事件</p>
<p>当设计ISR时，我们希望中断尽可能快地运行(以最小化中断)</p>
<ul>
<li>==避免内存分配操作==，如声明非静态变量、操作堆栈或使用动态内存</li>
<li>尽量==减少函数调用==，以避免时钟周期开销、不可重入函数或阻塞函数的问题</li>
</ul>
<p>前后台系统：ISR（中断服务处理）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/dbfffc11ced9444caa7f/?dl=1'></p>
<h5 id="带有中断的轮询"><a href="#带有中断的轮询" class="headerlink" title="带有中断的轮询"></a>带有中断的轮询</h5><ul>
<li><p>优先级-中断优先于主循环，中断的优先级</p>
</li>
<li><p>反应时间-所有任务的总和或中断执行时间</p>
</li>
<li><p>变更的影响-对中断服务例程的影响较小。与主循环的轮询相同。</p>
</li>
<li><p>共享数据——必须处理与中断服务例程共享的数据</p>
</li>
</ul>
<p>优点：</p>
<ul>
<li><p>不需要浪费CPU周期来检查数据是否准备好</p>
</li>
<li><p>获取数据的延迟是确定的</p>
</li>
<li><p>抖动被最小化</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>中断的设置可能比较复杂</p>
</li>
<li><p>必须小心不要使用频繁触发的中断</p>
</li>
<li><p>当使用中断来接收数据时，开发人员必须仔细管理他们在ISR中所做的工作。开发人员经常需要使用ISR来处理所需的即时操作，然后将处理和非紧急的工作卸载给应用程序，从而增加了软件设计的复杂性。</p>
</li>
</ul>
<h5 id="数据获取-存储相关的中断设计模式"><a href="#数据获取-存储相关的中断设计模式" class="headerlink" title="数据获取/存储相关的中断设计模式"></a>数据获取/存储相关的中断设计模式</h5><p>线性数据存储，乒乓缓冲/双缓冲，环形/循环缓冲区，带有信号量的循环缓冲区，带有事件标志的循环缓冲区，消息队列</p>
<ol>
<li>线性数据存储设计模式：中断服务程序可以直接访问的共享内存位置<ul>
<li>线性数据存储可能是危险的：<ul>
<li>线性数据存储是经常遇到竞态条件的地方</li>
<li>用于存储应用程序和ISR之间的数据的共享变量也需要声明为volatile，以防止编译器优化</li>
</ul>
</li>
<li>数据存储必须由==互斥锁==保护，以防止竞态条件</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/3fc3369100c6436e8fe1/?dl=1'></li>
</ul>
</li>
<li>乒乓缓冲区/双缓冲区设计模式<ul>
<li>旨在帮助缓解数据存储遇到的一些竞态条件问题</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/e32ad66538dc4503b977/?dl=1'></li>
</ul>
</li>
<li>环形缓冲区设计模式<ul>
<li>环形缓冲区，也被称为循环缓冲区或者环形队列，是一种数据结构类型，它在内存中形成一个环形的存储空间</li>
<li>环形缓冲区的特点是==其终点和起点是相连的==，形成一个环状结构。这种数据结构在处理流数据和实现数据缓存等场景中具有广泛的应用</li>
<li>在中断中接收到的实时数据可以从外设中移除并存储在循环缓冲区中。因此，中断可以尽可能快地运行，同时允许应用程序代码==自行处理循环缓冲区==。使用循环缓冲区有助于确保数据不丢失，中断速度快，合理地处理数据</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/bf04c35a90eb4563958e/?dl=1'></li>
</ul>
</li>
<li>带有通知的循环缓冲区设计模式<ul>
<li>应用程序需要轮询缓冲区以查看是否有新的可用数据<ul>
<li>信号量和事件标志</li>
</ul>
</li>
<li>在大多数实时操作系统中，使用事件标志比使用信号量更有效</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/b231765e87454be4afa4/?dl=1'></li>
</ul>
</li>
<li>消息队列设计模式<ul>
<li>类似于使用带有信号量的线性缓冲区</li>
<li>消息队列通常需要更多的RAM、ROM和处理能力</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/70308d5a15134b21847d/?dl=1'></li>
</ul>
</li>
</ol>
<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>DMA，全称Direct Memory Access，即直接存储器访问</p>
<p>无需CPU的交互情况下在RAM和外设之间以及内部传输数据</p>
<h5 id="DMA控制器将外设数据传输到循环缓冲区的设计模式"><a href="#DMA控制器将外设数据传输到循环缓冲区的设计模式" class="headerlink" title="DMA控制器将外设数据传输到循环缓冲区的设计模式"></a>DMA控制器将外设数据传输到循环缓冲区的设计模式</h5><p>DMA控制器可以显著提高外设和应用程序之间的数据吞吐量。此外，可以利用DMA控制器减轻CPU运行ISR来传输数据的负担，并最大限度地减少浪费的计算周期</p>
<h3 id="RTOS（实时操作系统）应用程序设计模式"><a href="#RTOS（实时操作系统）应用程序设计模式" class="headerlink" title="RTOS（实时操作系统）应用程序设计模式"></a>RTOS（实时操作系统）应用程序设计模式</h3><p>在RTOS应用程序中，通常有两种类型的同步</p>
<ul>
<li>资源同步：决定了对共享资源的访问是否安全</li>
<li>活动同步：决定执行是否已达到特定状态</li>
</ul>
<h4 id="资源同步"><a href="#资源同步" class="headerlink" title="资源同步"></a>资源同步</h4><p>确保需要访问资源(如内存位置)的多个任务或任务和中断以协调的方式进行，从而避免竞争条件和内存损坏。</p>
<p>可以通过三种方式处理资源同步</p>
<ol>
<li>中断锁定<ul>
<li>当系统任务禁用中断以在任务和中断之间提供资源同步时，就会发生中断锁定</li>
<li>中断锁定可能是有用的，但在实时嵌入式系统中可能会导致许多问题</li>
</ul>
</li>
<li>抢占锁定<ul>
<li>抢占锁可用于确保任务在执行临界区期间不间断，抢占锁在临界区期间临时禁用RTOS内核抢占调度程序</li>
<li>抢占锁是一种比中断锁更好的技术，因为关键的系统中断仍然允许运行；但是，更高优先级的任务在执行时可能会延迟。抢占锁还会给系统带来额外的延迟和抖动。还有一种可能性是，由于内核的抢占式调度器被禁用，高优先级任务的执行可能会延迟。</li>
</ul>
</li>
<li>互斥锁：保护共享资源的==最安全、最推荐的方法==之一是使用互斥锁<ul>
<li>互斥锁通过创建一个对象来保护临界区，该对象的状态可以被检查，以确定是否可以安全访问共享资源，其唯一目的是为共享资源提供互斥</li>
<li>互斥锁不会禁用中断，它不会禁用内核的抢占调度程序</li>
<li>保护共享资源的互斥锁的一个潜在问题是，开发人员需要知道它的存在!</li>
</ul>
</li>
</ol>
<h4 id="活动同步"><a href="#活动同步" class="headerlink" title="活动同步"></a>活动同步</h4><p>活动同步是关于协调任务执行的。</p>
<p>在使用==实时操作系统==时，可以使用许多活动同步模式来协调任务执行</p>
<ol>
<li>单向同步<ul>
<li>任务到任务：单向同步使用二值信号量或事件标志来同步任务</li>
<li>中断到任务：可以在中断和任务之间同步和协调任务执行，不同之处在于，在ISR给出信号量或事件标志之后，ISR将继续执行，直到完成为止<ul>
<li>单向同步也可以与计数信号量一起使用</li>
</ul>
</li>
</ul>
</li>
<li>双向同步：两个任务在它们之间的两个方向上进行协调</li>
<li>同步多个任务之广播设计模式<ul>
<li>允许多个任务阻塞，直到给定信号量、出现事件标志，甚至将消息放入消息队列</li>
<li>任务或ISR可以提供由多个任务使用的二值信号量广播。广播可能无法在所有实时操作系统中实现，必须检查RTOS是否支持<ul>
<li>如果不支持广播，则可以创建由任务或中断给出的多个信号量。从设计的角度来看，使用多个信号量并不优雅，从实现的角度来看也不高效，但有时在软件中就是这样。</li>
</ul>
</li>
</ul>
</li>
<li>发布和订阅模型<ul>
<li>在物联网领域广泛使用<ul>
<li>在许多情况下，物联网设备将启动电源，连接到云，然后订阅它想要接收的消息主题。该设备甚至还可以发布特定的主题</li>
</ul>
</li>
<li>ROS使用</li>
<li>会导致应用程序占用更大的内存</li>
</ul>
</li>
</ol>
<h4 id="IOT（物联网）"><a href="#IOT（物联网）" class="headerlink" title="IOT（物联网）"></a>IOT（物联网）</h4><p>打破了传感器任务和任何需要使用数据的任务之间的依赖关系</p>
<p>系统完全可扩展</p>
<ul>
<li>如果突然需要使用传感器数据进行故障处理，不必回头重新构建系统或添加另一个依赖项。相反，创建一个订阅传感器数据的故障任务。该任务将获得操作和检测故障所需的数据</li>
</ul>
<h3 id="低功耗应用程序设计模式"><a href="#低功耗应用程序设计模式" class="headerlink" title="低功耗应用程序设计模式"></a>低功耗应用程序设计模式</h3><p>主要模式是尽可能地保持设备关闭</p>
<ul>
<li>事件驱动中，事件之间没有实际工作要做时，应该将微控制器置于适当的低功耗状态，并关闭任何非必要的电子设备</li>
<li>除非发生唤醒事件，否则系统处于低功耗状态</li>
<li>实际工作完成后，系统恢复到低功耗状态</li>
</ul>
<p>建议：</p>
<p>使用内置tickless模式的RTOS，或者可以扩展系统tick以使微控制器休眠更长时间的RTOS</p>
<ul>
<li>例如，FreeRTOS有一个可以启用的tickless模式。开发人员可以添加自定义代码来管理低功耗状态。当系统进入睡眠状态时，系统节拍被自动缩放，因此发生的系统节拍更少!</li>
</ul>
<h3 id="多核架构"><a href="#多核架构" class="headerlink" title="多核架构"></a>多核架构</h3><ul>
<li>同构多核，对称多核处理具有相同处理器架构的两个核</li>
<li>异构多核架构，每个处理核心都有不同的底层架构<ul>
<li>例如， Cypress PSoC 64具有用于用户应用程序的Arm Cortex-M4和作为安全处理器的Arm Cortex-M0+。这两个核心也不必以相同的时钟速度运行。例如， Arm Cortex-M4的工作频率为150mhz，而Arm Cortex-M0+的工作频率为100mhz</li>
</ul>
</li>
</ul>
<h4 id="人工智能用例"><a href="#人工智能用例" class="headerlink" title="人工智能用例"></a>人工智能用例</h4><p>其理念是一个核心用于运行机器学习推理，而另一个核心用于实时控制</p>
<h4 id="实时控制用例"><a href="#实时控制用例" class="headerlink" title="实时控制用例"></a>实时控制用例</h4><p>多核微控制器系统中经常使用的另一个用例是让每个核心管理实时控制能力。</p>
<h4 id="安全解决方案用例"><a href="#安全解决方案用例" class="headerlink" title="安全解决方案用例"></a>安全解决方案用例</h4><p>另一个流行用例是用应用程序管理安全解决方案</p>
<ul>
<li>例如，开发人员可以使用内置在多核中的硬件隔离，将其中一个作为安全处理器，处理安全操作和信任根。另一个核心为正常应用空间。数据可以通过共享内存在内核之间共享，但内核之间只能通过处理器间通信(IPC)请求进行交互。</li>
</ul>
<h2 id="lecture-7-1-嵌⼊式系统建模"><a href="#lecture-7-1-嵌⼊式系统建模" class="headerlink" title="lecture 7-1 - 嵌⼊式系统建模"></a>lecture 7-1 - 嵌⼊式系统建模</h2><h3 id="建模、设计、分析"><a href="#建模、设计、分析" class="headerlink" title="建模、设计、分析"></a>建模、设计、分析</h3><ul>
<li><p>建模是通过模拟加深对系统理解的过程。</p>
<ul>
<li>模型是对系统的模拟，并反映系统的特性，模型指定了系统的功能。</li>
</ul>
</li>
<li><p>设计是创建系统的结构。指定系统如何完成其功能。</p>
</li>
<li><p>分析是通过剖析获得对系统更深⼊理解的过程。具体说明系统为什么能够完成其功能(或者⽆法完成模型认为其能完成的功能)</p>
</li>
</ul>
<h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>是对所研究的系统、过程或概念的一种表达形式</p>
<p>使用模型的目的是要给出系统的抽象视图，每个模型都表示一组对象以及这些对象之间的相互关系</p>
<h4 id="模型的基本特征"><a href="#模型的基本特征" class="headerlink" title="模型的基本特征"></a>模型的基本特征</h4><ul>
<li><p>简单</p>
</li>
<li><p>经得起理论检验</p>
</li>
<li><p>高表现力</p>
<ul>
<li>简洁的表示，可以提高生产率</li>
</ul>
</li>
<li><p>提供逻辑推理能力</p>
</li>
<li><p>可执行：仿真/验证</p>
</li>
<li><p>可综合：通常要求设计正交性</p>
</li>
<li><p>能够适应各种不同的任务</p>
</li>
<li><p>描述不存在歧义，易于理解易于修改</p>
</li>
</ul>
<h4 id="常见的系统建模技术"><a href="#常见的系统建模技术" class="headerlink" title="常见的系统建模技术"></a>常见的系统建模技术</h4><ol>
<li>面向状态的建模<ul>
<li>有限状态机Finite State Machines</li>
</ul>
</li>
<li>面向活动的建模<ul>
<li>数据流图/过程模型，把系统描绘成一组与数据或者执行的相关性有关的活动的集合</li>
</ul>
</li>
<li>面向结构的模型<ul>
<li>框图</li>
<li>着重强调系统的物理构成</li>
</ul>
</li>
<li>面向数据的模型<ul>
<li>实体-关系图</li>
</ul>
</li>
<li>异构模型<ul>
<li>综合前四种模型特征</li>
<li>表达复杂系统的多种不同视图</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/b2ba2f059b444d308a95/?dl=1'></p>
<h4 id="基于模型的设计"><a href="#基于模型的设计" class="headerlink" title="基于模型的设计"></a>基于模型的设计</h4><p>创建嵌入式系统各个部分的数学模型（物理世界，控制系统，软件环境，硬件平台，网络，传感器和执行器）</p>
<p>从模型构造实现：</p>
<ul>
<li>目标：构造自动化，就像编译器一样</li>
<li>实际上，只有部分是自动构造的</li>
</ul>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>周期性与事件驱动</p>
<ul>
<li>周期性的例子：流式应用、处理器……</li>
<li>事件驱动：反应式(由环境中的变化触发)</li>
</ul>
</li>
<li><p>实时</p>
<ul>
<li>硬实时、软实时</li>
</ul>
</li>
<li><p>控制、数据、通信</p>
</li>
<li><p>并行，地理距离</p>
<ul>
<li>高度并发与顺序执行；分布式系统</li>
</ul>
</li>
<li><p>确定性与非确定性</p>
<ul>
<li>可预测性的程度</li>
</ul>
</li>
</ul>
<h3 id="嵌入式系统模型的用途"><a href="#嵌入式系统模型的用途" class="headerlink" title="嵌入式系统模型的用途"></a>嵌入式系统模型的用途</h3><ul>
<li>通过使用现代建模软件工具，可以离线仿真的方式进行设计和执行初始验证</li>
<li>可以使用模型来作为所有==后续开发阶段的基础==</li>
<li><p>将==降低出错风险==，通过在整个开发过程中执行验证和确认测试来缩短开发周期</p>
</li>
<li><p>以系统模型为基础，可以==更快、更可靠==地进行设计评估和预测</p>
</li>
<li>这种迭代方法可以在性能和可靠性方面改进设计</li>
<li>由于模型的可重用性以及对物理原型的依赖的减少，==降低了资源成本==</li>
<li>通过使用代码自动生成技术，可以==减少开发错误和开销==</li>
</ul>
<h3 id="为何为嵌入式系统建模"><a href="#为何为嵌入式系统建模" class="headerlink" title="为何为嵌入式系统建模?"></a>为何为嵌入式系统建模?</h3><ul>
<li><p>一个良好的集成建模方法可以大大减少系统文档、设计、测试和实际实现之间的偏差。</p>
</li>
<li><p>对于某些嵌入式系统的问题，建模方法可以直接带来==额外的效率和准确性的提高==</p>
</li>
</ul>
<h3 id="软件建模"><a href="#软件建模" class="headerlink" title="软件建模"></a>软件建模</h3><p>通常使用某种形式的软件建模作为切入或制定应用程序的整体设计的最初方法</p>
<p>软件模型在格式、详细程度和功能方面有显著不同</p>
<ul>
<li>一些软件模型是行为的</li>
<li>有些只是直观地帮助理解和构建</li>
<li>另一些则更多地用作框架，以确保类似应用程序之间的一致性，或促进工程师团队之间的沟通。</li>
</ul>
<p>==面临的挑战==是，要知道哪种类型和级别的模型最适合当前的具体情况和问题</p>
<h3 id="建模语言"><a href="#建模语言" class="headerlink" title="建模语言"></a>建模语言</h3><p>建模语言有明确的定义和标准语法，用于表示结构和功能参与者及其随时间变化的主要关系</p>
<p>建模语言有多种形式：</p>
<ul>
<li><p>图形、文本</p>
</li>
<li><p>面向文档、仿真或执行</p>
</li>
<li><p>专注于体系架构层面内容、实现层面内容</p>
</li>
</ul>
<blockquote>
<p>C代码: 文本, 执行, 实现层面的语言</p>
<p>基于时间的仿真：图形、实现、仿真工具</p>
<p>状态图：图形化、架构和实现工具</p>
<p>数据流：图形化、架构和实现软件</p>
<p>V图承诺 ：通常用于描述一个嵌入式建模开发周期</p>
</blockquote>
<h3 id="何时为嵌入式系统建立模型"><a href="#何时为嵌入式系统建立模型" class="headerlink" title="何时为嵌入式系统建立模型"></a>何时为嵌入式系统建立模型</h3><ul>
<li><p>任务和安全关键型应用：特指故障可能导致巨额损失，对企业声誉造成伤害或严重损坏</p>
<ul>
<li>软件建模、软件工程最优方法和正式行业标准等都要结合起来，以促进和保障嵌入式系统的安全和可靠</li>
</ul>
</li>
<li><p>高度复杂的应用程序和系统</p>
<ul>
<li>现代汽车动力传动控制系统受益于建模技术，因为需要不断调整满足各种要求，包括：控制废气排放，日益严格的标准，更好的燃油经济性，满足客户的要求，提供卓越的性能和舒适度等</li>
<li>上述目标既相互关联又相互冲突</li>
</ul>
</li>
<li><p>大型开发团队</p>
<ul>
<li>庞大的开发团队面临几个关键问题的挑战：通信问题，地域分散和语言不同，工具差异</li>
<li>建模可以帮助解决上述一些问题：<ul>
<li>建模可以帮助嵌入式项目不同团队内明确的沟通，设计一个有用的、能够准确表示项目动态的系统模型，可以方便沟通</li>
<li>嵌入式模型提供了项目一致性的表达，而不是依赖于翻译书面文档</li>
<li>要求保持软件模型可以在工具之间共享</li>
</ul>
</li>
</ul>
</li>
<li><p>没有其他选择（当没有原型时）</p>
<ul>
<li>当嵌入式系统不存在 — 当设计的硬件尚未完成或芯片尚未准备好，这样的情形，建模、模拟、仿真和原型机设计都是非常有用的方法</li>
<li>尚未发布的芯片，因为项目大小或成本的关系，不能开发原型机，软件模型可以很有帮助</li>
</ul>
</li>
</ul>
<h3 id="缺陷检测的时间和成本"><a href="#缺陷检测的时间和成本" class="headerlink" title="缺陷检测的时间和成本"></a>缺陷检测的时间和成本</h3><ul>
<li><p>使用正确建模和仿真技术并不只是获得一个更好的设计，还可以节约成本以及更快的完成开发</p>
</li>
<li><p>建模结合软件工程最优方法将有助于解决大多数缺陷</p>
</li>
</ul>
<h2 id="lecture-7-2-有限状态机FSM"><a href="#lecture-7-2-有限状态机FSM" class="headerlink" title="lecture 7-2 - 有限状态机FSM"></a>lecture 7-2 - 有限状态机FSM</h2><h3 id="反应式系统"><a href="#反应式系统" class="headerlink" title="反应式系统"></a>反应式系统</h3><p>反应式(reactive)系统就是指能够持续地与环境进行交互，并且及时地进行响应</p>
<p>大多数实时系统都是反应式系统，如通信网络、看门狗和家庭应用（洗衣机、微波炉和洗碗机等）等</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>其特征是==事件驱动==，当系统接收到一个外部事件时，需要对事件进行处理，然后产生响应<ul>
<li>反应式系统可以定义为系统可能的输入/输出事件序列的集合、条件、动作和时序约束</li>
</ul>
</li>
<li>对反应式系统建模的主要模型包括有限状态机、行为有限状态机、协同设计有限状态机、UML状态图（UML StateCharts）、程序状态机和通信交互进程等</li>
</ul>
<h3 id="FSM定义"><a href="#FSM定义" class="headerlink" title="FSM定义"></a>FSM定义</h3><ul>
<li>有限状态机（finite-state machine，FSM）又称有限状态自动机（finite-state automaton，FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型</li>
<li>状态存储关于过去的信息，就是说：它反映从系统开始到现在时刻的输入变化。</li>
<li>转移指示状态变更，并且用必须满足确使转移发生的条件来描述它。</li>
<li>动作是在给定时刻要进行的活动的描述。有多种类型的动作：<ul>
<li>进入动作（entry action）：在进入状态时进行</li>
<li>退出动作（exit action）：在退出状态时进行</li>
<li>输入动作：依赖于当前状态和输入条件进行</li>
<li>转移动作：在进行特定转移时进行</li>
</ul>
</li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>有限状态机是在自动机理论和计算理论中研究的一类自动机。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议等研究。</p>
<h3 id="FSM应⽤实例"><a href="#FSM应⽤实例" class="headerlink" title="FSM应⽤实例"></a>FSM应⽤实例</h3><h4 id="汽车警报器"><a href="#汽车警报器" class="headerlink" title="汽车警报器"></a>汽车警报器</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/af2f5251145440d48c05/?dl=1'></p>
<h4 id="吃豆人"><a href="#吃豆人" class="headerlink" title="吃豆人"></a>吃豆人</h4><p>⻆⾊AI可以建模为⼀系列认知状态，环境事件可以迫使状态发⽣迁移</p>
<p>吃⾖⼈中的幽灵有四种⾏为:</p>
<ul>
<li>在迷宫中随机漫步</li>
<li>当吃⾖⼈在视线范围内追逐吃⾖⼈</li>
<li>当吃⾖⼈吃了⼀个能量球时，逃离吃⾖⼈</li>
<li>回到中央基地再⽣</li>
</ul>
<h4 id="Internet-Protocols-TCP"><a href="#Internet-Protocols-TCP" class="headerlink" title="Internet Protocols: TCP"></a>Internet Protocols: TCP</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/213087e90e034cc6a892/?dl=1'></p>
<h3 id="FSM特性"><a href="#FSM特性" class="headerlink" title="FSM特性"></a>FSM特性</h3><p>(next_states, output) = Φ(state, event)</p>
<p>有限状态机具有两个重要特性:</p>
<ul>
<li>确定性：如果对于每个状态，每个输入值最多可激活一个转移，则称这样的状态机具有确定性，这意味着Φ(S,E)是单一值</li>
<li>可接受性：如果对于每个状态，每个输入都有至少一个可能的转移，则称这样的状态机为可接受的，定义了每个可能的状态和输入值</li>
</ul>
<h3 id="Moore机和Mealy机"><a href="#Moore机和Mealy机" class="headerlink" title="Moore机和Mealy机"></a>Moore机和Mealy机</h3><p>状态模型是单线程的</p>
<ul>
<li>任何时候只有一个状态是有效的</li>
</ul>
<p>Moore状态模型：意味着输出完全由当前状态决定，与输入信号的当前值无关</p>
<ul>
<li>非反应性，输入对输出的影响要到下一个时钟周期才能反映出来</li>
<li>结构简单，状态数量大于等于对应的mealy机中的数量</li>
</ul>
<p>Mealy状态模型：意味着输出既依赖于当前状态，也与输入信号的当前值有关</p>
<ul>
<li>往往更加精简</li>
<li>即时对输入产生输出，即响应速度快</li>
</ul>
<p>可相互转换，mealy机也可转换成大致等效的Moore机，差别只是输出产生于下一个响应，而非当前响应</p>
<h3 id="等价-amp-优化"><a href="#等价-amp-优化" class="headerlink" title="等价&amp;优化"></a>等价&amp;优化</h3><p>对所有的输入具有相同输出的两个FSM被称为等价</p>
<p>等价不需要同构(相同形状)——也就是说，两个等价的FSM不需要有相同的图，甚至不需要有相同数量的状态!</p>
<p>==等价使优化成为可能==：优化一个FSM意味着缩减状态机的状态数目，同时保证状态机能实现同样功能</p>
<h3 id="非确定性FSM"><a href="#非确定性FSM" class="headerlink" title="非确定性FSM"></a>非确定性FSM</h3><ul>
<li>当下一个状态或输出有多个值时，FSM被称为非确定性的<ul>
<li>五元组中，转移关系表示状态和输入值映射到可能的（下一状态，输出值）对集，初始状态不是一个元素而是一个集合，可以有多个初始状态</li>
</ul>
</li>
<li>在嵌入式系统建模中的主要用途:<ul>
<li>环境建模：对于隐藏与环境如何运作无关的细节非常有用</li>
<li>机器人不确定的行为</li>
</ul>
</li>
</ul>
<h3 id="DFAs与-NFA"><a href="#DFAs与-NFA" class="headerlink" title="DFAs与 NFA"></a>DFAs与 NFA</h3><p>形式上，确定有限状态自动机（DFA, Deterministic Finite Automaton）和非确定有限状态自动机（NFA）是等价的（幂集构造）</p>
<p>在实践中，NFA通常更简洁</p>
<h3 id="常规FSM建模"><a href="#常规FSM建模" class="headerlink" title="常规FSM建模"></a>常规FSM建模</h3><p>问题：</p>
<ul>
<li>经常过度指定</li>
<li>由于缺乏组合潜力，可伸缩性较差</li>
<li>不支持并发</li>
</ul>
<p>简单的解决方案：在模型中引入层次结构</p>
<h3 id="状态图-层次FSM"><a href="#状态图-层次FSM" class="headerlink" title="状态图: 层次FSM"></a>状态图: 层次FSM</h3><ul>
<li>StateCharts语言由David Harel于1987年提出</li>
<li>支持层次结构模型及并发</li>
<li>状态图支持：<ul>
<li>将状态重复分解为AND/OR子状态</li>
<li>动作</li>
<li>活动</li>
<li>判定式</li>
<li>历史</li>
<li>同步(即时广播)通信机制</li>
</ul>
</li>
</ul>
<h3 id="层次FSM模型"><a href="#层次FSM模型" class="headerlink" title="层次FSM模型"></a>层次FSM模型</h3><ul>
<li><p>扩展有限状态机</p>
</li>
<li><p>层次结构:</p>
<ul>
<li>状态a“包含”一个FSM</li>
<li>处于a状态意味着FSM处于a状态</li>
<li>a的状态称为OR状态</li>
<li>用于对抢占和例外进行建模</li>
</ul>
</li>
<li><p>并发性:</p>
<ul>
<li>两个或两个以上FSM同时处于活动状态</li>
<li>状态称为AND状态</li>
</ul>
</li>
</ul>
<h3 id="层次化状态图"><a href="#层次化状态图" class="headerlink" title="层次化状态图"></a>层次化状态图</h3><ul>
<li><p>FSM将处于S的⼦状态之⼀</p>
</li>
<li><p>⽀持从/到⼦状态的转移</p>
<ul>
<li>初始状态(默认)</li>
<li>历史</li>
</ul>
</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/60a717335e5e4ca19570/?dl=1'></p>
<h4 id="默认状态机制"><a href="#默认状态机制" class="headerlink" title="默认状态机制"></a>默认状态机制</h4><p>指定超状态变为活跃时将要激活的特定⼦状态</p>
<ul>
<li>伪状态，不是⼀个状态</li>
</ul>
<h4 id="历史机制"><a href="#历史机制" class="headerlink" title="历史机制"></a>历史机制</h4><ul>
<li><p>采用这个机制，就可能回到超状态退出之前最后一个活跃子状态</p>
<ul>
<li>给定输入m, S返回到S离开之前的状态(可以是A、B、C、D或E)</li>
</ul>
</li>
<li><p>在第一次进入S时，应用默认机制</p>
</li>
<li><p>历史和默认机制可以组合使用</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/dcbabc19986b4dad88ce/?dl=1'></p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>与型超状态（AND-super-state）：无论什么时候包含状态S的系统在进入S状态时都将进入S的所有子状态中</p>
<ul>
<li>FSM处于超状态的所有(直接)子状态</li>
<li>与或型超状态不同，需要多个控制点</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/fc3423ec8c0642b29d46/?dl=1'></p>
<h4 id="进入和离开与型超状态"><a href="#进入和离开与型超状态" class="headerlink" title="进入和离开与型超状态"></a>进入和离开与型超状态</h4><p>进入与型超状态时所进入的子状态可以被单独定义，可以是历史、默认及显示转移的任意组合</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/e89698b257cd406098b3/?dl=1'></p>
<h3 id="StateCharts图中的状态"><a href="#StateCharts图中的状态" class="headerlink" title="StateCharts图中的状态"></a>StateCharts图中的状态</h3><ul>
<li>与型状态</li>
<li>或型状态</li>
<li>基本状态</li>
</ul>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul>
<li><p>鉴于嵌入式系统对时间进行建模的需求，StateCharts提供了定时器</p>
</li>
<li><p>进入包含定时器的状态一段时间后，超时（timeout）将会发生，且系统将离开这个指定状态</p>
</li>
<li><p>定时器可以被分层使用</p>
</li>
</ul>
<h4 id="应答机层次结构中使用定时器"><a href="#应答机层次结构中使用定时器" class="headerlink" title="应答机层次结构中使用定时器"></a>应答机层次结构中使用定时器</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/f85805b55fc142368129/?dl=1'></p>
<h3 id="StateCharts中的边的标号"><a href="#StateCharts中的边的标号" class="headerlink" title="StateCharts中的边的标号"></a>StateCharts中的边的标号</h3><ul>
<li>生成的输出可用边的标号来指定</li>
<li>在StateChart中标记转移的表达式的一般语法是“事件[条件]/动作”（event[condition]/action），其中<ul>
<li>event是指触发转移的事件</li>
<li>condition部分隐含了变量值的测试或对系统当前状态的测试</li>
<li>action部分描述FSM对状态转移的反应</li>
</ul>
</li>
<li>对于每个转移，事件、条件和动作都是可选的</li>
</ul>
<h4 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/c8980a0072da402e9173/?dl=1'></p>
<h3 id="StateCharts的优势"><a href="#StateCharts的优势" class="headerlink" title="StateCharts的优势"></a>StateCharts的优势</h3><ul>
<li><p>层次结构允许任意嵌套与型和或型超状态</p>
</li>
<li><p>StateMate的语义定义在足够详细的层次上</p>
</li>
<li><p>大量的商业仿真工具可用</p>
<ul>
<li>StateMate, StateFlow, BetterState，…</li>
</ul>
</li>
<li><p>可在后端将StateCharts转换为C或VHDL，从而支持软件或硬件实现</p>
</li>
</ul>
<h3 id="StateChart的不足"><a href="#StateChart的不足" class="headerlink" title="StateChart的不足"></a>StateChart的不足</h3><ul>
<li><p>生成的C程序可能效率低下</p>
</li>
<li><p>生成的硬件可能更糟</p>
</li>
<li><p>难以应用于分布式应用程序</p>
</li>
<li><p>没有结构化层次的描述</p>
</li>
</ul>
<h3 id="例子：自动饮料售卖机"><a href="#例子：自动饮料售卖机" class="headerlink" title="例子：自动饮料售卖机"></a>例子：自动饮料售卖机</h3><p>假设有一台自动饮料售卖机:</p>
<ul>
<li><p>开机后，机器等待投币</p>
</li>
<li><p>当投入一个25分硬币时，机器等待另一个25分硬币</p>
</li>
<li><p>当第二枚硬币存入时，机器进入等待状态</p>
</li>
<li><p>当使用者按下“可乐”键时，就会出现可乐</p>
</li>
<li><p>当使用者拿起瓶子时，机器再次进入等待状态</p>
</li>
<li><p>当用户按下“雪碧”或“健怡可乐”时，就会出现雪碧或健怡可乐</p>
</li>
<li><p>当使用者拿起瓶子时，机器再次进入等待状态</p>
</li>
</ul>
<h4 id="⾃动饮料售卖机-1-0"><a href="#⾃动饮料售卖机-1-0" class="headerlink" title="⾃动饮料售卖机 1.0"></a>⾃动饮料售卖机 1.0</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/b4f3c5f214ee4119b271/?dl=1'></p>
<h4 id="自动饮料售卖机V1-1"><a href="#自动饮料售卖机V1-1" class="headerlink" title="自动饮料售卖机V1.1"></a>自动饮料售卖机V1.1</h4><p>瓶子会在机器里卡住</p>
<ul>
<li>当瓶子卡住时，指示器会自动通知系统</li>
<li>当这种情况发生时，机器将不再接受任何钱币或释放任何饮料瓶，直到饮料瓶被清理干净</li>
<li>当被卡住的饮料瓶被清空时，机器将再次进入等待状态</li>
</ul>
<p>状态机需要修改</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/1b0aa447f97b49fb9612/?dl=1'></p>
<h3 id="层次FSM"><a href="#层次FSM" class="headerlink" title="层次FSM"></a>层次FSM</h3><p>层次结构允许</p>
<ul>
<li>合理的默认活动</li>
<li>在多个地方可以增强行为<ul>
<li>考虑被卡住的恢复行为</li>
</ul>
</li>
<li>所需的状态数量大幅减少</li>
<li>易于添加扩展状态语义<ul>
<li>增强状态和条件动作</li>
</ul>
</li>
</ul>
<p>如何在软件中进行有效的实现?</p>
<ul>
<li>层次FSM比FSM更复杂，成本更高</li>
<li>但是要在表现力与复杂性和可维护性之间进行权衡</li>
</ul>
<h2 id="Lecture-8-eos"><a href="#Lecture-8-eos" class="headerlink" title="Lecture 8 - eos"></a>Lecture 8 - eos</h2><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>一个实时系统是指计算的正确性不仅取决于程序的逻辑正确性，==也取决于结果产生的时间==，如果系统的时间约束条件得不到满足，将会发生系统出错。</p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li>确定性：如果一个系统始终会为某个已知输入产生相同的输出，则该系统是确定性的<ul>
<li>非确定性系统的输出具有随机变化特征</li>
</ul>
</li>
<li>截止时限：截止时限就是必须完成某项任务的有限时间窗口，指明计算何时必须结束</li>
</ul>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul>
<li>硬实时软件系统：有一组严格的截止时限，且错过一个截止时限就会认为系统失败<ul>
<li>飞机传感器，自动驾驶系统，航天器，行星探测器</li>
</ul>
</li>
<li>软实时软件系统：会试图满足截止时限要求，但如果错过了某个截止时限也不会认为系统失败。但是，在这样一个事件中，软实时系统可能会降低其服务质量以改进其响应能力<ul>
<li>音频和视频传输软件</li>
</ul>
</li>
<li>准实时软件系统：会将截止时限之后交付的信息/计算视为无效。与软实时系统一样，准实时系统在错过某个截止时限后不会认为系统失败，并且如果错过了某个截止时间，准实时系统可能会降低服务质量<ul>
<li>财务预测系统，机器人装配线</li>
</ul>
</li>
</ul>
<h3 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><p>嵌入式操作系统在智能系统发挥越来越大的作用</p>
<p>近年国内嵌入式操作系统市场规模整体保持稳定</p>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><ul>
<li>实时操作系统（Real-Time Operating System, RTOS）是支持构建实时系统的操作系统</li>
<li>许多嵌入式系统都是实时系统，因此，==用于该类的操作系统必须是实时操作系统==</li>
<li>实时计算机系统同时需要实时运行的操作系统和提供确定性执行的用户代码</li>
<li>非实时操作系统上的确定性用户代码和实时操作系统上的非确定性用户代码都不会产生实时性能</li>
</ul>
<h4 id="RTOS-and-GPOS（通用操作系统）"><a href="#RTOS-and-GPOS（通用操作系统）" class="headerlink" title="RTOS and GPOS（通用操作系统）"></a>RTOS and GPOS（通用操作系统）</h4><p>==相似的功能==</p>
<p>多任务级别，软件和硬件资源管理，为应用提供基本的OS服务，从软件应用抽象硬件</p>
<h5 id="RTOS从GPOS中分离出来的不同功能"><a href="#RTOS从GPOS中分离出来的不同功能" class="headerlink" title="RTOS从GPOS中分离出来的不同功能"></a>RTOS从GPOS中分离出来的不同功能</h5><ul>
<li><p>嵌入式应用上下文中具有更好的可靠性</p>
</li>
<li><p>满足应用需要的剪裁能力</p>
</li>
<li><p>更快的特性</p>
</li>
<li><p>减少内存需求</p>
</li>
<li><p>为实时嵌入式系统提供可剪裁的调度策略</p>
</li>
<li><p>支持无盘化嵌入式系统，允许从ROM或RAM上引导和运行</p>
</li>
<li><p>对不同硬件平台具有更好的可移植性</p>
</li>
</ul>
<h4 id="RTOS关键要求"><a href="#RTOS关键要求" class="headerlink" title="RTOS关键要求"></a>RTOS关键要求</h4><ul>
<li><p>操作系统的时间行为必须是可预测的</p>
<ul>
<li>任何调度策略都必须是确定性的</li>
<li>为了避免关键事件处理过程中的不可预测延迟，禁止中断的时间必须尽可能短</li>
</ul>
</li>
<li><p>操作系统必须管理线程和进程的调度</p>
</li>
<li><p>一些系统要求操作系统管理时间</p>
<ul>
<li>对时间精度的要求可能会有所不同</li>
<li>一些与环境的连接可用来获取精确的时间信息，如GPS或移动网络</li>
</ul>
</li>
<li><p>操作系统必须是快速的</p>
</li>
<li><p>可靠性</p>
</li>
<li><p>简洁紧凑</p>
</li>
</ul>
<h4 id="为何使用RTOS"><a href="#为何使用RTOS" class="headerlink" title="为何使用RTOS"></a>为何使用RTOS</h4><ul>
<li><p>可被复用的标准软件组件</p>
</li>
<li><p>灵活性</p>
</li>
<li><p>响应时间</p>
</li>
</ul>
<h4 id="RTOS类别"><a href="#RTOS类别" class="headerlink" title="RTOS类别"></a>RTOS类别</h4><ul>
<li><p>快速专有内核</p>
</li>
<li><p>对于标准操作系统的实时扩展</p>
<ul>
<li>RT_PREEMPT：Linux内核补丁，该内核补丁会将Linux的调度器修改为完全可抢占</li>
<li>Xenomai：一个符合POSIX标准的协同内核（或管理程序），是一个可以提供与Linux内核协作的实时内核，Linux内核会被视为实时内核调度器的空闲任务（最低优先级任务）</li>
<li>RTAI：一个协同内核（co-kernel）的替代解决方案</li>
</ul>
</li>
</ul>
<h3 id="对于标准操作系统的实时扩展"><a href="#对于标准操作系统的实时扩展" class="headerlink" title="对于标准操作系统的实时扩展"></a>对于标准操作系统的实时扩展</h3><p>优点：</p>
<ul>
<li><p>可配备标准操作系统的API，具有GUI、文件系统等</p>
</li>
<li><p>标准OS的增强功能也可很快速地应用在嵌入式领域</p>
</li>
<li><p>非实时进程不会影响实时进程</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>设备驱动程序存在一些问题，为避免冲突，有必要将设备划分为由实时进程处理的和由标准OS处理的两大类型</p>
</li>
<li><p>实时进程不能使用标准OS的服务，因此，诸如文件系统访问、GUI等所有优秀特性对于实时进程一般是不可用的</p>
</li>
</ul>
<h3 id="最流行的嵌入式操作系统"><a href="#最流行的嵌入式操作系统" class="headerlink" title="最流行的嵌入式操作系统"></a>最流行的嵌入式操作系统</h3><p>Embedded Linux，FreeRTOS，Ubuntu</p>
<h3 id="国产嵌入式操作系统"><a href="#国产嵌入式操作系统" class="headerlink" title="国产嵌入式操作系统"></a>国产嵌入式操作系统</h3><ul>
<li>HUAWEI Lite OS鸿蒙操作系统</li>
<li>“道系统”操作系统DeltaOS</li>
<li>SylixOS实时操作系统</li>
</ul>
<h3 id="物联网操作系统"><a href="#物联网操作系统" class="headerlink" title="物联网操作系统"></a>物联网操作系统</h3><p>物联网(IoT)源于大量廉价、小巧、节能的通信设备(或物)</p>
<p>从硬件上看，物联网是由异构硬件组成的</p>
<h4 id="物联网操作系统的要求-内存-异构硬件"><a href="#物联网操作系统的要求-内存-异构硬件" class="headerlink" title="物联网操作系统的要求-内存/异构硬件"></a>物联网操作系统的要求-内存/异构硬件</h4><ul>
<li>内存占用小：正确的权衡性能，方便的API，操作系统内存占用小</li>
<li>支持异构硬件：可以配备各种各样的通信技术</li>
</ul>
<h4 id="物联网操作系统的要求-网络连接-节能"><a href="#物联网操作系统的要求-网络连接-节能" class="headerlink" title="物联网操作系统的要求-网络连接/节能"></a>物联网操作系统的要求-网络连接/节能</h4><ul>
<li>网络连接：物联网中使用的通信技术不仅包括各种各样的低功耗无线电技术，还包括各种有线技术</li>
<li>节能：许多物联网设备使用电池或其他有限的能源，为上层提供节省能源的方案，尽量利用这些功能本身</li>
</ul>
<h4 id="物联网操作系统的要求-实时"><a href="#物联网操作系统的要求-实时" class="headerlink" title="物联网操作系统的要求-实时"></a>物联网操作系统的要求-实时</h4><ul>
<li>实时功能：物联网通用操作系统的另一个要求是RTOS</li>
</ul>
<h4 id="物联网操作系统的要求-安全"><a href="#物联网操作系统的要求-安全" class="headerlink" title="物联网操作系统的要求-安全"></a>物联网操作系统的要求-安全</h4><p>需求(和挑战)是提供必要的机制(密码库和安全协议)，同时保持灵活性和可用性</p>
<p>挑战还包括物联网架构中各个部分的数据完整性、身份验证和访问控制</p>
<h3 id="调度模型"><a href="#调度模型" class="headerlink" title="调度模型"></a>调度模型</h3><p>两种调度器</p>
<ul>
<li>抢占式调度器</li>
<li>非抢占(或合作)调度器</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存是以静态还是动态的方式分配是一个重要的问题</p>
<p>动态内存分配需要在运行时处理内存不足等情况，这可能很难处理</p>
<p>基于堆的malloc实现通常会导致内存碎片，从而导致系统更快地耗尽内存</p>
<h3 id="网络缓存管理"><a href="#网络缓存管理" class="headerlink" title="网络缓存管理"></a>网络缓存管理</h3><p>两种可能的解决方案：</p>
<ul>
<li>复制内存(memcpy())</li>
<li>在几个层之间传递指针</li>
</ul>
<h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p>物联网操作系统领域的典型编程模型可分为：</p>
<ul>
<li>事件驱动系统</li>
<li>多线程系统</li>
</ul>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>对于一个操作系统的编程语言，主要的选择有：</p>
<ul>
<li>通常是ANSI C或C++</li>
<li>特定于操作系统的语言</li>
</ul>
<h3 id="驱动模型和硬件抽象层"><a href="#驱动模型和硬件抽象层" class="headerlink" title="驱动模型和硬件抽象层"></a>驱动模型和硬件抽象层</h3><p>灵活、合理方便的驱动接口对于物联网操作系统至关重要</p>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p>编程语言的选择也预先决定了可能使用的工具，包括用于调试的工具，完善的工具链通常包括相应的调试工具</p>
<p>一个常见的辅助工具是使用printf()和类似的工具在串行接口上进行简单的调试，例如USART</p>
<h3 id="特征集"><a href="#特征集" class="headerlink" title="特征集"></a>特征集</h3><p>操作系统可以分为内核和更高级别的功能</p>
<p>除了网络协议之外，在低端物联网设备的操作系统中，更高层的特性还包括空中更新OTA、动态加载和链接，或用于轻量级加密和解密的库</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>处理与硬件相关的测试部分(如设备驱动程序的测试)的一种广泛使用的方法是使用硬件仿真工具，如MSPSim或Emul8</p>
<h3 id="与物联网相关的操作系统分类"><a href="#与物联网相关的操作系统分类" class="headerlink" title="与物联网相关的操作系统分类"></a>与物联网相关的操作系统分类</h3><ul>
<li><p>事件驱动的操作系统</p>
<ul>
<li>最初针对无线传感器网络领域开发的操作系统最常见的方法</li>
<li>关键思想是，系统上的所有处理都是由(外部)事件触发的，通常由中断发出信号</li>
<li>虽然这种方法在内存消耗和低复杂度方面是有效的，但它对程序员施加了一些重要的约束</li>
</ul>
</li>
<li><p>多线程操作系统</p>
<ul>
<li>通常会引入一些内存开销，这是由于堆栈预留空间造成的，而运行时开销则是由于上下文切换造成的</li>
</ul>
</li>
<li><p>纯RTOS</p>
<ul>
<li>主要关注实现实时保证的目标，正式的验证、认证和标准化通常是至关重要的</li>
<li>为了允许模型检查和形式化验证，会对开发人员施加严格的约束</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/5a97971ea97c460fb974/?dl=1'></p>
<h2 id="Lecture-8-2-实时调度"><a href="#Lecture-8-2-实时调度" class="headerlink" title="Lecture 8-2 - 实时调度"></a>Lecture 8-2 - 实时调度</h2><h3 id="实时系统所需的调度策略"><a href="#实时系统所需的调度策略" class="headerlink" title="实时系统所需的调度策略"></a>实时系统所需的调度策略</h3><p>是一个任务集合，需要调度策略</p>
<ul>
<li>优先级排序约束</li>
<li>时间约束：截止时限？任务可能被要求在不早于某一特定时间执行？任务可能相互依赖，也可能相互合作形成一个应用程序？可能不相关，只是共享处理器资源？</li>
</ul>
<h3 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h3><p>面临并发程序或一组程序要执行时，调度程序决定接下来执行哪个任务</p>
<ul>
<li>多处理器调度程序<ul>
<li>决定下一步执行哪个任务</li>
<li>由哪个处理器来执行，即处理器分配</li>
</ul>
</li>
<li>调度决策是执行任务的决策<ul>
<li>分配：应该由哪个处理器执行任务</li>
<li>排序：每个处理器按什么顺序执行相应的任务</li>
<li>定时：每一项任务什么时候执行</li>
</ul>
</li>
</ul>
<h3 id="调度程序分类-根据决策制定的时间"><a href="#调度程序分类-根据决策制定的时间" class="headerlink" title="调度程序分类 - 根据决策制定的时间"></a>调度程序分类 - 根据决策制定的时间</h3><ul>
<li>完全静态调度程序：在系统设计时制定三项决策<ul>
<li>明确规范</li>
<li>通常不需要信号和互斥锁</li>
<li>可通过定时来实现互斥和优先序约束</li>
<li>在大多数现代微处理器上难以实现，因为执行时间难以准确预测，而且通常具有数据依赖性</li>
</ul>
</li>
<li>静态顺序调度程序/离线调度程序：在设计时完成任务的分配和排序，但直到任务运行时才确定每个任务的物理执行时间<ul>
<li>可能受一些因素影响，比如是否获取互斥锁，是否满足优先序约束</li>
<li>不会根据一个信号或互斥锁的状态改变任务的顺序</li>
</ul>
</li>
<li>在线调度程序<ul>
<li>静态分配调度程序：在设计时制定任务的分配，其他决策在任务运行时制定</li>
<li>完全动态调度程序：在任务运行时制定所有的决策</li>
</ul>
</li>
</ul>
<h3 id="任务模型"><a href="#任务模型" class="headerlink" title="任务模型"></a>任务模型</h3><p>调度程序可能做出很多有关任务的假设，这样的假设集称为调度程序的任务模型</p>
<ul>
<li><p>假设调度开始之前知道所有要执行的任务</p>
</li>
<li><p>支持任务的到达</p>
</li>
<li><p>支持任务反复执行，可能是无休止的，也可能是周期性的</p>
</li>
<li><p>任务是突发性的，重复出现但时间不规律，任务的两次执行时间间隔有一个下限</p>
</li>
<li><p>优先序约束：如果执行 <em>i</em> 必须优先于 <em>j</em> ，可以写成 <em>i&lt;j</em></p>
</li>
<li><p>任务执行可以有一些先决条件才开始或恢复执行</p>
<ul>
<li>得到互斥锁</li>
</ul>
</li>
</ul>
<h3 id="任务的周期"><a href="#任务的周期" class="headerlink" title="任务的周期"></a>任务的周期</h3><p>作业（job）：一个任务的每次执行被称为一个作业</p>
<p>周期任务：每隔 $ T_{i}$个时间单元释放一次的任务$ τ_{i}$ 被称为周期任务，$ T_{i}$被称为他们的周期</p>
<p>偶发任务：如果连续释放任务$ τ_{i}$ 的间隔长度有一个下界，该任务就被称为是偶发任务</p>
<ul>
<li>在实际应用中，偶发任务经常被当作周期任务进行处理，其周期为相邻任务实例到达时刻的最小时间时隔</li>
</ul>
<p>非周期任务：既不是周期的也不是偶发的任务</p>
<p>超周期：令<em>τ</em>是一个周期或偶发的任务系统，该系统的超周期被定义为每个独立任务周期的最小公倍数</p>
<h4 id="与任务执行相关的时间"><a href="#与任务执行相关的时间" class="headerlink" title="与任务执行相关的时间"></a>与任务执行相关的时间</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/50c4ecabdb4f4001a27f/?dl=1'></p>
<h3 id="时限约束"><a href="#时限约束" class="headerlink" title="时限约束"></a>时限约束</h3><p>如果进程没有在截止时限前完成会发生什么?</p>
<ul>
<li>硬截止时限：如果错过，系统将失败<ul>
<li>具有硬时限的调度称为硬实时调度</li>
</ul>
</li>
<li>软截止时限：反应不需要严格执行的设计决策，最好满足时限要求，但是错过了也不算错误<ul>
<li>软实时调度</li>
<li>也许会试图采取一些补偿性的措施，例如使用近似数据或者切换到特殊安全模式</li>
<li>简单的措施避免错误数据的扩散，例如电话中插入一段寂静，或者干脆置之不理</li>
</ul>
</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>假设每个任务都有优先级号，调度程序总是执行优先级最高的任务</p>
<ul>
<li>通常用最小的优先级号表示</li>
<li>固定优先级：任务整个执行过程中其优先级保持不变</li>
<li>动态优先级：在执行过程中任务的优先级是可变的</li>
</ul>
<h4 id="非抢占式调度与抢占式调度程序"><a href="#非抢占式调度与抢占式调度程序" class="headerlink" title="非抢占式调度与抢占式调度程序"></a>非抢占式调度与抢占式调度程序</h4><ul>
<li>非抢占式优先级调度程序：通过优先级决定当前任务完成之后执行哪个任务，不中断一个正在执行的任务而去执行另外一个</li>
<li>抢占式优先级调度程序<ul>
<li>假设：（1）所有任务都有优先级静态分配(在任务的持续时间内是常量)或者动态分配(可以变化)；（2）内核跟踪哪些任务是“激活的”</li>
<li>抢占式调度:<ul>
<li>在任何时刻，支持任务的到达，执行最高优先级的被激活任务</li>
<li>当任何任务改变优先级或激活状态时，内核可以调度一个新任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="调度程序的度量"><a href="#调度程序的度量" class="headerlink" title="调度程序的度量"></a>调度程序的度量</h3><p>可行调度，CPU利用率，调度开销：制定调度决策所需的时间，延迟，总完成时间</p>
<h3 id="可行调度"><a href="#可行调度" class="headerlink" title="可行调度"></a>可行调度</h3><ul>
<li>调度策略的选择取决于应用程序的目标</li>
<li><p>最简单的目标就是所有的任务执行都符合他们的时限</p>
<ul>
<li>$ f_{i}$ ≤ $ d_{i}$ ，满足以上条件的调度称为可行调度</li>
</ul>
</li>
<li><p>对于具有可行调度的每个任务集（符合任务模型）都产生可行调度的调度程序称为可行性最优</p>
</li>
</ul>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><ul>
<li><p>指处理器用于执行任务时间（对闲置时间）的百分比</p>
</li>
<li><p>适合周期性执行的任务</p>
</li>
<li><p>每当处理器的使用率小于或等于100%时都能实现可行调度的调度算法无疑是可行性最优的</p>
</li>
<li><p>通常假设没有调度开销：</p>
<ul>
<li>U = (CPU time for useful work)/ (total available CPU time)</li>
</ul>
</li>
</ul>
<h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><ul>
<li><p>对于任务集<em>T</em>，最大延迟定义为：</p>
<ul>
<li>$ L_{max} = \underset{i \in T}{max}(f_{i}-d_{i})$</li>
</ul>
</li>
<li><p>对于一个可行调度，值为0或负数</p>
</li>
<li><p>也可用于比较非可行调度，对于软实时程序，可以容许最大延迟值为正数，只要不是太大</p>
</li>
</ul>
<h3 id="总完成时间-总时程"><a href="#总完成时间-总时程" class="headerlink" title="总完成时间/总时程"></a>总完成时间/总时程</h3><p>$ M = \underset{i \in T}{max}f_{i}-\underset{i \in T}{min}r_{i}$</p>
<p>性能指标，而非实时要求</p>
<h3 id="嵌入式调度与通用调度"><a href="#嵌入式调度与通用调度" class="headerlink" title="嵌入式调度与通用调度"></a>嵌入式调度与通用调度</h3><p>通用调度试图避免使进程无法访问CPU</p>
<ul>
<li>公平性=对CPU的访问</li>
</ul>
<p>嵌入式系统必须满足截止期限</p>
<ul>
<li>低优先级的进程可能很长时间不会运行</li>
</ul>
<h3 id="调度程序何时被调用"><a href="#调度程序何时被调用" class="headerlink" title="调度程序何时被调用"></a>调度程序何时被调用</h3><ul>
<li>非抢占式调度程序<ul>
<li>任务完成时被调用</li>
</ul>
</li>
<li>抢占式调度程序<ul>
<li>在计时器中断时</li>
<li>在I/O中断时</li>
<li>操作系统服务被调用</li>
<li>任务试图获得互斥锁</li>
<li>任务测试信号</li>
</ul>
</li>
</ul>
<h2 id="lecture-8-3-实时调度-调度异常"><a href="#lecture-8-3-实时调度-调度异常" class="headerlink" title="lecture 8-3 - 实时调度 - 调度异常"></a>lecture 8-3 - 实时调度 - 调度异常</h2><h3 id="调度异常"><a href="#调度异常" class="headerlink" title="调度异常"></a>调度异常</h3><ol>
<li>互斥<ul>
<li>优先级反转：互斥的危险<ul>
<li>当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。</li>
</ul>
</li>
<li>优先级继承<ul>
<li>优先级继承解决了优先级反转</li>
<li><strong>优先级继承</strong>是当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则==将任务C的优先级提升到自身的优先级==，任务C释放资源S后，==再恢复任务C的原优先级==。这种方法只在占有资源的低优先级任务阻塞了高优先级任务时才动态的改变任务的优先级，如果过程较复杂，则需要进行判断。</li>
</ul>
</li>
<li>优先级天花板</li>
</ul>
</li>
<li>多处理器调度<ul>
<li>Richard异常</li>
</ul>
</li>
</ol>
<h3 id="考虑互斥"><a href="#考虑互斥" class="headerlink" title="考虑互斥"></a>考虑互斥</h3><p>当线程访问共享资源时，它们需要使用互斥来确保数据的完整性</p>
<p>互斥也会使调度复杂化</p>
<h3 id="PIP"><a href="#PIP" class="headerlink" title="PIP"></a>PIP</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li>作业是根据其动态优先级调度的，具有相同优先级的作业以FCFS规则执行 </li>
<li>当作业 $ J_{i}$试图进入临界区，而资源被较低优先级的作业独占使用时，作业$ J_{i}$被阻塞，否则就进入临界区</li>
<li>当作业$J_{i}$被阻塞时，它将其动态优先级传递给持有该信号量的作业$ J_{k}$。$ J_{k}$恢复并以$ P_{k}$ = $ P_{i}$的优先级执行其临界区的其余部分(它继承被它阻塞的所有作业的最高优先级的优先级)</li>
<li>当$ J_{k}$退出临界区时，它释放该信号量，并唤醒阻塞在该信号量上的最高优先级作业。如果没有其他作业被$ J_{k}$阻塞，则将$ P_{k}$设置为其名义优先级$P_{k}$，否则将其设置为$ J_{k}$阻塞的作业的最高优先级</li>
<li>优先级继承是可传递的，即如果1被2阻塞，2被3阻塞，则3通过2继承1的优先级</li>
</ol>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>低优先级的任务⾸先启动并获取锁a，然后被⾼优先级的任务抢占，⾼优先级的任务获取锁b，运⾏，在尝试获取锁a时被阻塞。然后低优先级的任务尝试获取锁b时被阻塞，不可能再执⾏下去</p>
<h3 id="优先级上限协议"><a href="#优先级上限协议" class="headerlink" title="优先级上限协议"></a>优先级上限协议</h3><ul>
<li>每个锁或信号量都被分配了一个优先级上限，该上限等于可以锁定它的最高优先级任务的优先级</li>
<li>只有当任务<em>T</em>的优先级严格高于其他任务当前持有的所有锁的优先级上限时，任务<em>T</em>才能获得锁</li>
<li>==这可以防止一些死锁的发生==</li>
<li>有一些扩展支持动态优先级和锁的动态创建</li>
</ul>
<h4 id="OCPP-amp-ICPP"><a href="#OCPP-amp-ICPP" class="headerlink" title="OCPP &amp; ICPP"></a>OCPP &amp; ICPP</h4><p>原始优先级上限协议(OCPP)：在OCPP中，当更高优先级的任务 <em>Y</em> 试图获取任务 <em>X</em> 锁定的资源时，任务 <em>X</em> 的优先级会被提升到资源的优先级上限，确保任务 <em>X</em> 尽快完成其临界区，以解锁资源；只有当一个任务的动态优先级高于其他任务锁定的所有资源的优先级上限时，才允许该任务锁定资源，否则，任务将阻塞，等待资源</p>
<p>立即优先级上限协议(ICPP)：在ICPP中，当一个任务锁定一个资源时，它的优先级立即被提升为资源的优先级上限，因此任何可能锁定资源的任务都无法被调度</p>
<ul>
<li>从调度的角度来看，这两种上限方案的最坏情况是相同的。然而，也有一些不同之处<ul>
<li>ICPP比OCPP更容易实现，因为不需要监视阻塞关系</li>
<li>ICPP导致更少的上下文切换，因为阻塞是在首次执行之前进行的</li>
<li>ICPP需要更多的优先级传递，因为这发生在所有资源使用中</li>
<li>OCPP仅在实际发生阻塞时才更改优先级</li>
</ul>
</li>
</ul>
<h3 id="脆弱性"><a href="#脆弱性" class="headerlink" title="脆弱性"></a>脆弱性</h3><p>一般来说，所有线程调度算法都是脆弱的：微小的更改可能会产生意想不到的严重后果</p>
<ul>
<li>定理(Richard Graham, 1976)：如果一个具有固定优先级、执行时间和优先级约束的任务集在固定数量的处理器上按照优先级进行调度，那么增加处理器数量、减少执行时间或削弱优先序约束可能增加调度时长</li>
</ul>
<h3 id="Richard异常"><a href="#Richard异常" class="headerlink" title="Richard异常"></a>Richard异常</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/468116431fa740a6a892/?dl=1'></p>
<h4 id="增加处理器数量"><a href="#增加处理器数量" class="headerlink" title="增加处理器数量"></a>增加处理器数量</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/b48fce7c832e484682e6/?dl=1'></p>
<h4 id="贪心调度"><a href="#贪心调度" class="headerlink" title="贪心调度"></a>贪心调度</h4><p>基于优先级的调度是“贪⼼的”。对于本例，更智能的调度程序可以推迟调度5、6或7，使处理器空闲⼀个时间单元</p>
<ul>
<li>贪心调度可能是唯一可行的选项<ul>
<li>如果任务只有在其前序任务完成后才“到达”(调度器才获知)，那么贪⼼调度可能是唯⼀可⾏的选项</li>
</ul>
</li>
</ul>
<h4 id="减少计算时间"><a href="#减少计算时间" class="headerlink" title="减少计算时间"></a>减少计算时间</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/e9e7dc818d1344a783c4/?dl=1'></p>
<h4 id="弱化优先序约束"><a href="#弱化优先序约束" class="headerlink" title="弱化优先序约束"></a>弱化优先序约束</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/9ff6a70bacb749ada2d6/?dl=1'></p>
<h2 id="Lecture-9-1-实时内核-任务管理"><a href="#Lecture-9-1-实时内核-任务管理" class="headerlink" title="Lecture 9-1 - 实时内核-任务管理"></a>Lecture 9-1 - 实时内核-任务管理</h2><h3 id="µC-OS-II"><a href="#µC-OS-II" class="headerlink" title="µC/OS-II"></a>µC/OS-II</h3><p>是一个可移植的、可固化的、可扩展的、抢占式的、实时确定性的多任务内核，适用于微处理器、微控制器和DSP</p>
<h4 id="面向安全性至关重要的市场的可靠性"><a href="#面向安全性至关重要的市场的可靠性" class="headerlink" title="面向安全性至关重要的市场的可靠性"></a>面向安全性至关重要的市场的可靠性</h4><p>为了证明软件系统的可靠性和安全性，软件认证是至关重要的。μC/OS-II目前在大量高级别的安全关键设备中实现</p>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><ul>
<li>航空电子设备——用于火星好奇号漫游者</li>
<li>医疗设备/器械</li>
<li>数据通信设备</li>
<li>白色家电(电器)</li>
<li>移动电话，pda, MID</li>
<li>工业控制</li>
<li>消费电子产品</li>
<li>汽车</li>
</ul>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/6ba0043f929c4717840e/?dl=1'></p>
<h4 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h4><ul>
<li><p>μC/OS-II最多可管理64个任务</p>
</li>
<li><p>μC/OS-II保留了四个最高优先级的任务和四个最低优先级的任务作为系统任务</p>
</li>
<li><p>μC/OS-II实际使用的优先级只有两个：OSTaskCreate和OS_LOWEST_PRIO-1(参见OS_CFG.H)</p>
</li>
<li><p>留给多达56个应用程序任务</p>
</li>
<li><p>优先级越低，任务优先级越高</p>
</li>
<li><p>在μC/OS-II版本中，任务优先级号也作为任务的标识符</p>
</li>
</ul>
<h3 id="空闲任务和统计任务"><a href="#空闲任务和统计任务" class="headerlink" title="空闲任务和统计任务"></a>空闲任务和统计任务</h3><ul>
<li>内核总是创建一个空闲任务OSTaskIdle()<ul>
<li>总是设置为最低优先级，OS_LOWEST_PRIOR</li>
<li>当所有其他任务都未在执行时，空闲任务开始执行</li>
<li>应用程序不能删除该任务</li>
<li>空闲任务的工作就是把32位计数器OSIdleCtr加1，该计数器被统计任务所使用</li>
</ul>
</li>
<li>统计任务OSTaskStat()，提供运行时间统计<ul>
<li>每秒钟运行一次，计算当前的CPU利用率</li>
<li>其优先级是OS_LOWEST_PRIOR-1</li>
<li>可选</li>
</ul>
</li>
</ul>
<h3 id="任务控制块TCB"><a href="#任务控制块TCB" class="headerlink" title="任务控制块TCB"></a>任务控制块TCB</h3><p>任务控制块 OS_TCB是描述一个任务的核心数据结构，存放了它的各种管理信息，包括任务堆栈指针，任务的状态、优先级，任务链表指针等</p>
<p>一旦任务建立了，任务控制块OS_TCB将被赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">os_tcb</span> </span><br><span class="line">&#123;</span><br><span class="line"> 栈指针；</span><br><span class="line"> INT16U OSTCBId; <span class="comment">/*任务的ID*/</span></span><br><span class="line"> 链表指针；</span><br><span class="line"> OS_EVENT *OSTCBEventPtr; <span class="comment">/*事件指针*/</span></span><br><span class="line"> <span class="type">void</span> *OSTCBMsg; <span class="comment">/*消息指针*/</span></span><br><span class="line"> INT8U OSTCBStat; <span class="comment">/*任务的状态*/</span></span><br><span class="line"> INT8U OSTCBPrio; <span class="comment">/*任务的优先级*/</span></span><br><span class="line"> 其他……</span><br><span class="line">&#125; OS_TCB;</span><br></pre></td></tr></table></figure>
<h4 id="栈指针"><a href="#栈指针" class="headerlink" title="栈指针"></a>栈指针</h4><ul>
<li>OSTCBStkPtr：指向当前任务栈顶的指针</li>
<li>OSTCBStkBottom：指向任务栈底的指针</li>
<li>OSTCBStkSize：栈的容量<ul>
<li>用可容纳的指针数目而不是字节数（Byte）来表示</li>
</ul>
</li>
</ul>
<h4 id="链表指针"><a href="#链表指针" class="headerlink" title="链表指针"></a>链表指针</h4><ul>
<li>所有的任务控制块分属于两条不同的链表<ul>
<li>单向的空闲链表（头指针为OSTCBFreeList）</li>
<li>双向的使用链表（头指针为OSTCBList）</li>
</ul>
</li>
<li>OSTCBNext、OSTCBPrev：用于将任务控制块插入到空闲链表或使用链表中<ul>
<li>每个任务的任务控制块在任务创建的时候被链接到使用链表中，在任务删除的时候从链表中被删除</li>
<li>双向连接的链表使得任一成员都能快速插入或删除</li>
</ul>
</li>
</ul>
<h4 id="空闲TCB链表"><a href="#空闲TCB链表" class="headerlink" title="空闲TCB链表"></a>空闲TCB链表</h4><ul>
<li>所有的任务控制块都被放置在任务控制块列表数组OSTCBTbl[]中</li>
<li>系统初始化时，所有TCB被链接成空闲的单向链表，头指针为OSTCBFreeList</li>
<li>当创建一个任务后，就把OSTCBFreeList所指向的TCB赋给了该任务，并将它加入到使用链表中，然后把OSTCBFreeList指向空闲链表中的下一个结点</li>
</ul>
<h4 id="指针数组-指向相应TCB"><a href="#指针数组-指向相应TCB" class="headerlink" title="指针数组(指向相应TCB)"></a>指针数组(指向相应TCB)</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/d712cdb367544103982c/?dl=1'></p>
<h3 id="状态的转换"><a href="#状态的转换" class="headerlink" title="状态的转换"></a>状态的转换</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/f4b377aac18642e79f50/?dl=1'></p>
<h3 id="任务就绪表"><a href="#任务就绪表" class="headerlink" title="任务就绪表"></a>任务就绪表</h3><p>每个任务的就绪态标志放入在就绪表中</p>
<p>就绪表中有两个变量</p>
<ul>
<li>OSRdyGrp：在OSRdyGrp中，任务按优先级分组，8个任务为一组OSRdyGrp中的每一位表示8组任务中每一组中是否有进入就绪态的任务</li>
<li>OSRdyTbl[ ]：任务进入就绪态时，就绪表OSRdyTbl[ ]中的相应元素的相应位也置位</li>
</ul>
<h4 id="根据优先级确定就绪表"><a href="#根据优先级确定就绪表" class="headerlink" title="根据优先级确定就绪表"></a>根据优先级确定就绪表</h4><p>若OSRdyGrp及OSRdyTbl[]的第n位置1，则应该把OSRdyGrp及OSRdyTbl[]的值与$ 2^n$相或。uC/OS中，把$ 2^n$的n=0-7的8个值先计算好存在数组OSMapTbl[7]中</p>
<ul>
<li>假设优先级为12的任务进入就绪状态，12=1100b，则OSRdyTbl[1]的第4位置1，且OSRdyGrp的第1位置1，相应的数学表达式为:<ul>
<li>OSRdyGrp |= 0x02</li>
<li>OSRdyTbl[1] |= 0x10</li>
</ul>
</li>
</ul>
<h3 id="使任务进入就绪态"><a href="#使任务进入就绪态" class="headerlink" title="使任务进入就绪态"></a>使任务进入就绪态</h3><ul>
<li>如果prio是任务的优先级，即任务的标识号，则将任务放入就绪表，使任务进入就绪态的方法是<ul>
<li>OSRdyGrp |= OSMapTbl[prio&gt;&gt;3];</li>
<li>OSRdyTbl[prio&gt;&gt;3] |= OSMapTbl[prio&amp;0x07]</li>
</ul>
</li>
<li>假设优先级为12——1100b<ul>
<li>OSRdyGrp |= OSMapTbl[12&gt;&gt;3] (0x02)；</li>
<li>OSRdyTbl[1] |= 0x10;</li>
</ul>
</li>
</ul>
<h3 id="使任务脱离就绪态"><a href="#使任务脱离就绪态" class="headerlink" title="使任务脱离就绪态"></a>使任务脱离就绪态</h3><p>将任务就绪表OSRdyTbl[prio&gt;&gt;3]相应元素的相应位清零，而且当OSRdyTbl[prio&gt;&gt;3]中的所有位都为零时，即该任务所在组的所有任务中没有一个进入就绪态时，OSRdyGrp的相应位才为零</p>
<h3 id="任务的调度"><a href="#任务的调度" class="headerlink" title="任务的调度"></a>任务的调度</h3><ul>
<li>μC/OS-II是可抢占实时多任务内核，总是运行就绪任务中优先级最高的那一个</li>
<li>μC/OS-II中不支持时间片轮转法，每个任务的优先级要求不一样且是唯一的，所以任务调度的工作就是：查找准备就绪的最高优先级的任务并进行上下文切换</li>
<li>μC/OS-II任务调度所花的时间为常数，与应用程序中建立的任务数无关</li>
</ul>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>确定哪个任务的优先级最高，应该选择哪个任务去运行，这部分的工作是由调度器（Scheduler）来完成的</p>
<ul>
<li>任务级的调度是由函数OSSched()完成的</li>
<li>中断级的调度是由另一个函数OSIntExt()完成的</li>
</ul>
<h3 id="根据就绪表确定最高优先级"><a href="#根据就绪表确定最高优先级" class="headerlink" title="根据就绪表确定最高优先级"></a>根据就绪表确定最高优先级</h3><p>两个关键:</p>
<ul>
<li>将优先级数分解为高三位和低三位分别确定（64个任务版本）</li>
<li><p>高优先级有着小的优先级号</p>
</li>
<li><p>通过OSRdyGrp值确定高3位</p>
<ul>
<li>假设OSRdyGrp＝0x08=0x00001000，第3位为1，优先级的高3位为011</li>
</ul>
</li>
<li>通过OSRdyTbl[3]的值来确定低3位<ul>
<li>假设OSRdyTbl[3]＝0x3a，第1位为1，优先级的低3位为001，3*8+2-1=25</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/e5768e4725db4d7e8126/?dl=1'></p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OSSched</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> INT8U y;</span><br><span class="line"> <span class="built_in">OS_ENTER_CRITICAL</span>();</span><br><span class="line"> <span class="keyword">if</span> ((OSLockNesting | OSIntNesting) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">//检查是否中断</span></span><br><span class="line"> 	y = OSUnMapTbl[OSRdyGrp];</span><br><span class="line">   <span class="comment">//找到优先级最高的任务</span></span><br><span class="line"> 	OSPrioHighRdy = (INT8U)((y &lt;&lt; <span class="number">3</span>) + OSUnMapTbl[OSRdyTbl[y]]);</span><br><span class="line">   <span class="comment">//是否在运行</span></span><br><span class="line"> 	<span class="keyword">if</span> (OSPrioHighRdy != OSPrioCur) &#123;</span><br><span class="line"> 		OSTCBHighRdy=OSTCBPrioTbl[OSPrioHighRdy];</span><br><span class="line">	 	OSCtxSwCtr++;</span><br><span class="line">	 	<span class="built_in">OS_TASK_SW</span>();</span><br><span class="line"> 		&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">OS_EXIT_CRITICAL</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码中使用了查表法</p>
<h3 id="freertos的任务优先级调度示意"><a href="#freertos的任务优先级调度示意" class="headerlink" title="freertos的任务优先级调度示意"></a>freertos的任务优先级调度示意</h3><p>FreeRTOS 是一个实时操作系统，所奉行的调度规则：</p>
<ul>
<li>高优先级抢占低优先级任务，系统永远执行最高优先级的任务</li>
<li>同等优先级的任务轮转调度</li>
</ul>
<h3 id="任务级的任务切换OS-TASK-SW"><a href="#任务级的任务切换OS-TASK-SW" class="headerlink" title="任务级的任务切换OS_TASK_SW()"></a>任务级的任务切换OS_TASK_SW()</h3><ol>
<li>保护当前任务的现场</li>
<li>恢复新任务的现场</li>
<li>执行中断返回指令</li>
<li>开始执行新的任务</li>
</ol>
<h4 id="任务切换OS-TASK-SW-的代码"><a href="#任务切换OS-TASK-SW-的代码" class="headerlink" title="任务切换OS_TASK_SW()的代码"></a>任务切换OS_TASK_SW()的代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">OSCtxSw</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 将R1,R2,R3及R4推入当前堆栈；</span><br><span class="line"> OSTCBCur→OSTCBStkPtr = SP;</span><br><span class="line"> OSTCBCur = OSTCBHighRdy;</span><br><span class="line"> SP = OSTCBHighRdy →OSTCBSTKPtr;</span><br><span class="line"> 将R4,R3,R2及R1从新堆栈中弹出；</span><br><span class="line"> 执行中断返回指令；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给调度器上锁"><a href="#给调度器上锁" class="headerlink" title="给调度器上锁"></a>给调度器上锁</h3><ul>
<li>OSSchedlock()：给调度器上锁函数，用于禁止任务调度，保持对CPU的控制权（即使有优先级更高的任务进入了就绪态）</li>
<li>OSSchedUnlock()：给调度器开锁函数，当任务完成后调用此函数，调度重新得到允许</li>
</ul>
<h2 id="lecture-9-2-实时内核-任务之间的通信与同步"><a href="#lecture-9-2-实时内核-任务之间的通信与同步" class="headerlink" title="lecture 9-2 - 实时内核-任务之间的通信与同步"></a>lecture 9-2 - 实时内核-任务之间的通信与同步</h2><h3 id="事件控制块ECB"><a href="#事件控制块ECB" class="headerlink" title="事件控制块ECB"></a>事件控制块ECB</h3><p>所有的通信信号都被看成是事件(event), μC/OS-II通过事件控制块(ECB)来管理每一个具体事件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ECB数据结构</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">void</span> *OSEventPtr; <span class="comment">/*指向消息或消息队列的指针*/</span></span><br><span class="line"> INT8U OSEventTbl[OS_EVENT_TBL_SIZE];<span class="comment">//等待任务列表</span></span><br><span class="line"> INT16U OSEventCnt; <span class="comment">/*计数器（当事件是信号量时）*/</span></span><br><span class="line"> INT8U OSEventType; <span class="comment">/*事件类型：信号量、邮箱等*/</span></span><br><span class="line"> INT8U OSEventGrp; <span class="comment">/*等待任务组*/</span></span><br><span class="line">&#125; OS_EVENT;</span><br><span class="line"> 与TCB类似的结构，使用两个链表，空闲链表与使用链表</span><br></pre></td></tr></table></figure>
<h4 id="事件控制块ECB数据结构"><a href="#事件控制块ECB数据结构" class="headerlink" title="事件控制块ECB数据结构"></a>事件控制块ECB数据结构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/7001eb56830c40c599e5/?dl=1'></p>
<h3 id="任务和ISR之间的通信方式"><a href="#任务和ISR之间的通信方式" class="headerlink" title="任务和ISR之间的通信方式"></a>任务和ISR之间的通信方式</h3><ul>
<li>一个任务或ISR可以通过事件控制块ECB（信号量、邮箱或消息队列）向另外的任务发信号 </li>
<li>一个任务还可以等待另一个任务或中断服务子程序给它发送信号，对于处于等待状态的任务，还可以给它指定一个最长等待时间</li>
<li>多个任务可以同时等待同一个事件的发生，当该事件发生后，在所有等待该事件的任务中，优先级最高的任务得到了该事件并进入就绪状态，准备执行 </li>
</ul>
<h3 id="等待任务列表"><a href="#等待任务列表" class="headerlink" title="等待任务列表"></a>等待任务列表</h3><ul>
<li>每个正在等待某个事件的任务被加入到该事件的ECB的==等待任务列表==中，该列表包含两个变量OSEventGrp和OSEventTbl[ ] </li>
<li>在OSEventGrp中，任务按优先级分组，8个任务为一组，共8组，分别对应OSEventGrp 当中的8位</li>
<li>当某组中有任务处于等待该事件的状态时，对应的位就被置位，同时OSEventTbl[]中的相应位也被置位</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/0915be298c044862af47/?dl=1'></p>
<h2 id="lecture-10-bsp-bootloader"><a href="#lecture-10-bsp-bootloader" class="headerlink" title="- lecture 10 - bsp-bootloader"></a>- lecture 10 - bsp-bootloader</h2><h3 id="嵌入式系统的启动过程"><a href="#嵌入式系统的启动过程" class="headerlink" title="嵌入式系统的启动过程"></a>嵌入式系统的启动过程</h3><ol>
<li>上电复位、板级初始化阶段</li>
<li>系统引导/升级阶段<ul>
<li>引导<ul>
<li>将系统软件从NOR Flash中读取出来加载到RAM中运行 -&gt; 解决成本及Flash速度比RAM慢的问题</li>
<li>不需将软件引导到RAM中而是让其直接在NorFlash上运行</li>
<li>将软件从外存（如NandFlash、CF卡、MMC等）中读取出来加载到RAM中 -&gt; 成本更低 </li>
</ul>
</li>
<li>升级<ul>
<li>可通过网络进行远程升级或通过串口进行本地升级</li>
<li>远程升级一般支持TFTP、FTP、HTTP等方式</li>
<li>本地升级可通过Console口使用超级终端或特定的升级软件进行</li>
</ul>
</li>
</ul>
</li>
<li>系统初始化阶段<ul>
<li>进行操作系统等系统软件各功能部分必需的初始化工作</li>
<li>系统初始化阶段需要按特定顺序进行，如内核-&gt;网络-&gt;文件系统</li>
</ul>
</li>
<li>应用初始化阶段<ul>
<li>进行应用任务的创建，信号量、消息队列的创建和与应用相关的其它初始化工作</li>
</ul>
</li>
<li>多任务应用运行阶段<ul>
<li>各种初始化工作完成后，系统进入多任务状态，操作系统按照已确定的算法进行任务的调度，各应用任务分别完成特定的功能</li>
</ul>
</li>
</ol>
<h3 id="bsp，特点，与bios区别"><a href="#bsp，特点，与bios区别" class="headerlink" title="bsp，特点，与bios区别"></a>bsp，特点，与bios区别</h3><p>BSP全称“板级支持包”（Board Support Packages），==说的简单一点，就是一段启动代码==，和计算机主板的BIOS差不多，但提供的功能区别就相差很大</p>
<p><strong><em>特点</em></strong></p>
<ul>
<li>硬件相关性<ul>
<li>因为嵌入式实时系统的硬件环境具有应用相关性，所以，作为高层软件与硬件之间的接口，BSP必须为操作系统提供操作和控制具体硬件的方法</li>
</ul>
</li>
<li>操作系统相关性<ul>
<li>不同的操作系统具有各自的软件层次结构， 因此，不同的操作系统具有特定的硬件接口形式 </li>
</ul>
</li>
</ul>
<p><strong><em>与BIOS区别</em></strong></p>
<ul>
<li>BIOS主要是负责在电脑开启时检测、初始化系统设备（设置栈指针，中断分配，内存初始化..）、装入操作系统并调度操作系统向硬件发出的指令</li>
<li>==BSP是和操作系统绑在一起运行==，尽管BSP的开始部分和BIOS所做的工作类似，但是 ==BSP还包含和系统有关的基本驱动==</li>
<li>==BIOS程序是用户不能更改，编译编程的==，只能对参数进行修改设置，但是==程序员还可以编程修改BSP==，在BSP中任意添加一些和系统无关的驱动或程序，甚至可以把上层开发的统统放到BSP中</li>
</ul>
<h3 id="引导模式"><a href="#引导模式" class="headerlink" title="引导模式"></a>引导模式</h3><p>操作系统引导概念：将操作系统装入内存并开始执行的过程</p>
<ol>
<li>不需要BootLoader的引导模式：时间效率高，系统快速启动，直接在NOR flash或ROM系列非易失性存储介质中运行，但不满足运行速度的要求</li>
<li>需要BootLoader的引导模式：节省空间，牺牲时间，适用于硬件成本低，运行速度快，但启动速度相对慢</li>
</ol>
<h3 id="bootloader及其启动过程"><a href="#bootloader及其启动过程" class="headerlink" title="bootloader及其启动过程"></a>bootloader及其启动过程</h3><p>BOOTLOADER的生命周期</p>
<ul>
<li>初始化硬件,如设置UART(至少设置一个),检测存储器等</li>
</ul>
<ol>
<li>设置启动参数,告诉内核硬件的信息,如用哪个启动界面,波特率.</li>
<li>跳转到操作系统的首地址.</li>
</ol>
<ul>
<li>消亡</li>
</ul>
<h2 id="Lecture11-物联⽹概述"><a href="#Lecture11-物联⽹概述" class="headerlink" title="Lecture11 - 物联⽹概述+"></a>Lecture11 - 物联⽹概述+</h2><h3 id="定义，术语"><a href="#定义，术语" class="headerlink" title="定义，术语"></a>定义，术语</h3><p><strong><em>定义</em></strong></p>
<ul>
<li>物联网（英语：Internet of Things，简称IoT）是一种计算设备、机械、数字机器相互关系的系统，具备通用唯一识别码（UID），并具有通过网络传输数据的能力，无需人与人、或是人与设备的交互</li>
<li>物联网，Internet of Things (IoT) ，通过射频识别(RFID)、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络概念</li>
</ul>
<p><strong><em>术语</em></strong></p>
<ul>
<li>设备：在物联网中，具有强制性通信能力和选择性传感、激励、数据捕获、数据存储和数据处理能力的设备</li>
<li>物：在物联网中，“物”指物理世界（物理装置）或信息世界（虚拟事物）中的对象，可以被标识并整合入通信网</li>
</ul>
<h3 id="IOT特征"><a href="#IOT特征" class="headerlink" title="IOT特征"></a>IOT特征</h3><ul>
<li>智能：从生成的数据中提取知识</li>
<li>架构：一个支持许多其他架构的混合架构</li>
<li>复杂的系统：一组动态变化的对象</li>
<li>规模：可伸缩性</li>
<li>时间：数十亿并行和同时发生的事件</li>
<li>空间：定位</li>
<li>一切都是服务：将资源作为服务消费</li>
</ul>
<h3 id="IOT的优势和不足"><a href="#IOT的优势和不足" class="headerlink" title="IOT的优势和不足"></a>IOT的优势和不足</h3><p><strong><em>优势</em></strong></p>
<ol>
<li>技术优化：物联网技术有助于技术的改进和提高</li>
<li>改进的数据采集：传统的数据采集有其局限性和被动使用的设计，物联网促进了对数据的即时行动</li>
<li>减少浪费：物联网提供实时信息可使资源被有效的管理</li>
<li>提高客户参与度：物联网允许你通过发现问题和改进流程来改善客户体验</li>
</ol>
<p><strong><em>不足</em></strong></p>
<ol>
<li>安全：物联网技术创造了一个连接设备的生态系统，尽管有足够的安全措施，但系统可能缺乏足够的认证控制</li>
<li>隐私：物联网的使用，在没有用户积极参与的情况下，暴露大量的个人数据，这就产生了很多隐私问题</li>
<li>灵活性：主要涉及到与另一个系统的集成，在这个过程中涉及到许多不同的系统</li>
<li>复杂性：物联网系统的设计也相当复杂，此外部署和维护也不是很容易</li>
<li>合规性：物联网有自己的一套规则和法规，然而，由于法规遵循的复杂性，其任务是相当具有挑战性的</li>
</ol>
<h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/12176ac2c43c47e58198/?dl=1'></p>
<ul>
<li>消费者物联网用例<ul>
<li>智能家居类：智能灌溉、智能车库门、智能门锁、智能灯、智能恒温器和智能安全系统<ul>
<li>智能家居行业发展主要分为三个阶段：单品连接，物物联动，平台集成</li>
</ul>
</li>
<li>可穿戴设备类：健康和运动跟踪器、智能服装/可穿戴设备</li>
<li>宠物类：宠物定位系统、智能狗狗门</li>
</ul>
</li>
<li>零售、金融和营销<ul>
<li>任何以消费者为基础的商业交易场所，如定向广告，信标（如近距离感知客户）作为营销分析，资产跟踪，如库存控制、损失控制和供应链优化，资产保险跟踪</li>
</ul>
</li>
<li>医疗健康<ul>
<li>医疗保健物联网用例：家庭患者护理，预测性和预防性医疗的学习模型，痴呆症患者和老年人护理和跟踪</li>
</ul>
</li>
<li>智慧城市Smart City<ul>
<li>通过环境感知进行污染控制和监管分析，城市范围小气候天气预报，按需废物管理服务，智能交通灯控制和模式化，改善交通流量和燃油经济性</li>
</ul>
</li>
<li>智慧安防<ul>
<li>城市的安防从过去简单的安全防护系统向城市综合化体系演变</li>
<li>引入物联网技术后可以通过无线移动、跟踪定位等手段建立全方位的立体防护</li>
</ul>
</li>
<li>智能电网Smart Grids<ul>
<li>智能电网基本上承诺以自动化方式提取消费者和电力供应商的行为信息，以提高配电的效率、经济和可靠性，优化资源的使用</li>
</ul>
</li>
<li>能源产业物联网用例<ul>
<li>石油钻井平台数千个传感器和数据点分析，提高效率；远程太阳能电池板监控和维护；核设施的危险分析；智能电表、气表和水表</li>
</ul>
</li>
<li>智能制造<ul>
<li>智能工厂和工业 4.0 项目需要安全可靠的物联网设计</li>
<li>数字化工厂的核心特点是：产品的智能化、生产的自动化、信息流和物资流合一 </li>
</ul>
</li>
<li>工业和制造业物联网用例<ul>
<li>对新旧设备进行预防性维护；通过实时需求提高产量；节能</li>
</ul>
</li>
<li>智慧交通<ul>
<li>智能公交车、共享单车、汽车联网、智慧停车以及智能红绿灯、充电桩、高速无感收费等</li>
</ul>
</li>
<li>智慧物流<ul>
<li>集仓储、运输、配送、信息服务等多功能于一体，优化社会物流资源配置</li>
<li>实现物流各环节精细化、动态化、可视化管理，提高物流系统智能化分析决策和自动化操作执行能力，提升物流运作效率</li>
</ul>
</li>
<li>运输业和物流业物联网用例<ul>
<li>车队跟踪和位置感知；市政车辆的规划、路线和监控；冷藏运输和食品配送安全</li>
</ul>
</li>
<li>农业和环境物联网用例<ul>
<li>智能灌溉和施肥技术，以提高产量；智能照明在巢式或家禽养殖中的应用；牲畜监控和资产跟踪</li>
</ul>
</li>
</ul>
<h2 id="lecture12-IoT-技术"><a href="#lecture12-IoT-技术" class="headerlink" title="lecture12 - IoT 技术+"></a>lecture12 - IoT 技术+</h2><h3 id="IoT多样化的技术环境"><a href="#IoT多样化的技术环境" class="headerlink" title="IoT多样化的技术环境"></a>IoT多样化的技术环境</h3><ul>
<li>硬件(端设备)</li>
<li>用于开发设备软件、固件和API的集成开发环境（IDE）</li>
<li>通信（RFID、NFC、6LowPAN、Zig Bee、蓝牙、WiFi、2G/4G/5G）</li>
<li>IoT协议（CoAP、RESTful HTTP、MQTT、XMPP）</li>
<li>网络骨干网（IPv4、IPv6、UDP、6LowPAN）</li>
<li>软件 (RIOT OS、Contiki OS、Eclipse IoT)</li>
<li>云平台/数据中心</li>
<li>机器学习算法和软件</li>
</ul>
<h3 id="物联网软件、硬件、连接"><a href="#物联网软件、硬件、连接" class="headerlink" title="物联网软件、硬件、连接"></a>物联网软件、硬件、连接</h3><ul>
<li>物联网软件：若干物联网技术已接近成熟，包括边缘人工智能、基于物联网的流分析、监督和非监督机器学习 </li>
<li>物联网硬件：现有物联网技术被归类为相当成熟或主流包括cpu、mcu、gpu、安全芯片、FPGA和边缘网关 </li>
<li>物联网连接：eSIM、mesh网络、5G和Wi-Fi 6，接近成熟</li>
</ul>
<h3 id="进步最快的技术"><a href="#进步最快的技术" class="headerlink" title="进步最快的技术"></a>进步最快的技术</h3><ul>
<li>智能传感器<ul>
<li>在过去的三年中，围绕传感器的技术发展出现了高潮，这些传感器旨在解决各种边缘应用程序的延迟、数据吞吐量和安全性问题</li>
<li>新型传感器嵌入了数据处理功能，可以在更靠近传感器的地方处理数据，并对用户界面或执行器作出响应</li>
<li>推动智能传感器应用的一些应用包括可穿戴医疗设备，如血糖监测器，以及基于人工智能的制造质量控制</li>
</ul>
</li>
<li>Wi-Fi 6：相当成熟<ul>
<li>显著提高速度和网络容量，为接入点提供最佳吞吐量。其吞吐能力几乎是Wi-Fi 5的4倍</li>
<li>路由器、网关和客户场所设备(cpe)是Wi-Fi6在过去三年中快速普及的关键设备</li>
</ul>
</li>
<li>gpu<ul>
<li>优化gpu以训练AI深度学习模型，为物联网应用同时处理多个计算，并将gpu引入数据中心，因为它们具有并行处理能力，这使其更加成熟 </li>
</ul>
</li>
</ul>
<h3 id="IoT面临的挑战"><a href="#IoT面临的挑战" class="headerlink" title="IoT面临的挑战"></a>IoT面临的挑战</h3><p><strong><em>技术上的挑战</em></strong></p>
<ul>
<li>安全Security</li>
<li>互联Connectivity</li>
<li>兼容性和寿命Compatibility and Longevity</li>
<li>标准Standards</li>
<li>智能分析与动作Intelligent Analysis &amp; Actions</li>
</ul>
<p><strong><em>商业上的挑战</em></strong></p>
<p><strong><em>社会性问题</em></strong></p>
<h2 id="lecture13-IOT平台"><a href="#lecture13-IOT平台" class="headerlink" title="lecture13 - IOT平台"></a>lecture13 - IOT平台</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>物联网平台是一种多层技术，能够在物联网领域中直接提供、管理和自动化连接设备。通过使用灵活的连接选项、企业级安全机制和广泛的数据处理能力，无论硬件多样化如何都将硬件连接到云</p>
<p>对于开发者来说，物联网平台提供了一套随时可用的功能，极大地加快了联网设备应用程序的开发，同时兼顾了可扩展性和跨设备兼容性</p>
<p>物联网平台起源于物联网中间件的形式，其目的是充当硬件层和应用层之间的中介</p>
<h3 id="功能领域"><a href="#功能领域" class="headerlink" title="功能领域"></a>功能领域</h3><ul>
<li>使设备连接管理简单<ul>
<li>设备连接性是任何物联网产品的重要组成部分</li>
<li>连接管理平台还可以提供工具来跟踪数据消耗、在不同网络或服务线路之间切换设备</li>
</ul>
</li>
<li>接收、存储和发送数据<ul>
<li>数据管理是另一个需要关注的关键功能，因为需要一个中央集线器来管理和综合设备收集的数据</li>
<li>物联网平台作为终端设备生成数据的接收点</li>
</ul>
</li>
<li>帮助企业可视化设备数据并提供关键的见解<ul>
<li>许多物联网平台都配备了易于使用的数据仪表板，可以根据需要自定义查看的数据</li>
<li>设备管理可视化的目标是快速提供关于系统正在发生何事的见解，这样就可以在异常成为问题之前处理它们 </li>
</ul>
</li>
<li>提供特定于应用程序的支持和数据<ul>
<li>利用来自多个信息源的输入，将它们与有关特定应用程序的上下文连接起来</li>
</ul>
</li>
<li>是否有知识渊博、反应灵敏的支持团队‍<ul>
<li>需要平台提供商提供的持续支持和专业知识的数量取决于团队的规模以及项目的范围和重点</li>
</ul>
</li>
<li>提供健壮的安全<ul>
<li>最小权限原则也适用于物联网平台级别</li>
<li>要实现最有效的安全控制，寻找一种允许基于角色的访问控制的物联网平台，以便为团队中的每个人分配不同的职责和权限</li>
</ul>
</li>
<li>提供支持物联网解决方案特定需求的定制<ul>
<li>许多平台都提供了一定程度的定制，但要确保选择的平台能够适应需要它做的任何事情</li>
<li>一些物联网平台还允许添加任务管理工具，以简化团队成员之间的协作。</li>
</ul>
</li>
<li>一致的产品交付和平台更新<ul>
<li>寻找定期对系统进行更新和升级的物联网平台提供商</li>
<li>一些平台开始提供主动管理功能</li>
</ul>
</li>
</ul>
<h2 id="lecture14-IOT平台关键技术"><a href="#lecture14-IOT平台关键技术" class="headerlink" title="lecture14 - IOT平台关键技术+"></a>lecture14 - IOT平台关键技术+</h2><h3 id="设备管理，主要功能，物模型、设备影子、数字孪生（概念、价值）"><a href="#设备管理，主要功能，物模型、设备影子、数字孪生（概念、价值）" class="headerlink" title="设备管理，主要功能，物模型、设备影子、数字孪生（概念、价值）"></a>设备管理，主要功能，物模型、设备影子、数字孪生（概念、价值）</h3><p><strong><em>设备管理</em></strong></p>
<ul>
<li>设备管理服务, 可以帮助对所有连接的设备, 在全球范围内进行规模化的注册、查看及远程管理</li>
<li>设备管理在设备接入基础上，提供了更丰富完备的设备管理能力，简化海量设备管理复杂性，节省人工操作，提升管理效率 </li>
</ul>
<p><strong><em>主要功能</em></strong></p>
<p>物联网平台提供功能丰富的设备管理服务，包括不限于：</p>
<p>生命周期；设备分组；设备影子；物模型；数据解析；数据存储；在线调试</p>
<p><strong><em>物模型</em></strong></p>
<ul>
<li>物模型（Thing Model）是对设备在云端的功能描述，包括设备的属性、数据、服务和事件 </li>
<li>物联网平台通过定义一种物的描述语言来描述物模型，称之为 TSL（即 Thing Specification Language），采用JSON格式，可以根据TSL组装上报设备的数据 </li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/f4de5b2581804ddc9445/?dl=1'></p>
<p><strong><em>设备影子</em></strong></p>
<ul>
<li>物联网平台提供设备影子功能，用于缓存设备状态</li>
<li>设备影子是一个 JSON 文档</li>
<li>每个设备有且只有一个设备影子，设备可以通过MQTT获取和设置设备影子来同步状态</li>
</ul>
<p>应用：</p>
<ul>
<li>网络不稳定，设备频繁上下线 </li>
<li>多程序同时请求获取设备状态 </li>
<li>设备掉线 / 指令携带时间戳</li>
</ul>
<p><strong><em>数字孪生</em></strong></p>
<p>数字孪生，英文名叫Digital Twin（数字双胞胎），也被称为数字映射、数字镜像</p>
<p>数字孪生，是充分利用物理模型、传感器更新、运行历史等数据，集成多学科、多物理量、多尺度、多概率的仿真过程，在虚拟空间中完成映射，从而反映相对应的实体装备的全生命周期过程 </p>
<p>价值</p>
<ul>
<li>可见性: 数字孪生能够实现机器操作的可见性，以及制造工厂或者机场中大型的互联系统的可见性 </li>
<li>预测性: 使用多种建模技术(基于物理和基于数学的)，数字孪生模型能够用于预测机器未来的状态</li>
<li>假设分析: 通过适当设计的接口，可以很容易的与模型进行交互，并且对模型询问假设问题，来模拟现实中无法创建的各种条件 </li>
<li>对行为进行理解和解释的记录与沟通机制：数字孪生模型能够作为一种沟通和记录机制，能够对单独的机器或者机器的集合的行为进行理解和解释</li>
<li>连接不同的系统：比如后端的业务应用</li>
</ul>
<h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p><strong><em>基于云的IOT解决方案不足</em></strong></p>
<ol>
<li>对于大规模边缘的多源异构数据处理要求，无法在集中式计算线性增长的计算能力下得到满足</li>
<li>数据在用户和云数据中心之间的长距离传输将导致高网络时延和计算资源浪费</li>
<li>大多数终端用户处于网络边缘，通常使用的是资源有限的移动设备，具有低存储和计算能力以及有限的电池容量，所以有必要将一些不需要长距离传输到云数据中心的任务分摊到网络边缘端</li>
<li>云计算中数据安全性和隐私保护在远程传输和外包机制中将面临很大的挑战，使用边缘计算处理数据则可以降低隐私泄漏的风险</li>
</ol>
<p><strong><em>边缘/边缘计算概念</em></strong></p>
<p>我们将“边缘”定义为数据源和云数据中心之间的任何计算和网络资源</p>
<p>边缘计算与雾计算是可以互换的</p>
<ul>
<li>ISO/IEC JTC1/SC38：边缘计算是一种将主要处理和数据存储放在网络的边缘节点的分布式计算形式</li>
<li>国际标准组织ETSI的定义为在移动网络边缘提供 IT 服务环境和计算能力，强调靠近移动用户，以减少网络操作和服务交付的时延，提高用户体验</li>
</ul>
<p><strong><em>优势</em></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/94e96c19ca2d43a28a34/?dl=1'></p>
<p><strong><em>用途</em></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/dce15787f6e345098077/?dl=1'></p>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p><strong><em>主流技术</em></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/a36d113d7aad4821b6e7/?dl=1'></p>
<p><strong><em>多协议接入方案</em></strong></p>
<p>通过协议转换网关实现泛协议设备接入?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src='https://box.nju.edu.cn/f/e49a82f97d7c437cb105/?dl=1'></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://sebugmaker.github.io">Rain Sun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://sebugmaker.github.io/posts/612fa1e.html">http://sebugmaker.github.io/posts/612fa1e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sebugmaker.github.io" target="_blank">Rain's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></div><div class="post_share"><div class="social-share" data-image="https://box.nju.edu.cn/f/23f2833d55ac43308a73/?dl=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f2dc9eb.html" title="DevOps期末复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/493b6ecb651f4dd99d71/?dl=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DevOps期末复习</div></div></a></div><div class="next-post pull-right"><a href="/posts/dc53850b.html" title="MISE_hw4_体系结构作业"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/3fdd71e61b504e9bb79d/?dl=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MISE_hw4_体系结构作业</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/8618b667f75848d78fe7/?dl=1" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rain Sun</div><div class="author-info__description">Mia San Mia</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SEBugMaker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SEBugMaker" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sunbugmaker@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
    var sentence = document.querySelector("#poem_sentence")
    var author = document.querySelector("#poem_author")
    var dynasty = document.querySelector("#poem_dynasty")

    var sentenceText = result.data.content
    sentenceText = sentenceText.substr(0, sentenceText.length - 1);
    sentence.innerHTML = sentenceText
    dynasty.innerHTML = result.data.origin.dynasty
    author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">嵌入式系统概论复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">lecture 1 - 嵌入式系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">嵌入式系统的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">嵌入式系统三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">无处不在的嵌入式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPS"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">CPS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSN"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">WSN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOT"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">IOT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="toc-number">1.1.4.</span> <span class="toc-text">嵌入式系统组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.5.</span> <span class="toc-text">与通用计算机的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.6.</span> <span class="toc-text">嵌入式系统的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.7.</span> <span class="toc-text">嵌入式系统分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-2-%E5%B5%8C%E2%BC%8A%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%BD%85%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">lecture 2 - 嵌⼊式系统设计⽅法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%89%80%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">嵌入式系统设计所面临的挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">传统的嵌入式开发过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%8D%8F%E5%90%8C%E8%AE%BE%E8%AE%A1-HW-SW-Co-design"><span class="toc-number">1.2.3.</span> <span class="toc-text">软硬件协同设计 HW&#x2F;SW Co-design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%88%92%E5%88%86%EF%BC%88%E5%BD%B1%E5%93%8D%E8%BD%AF%E7%A1%AC%E4%BB%B6%E6%8A%98%E8%A1%B7%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E5%8F%8C%E9%87%8D%E6%80%A7%E3%80%81%E9%80%9F%E5%BA%A6%E3%80%81%E7%81%B5%E6%B4%BB%E6%80%A7%E3%80%81%E5%BC%80%E9%94%80%EF%BC%8C%E5%8F%8C%E9%87%8D%E6%80%A7%E4%B8%BA%E5%89%8D%E6%8F%90%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">软硬件划分（影响软硬件折衷方案——双重性、速度、灵活性、开销，双重性为前提）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-3-%E5%B5%8C%E2%BC%8A%E5%BC%8F%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">lecture 3 - 嵌⼊式微处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">冯诺依曼结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">哈佛结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RISC-VS-CISC"><span class="toc-number">1.3.3.</span> <span class="toc-text">RISC VS CISC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RISC-V"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">RISC-V</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">嵌入式微处理器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FPGA"><span class="toc-number">1.3.5.</span> <span class="toc-text">FPGA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DSP%E4%B8%8EFPGA"><span class="toc-number">1.3.6.</span> <span class="toc-text">DSP与FPGA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.7.</span> <span class="toc-text">嵌入式微处理器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARM%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.8.</span> <span class="toc-text">ARM架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.9.</span> <span class="toc-text">选择微处理器的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%8D%81%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.10.</span> <span class="toc-text">选择微处理器的十个步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-4-%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">lecture 4 - 存储器架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">易失性存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">在嵌入式系统中的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">非易失性存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E4%BB%B6"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">固件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">存储器层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache"><span class="toc-number">1.4.4.</span> <span class="toc-text">cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7cache"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">多级cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">暂存存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E9%9A%BE%E4%BB%A5%E9%A2%84%E6%B5%8B"><span class="toc-number">1.4.6.</span> <span class="toc-text">存储器访问时间难以预测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-5-%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">lecture 5 - 基于总线的计算机系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%AE%BE%E5%A4%87"><span class="toc-number">1.5.1.</span> <span class="toc-text">I&#x2F;O接口与设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%88%AB"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">类别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87"><span class="toc-number">1.5.2.</span> <span class="toc-text">I&#x2F;O设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8BI-O"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">可编程I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8BI-O%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">独立I&#x2F;O端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84I-O"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">内存映射I&#x2F;O</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ARM-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84I-O"><span class="toc-number">1.5.2.2.3.</span> <span class="toc-text">ARM 内存映射I&#x2F;O</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%99%E7%AD%89I-O"><span class="toc-number">1.5.3.</span> <span class="toc-text">忙等I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%ADI-O"><span class="toc-number">1.5.4.</span> <span class="toc-text">中断I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%AB%AF%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">中端接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">中断行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">中断物理接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%90%91%E9%87%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text">优先级和向量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">优先级中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">中断向量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.6.</span> <span class="toc-text">通用中断机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%BA%8F%E5%88%97"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">中断序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%BC%80%E9%94%80%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-number">1.5.7.</span> <span class="toc-text">中断开销的来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97"><span class="toc-number">1.5.8.</span> <span class="toc-text">中断设计指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">1.5.9.</span> <span class="toc-text">可重入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">原子变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E4%BB%A3%E7%A0%81%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">保持代码可重入性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">1.5.10.</span> <span class="toc-text">总线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">总线协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.5.10.2.</span> <span class="toc-text">总线复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.10.3.</span> <span class="toc-text">系统总线配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-6-1-%E5%B5%8C%E2%BC%8A%E5%BC%8F%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.</span> <span class="toc-text">lecture 6-1 - 嵌⼊式软件系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.1.</span> <span class="toc-text">嵌入式软件的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">与桌面软件的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6-%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">1.6.2.</span> <span class="toc-text">软件&#x2F;硬件的权衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">1.6.3.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%A3%80"><span class="toc-number">1.6.4.</span> <span class="toc-text">自检</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.5.</span> <span class="toc-text">软件系统层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E4%B8%BA%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E5%BB%BA%E7%AB%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.6.</span> <span class="toc-text">为何要为实时系统建立模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.6.7.</span> <span class="toc-text">模型间的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.8.</span> <span class="toc-text">嵌入式系统的可视化程序模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9E%8B%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">单线程程序模型优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.6.8.2.</span> <span class="toc-text">多线程程序模型的优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-6-2-%E5%B5%8C%E2%BC%8A%E5%BC%8F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%BB%BC%E8%BF%B0"><span class="toc-number">1.7.</span> <span class="toc-text">lecture 6-2 - 嵌⼊式软件架构综述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">嵌入式软件架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">嵌入式软件架构模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">实时嵌入式软件常用的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%A4%96%E8%AE%BE%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.4.</span> <span class="toc-text">管理外设数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%AE%BE%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">外设轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">轮询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#watchdog%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">1.7.4.2.1.</span> <span class="toc-text">watchdog看门狗</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">有限状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">中断设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E4%B8%AD%E6%96%AD%E7%9A%84%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.7.4.4.1.</span> <span class="toc-text">带有中断的轮询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96-%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%AD%E6%96%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.4.4.2.</span> <span class="toc-text">数据获取&#x2F;存储相关的中断设计模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA"><span class="toc-number">1.7.4.5.</span> <span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DMA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B0%86%E5%A4%96%E8%AE%BE%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%88%B0%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.4.5.1.</span> <span class="toc-text">DMA控制器将外设数据传输到循环缓冲区的设计模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTOS%EF%BC%88%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.5.</span> <span class="toc-text">RTOS（实时操作系统）应用程序设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">资源同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%90%8C%E6%AD%A5"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">活动同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOT%EF%BC%88%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%89"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">IOT（物联网）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E5%8A%9F%E8%80%97%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.6.</span> <span class="toc-text">低功耗应用程序设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.7.7.</span> <span class="toc-text">多核架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%94%A8%E4%BE%8B"><span class="toc-number">1.7.7.1.</span> <span class="toc-text">人工智能用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%8E%A7%E5%88%B6%E7%94%A8%E4%BE%8B"><span class="toc-number">1.7.7.2.</span> <span class="toc-text">实时控制用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%94%A8%E4%BE%8B"><span class="toc-number">1.7.7.3.</span> <span class="toc-text">安全解决方案用例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-7-1-%E5%B5%8C%E2%BC%8A%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.8.</span> <span class="toc-text">lecture 7-1 - 嵌⼊式系统建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E6%A8%A1%E3%80%81%E8%AE%BE%E8%AE%A1%E3%80%81%E5%88%86%E6%9E%90"><span class="toc-number">1.8.1.</span> <span class="toc-text">建模、设计、分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.8.2.</span> <span class="toc-text">建模</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">模型的基本特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">常见的系统建模技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">基于模型的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-1"><span class="toc-number">1.8.3.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.8.4.</span> <span class="toc-text">嵌入式系统模型的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.8.5.</span> <span class="toc-text">为何为嵌入式系统建模?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.8.6.</span> <span class="toc-text">软件建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80"><span class="toc-number">1.8.7.</span> <span class="toc-text">建模语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BB%BA%E7%AB%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.8.8.</span> <span class="toc-text">何时为嵌入式系统建立模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%A3%80%E6%B5%8B%E7%9A%84%E6%97%B6%E9%97%B4%E5%92%8C%E6%88%90%E6%9C%AC"><span class="toc-number">1.8.9.</span> <span class="toc-text">缺陷检测的时间和成本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-7-2-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BAFSM"><span class="toc-number">1.9.</span> <span class="toc-text">lecture 7-2 - 有限状态机FSM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">反应式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FSM%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">FSM定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">1.9.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FSM%E5%BA%94%E2%BD%A4%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.9.4.</span> <span class="toc-text">FSM应⽤实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%BD%E8%BD%A6%E8%AD%A6%E6%8A%A5%E5%99%A8"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">汽车警报器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%83%E8%B1%86%E4%BA%BA"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">吃豆人</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Internet-Protocols-TCP"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">Internet Protocols: TCP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FSM%E7%89%B9%E6%80%A7"><span class="toc-number">1.9.5.</span> <span class="toc-text">FSM特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Moore%E6%9C%BA%E5%92%8CMealy%E6%9C%BA"><span class="toc-number">1.9.6.</span> <span class="toc-text">Moore机和Mealy机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7-amp-%E4%BC%98%E5%8C%96"><span class="toc-number">1.9.7.</span> <span class="toc-text">等价&amp;优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7FSM"><span class="toc-number">1.9.8.</span> <span class="toc-text">非确定性FSM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFAs%E4%B8%8E-NFA"><span class="toc-number">1.9.9.</span> <span class="toc-text">DFAs与 NFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84FSM%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.9.10.</span> <span class="toc-text">常规FSM建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9B%BE-%E5%B1%82%E6%AC%A1FSM"><span class="toc-number">1.9.11.</span> <span class="toc-text">状态图: 层次FSM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1FSM%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.9.12.</span> <span class="toc-text">层次FSM模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%8C%96%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-number">1.9.13.</span> <span class="toc-text">层次化状态图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.13.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.13.2.</span> <span class="toc-text">默认状态机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.13.3.</span> <span class="toc-text">历史机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.9.13.4.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%92%8C%E7%A6%BB%E5%BC%80%E4%B8%8E%E5%9E%8B%E8%B6%85%E7%8A%B6%E6%80%81"><span class="toc-number">1.9.13.5.</span> <span class="toc-text">进入和离开与型超状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StateCharts%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.9.14.</span> <span class="toc-text">StateCharts图中的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.9.14.1.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%AD%94%E6%9C%BA%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.9.14.2.</span> <span class="toc-text">应答机层次结构中使用定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StateCharts%E4%B8%AD%E7%9A%84%E8%BE%B9%E7%9A%84%E6%A0%87%E5%8F%B7"><span class="toc-number">1.9.15.</span> <span class="toc-text">StateCharts中的边的标号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.9.15.1.</span> <span class="toc-text">条件转移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StateCharts%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.9.16.</span> <span class="toc-text">StateCharts的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StateChart%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.9.17.</span> <span class="toc-text">StateChart的不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%A5%AE%E6%96%99%E5%94%AE%E5%8D%96%E6%9C%BA"><span class="toc-number">1.9.18.</span> <span class="toc-text">例子：自动饮料售卖机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%BE%83%E5%8A%A8%E9%A5%AE%E6%96%99%E5%94%AE%E5%8D%96%E6%9C%BA-1-0"><span class="toc-number">1.9.18.1.</span> <span class="toc-text">⾃动饮料售卖机 1.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%A5%AE%E6%96%99%E5%94%AE%E5%8D%96%E6%9C%BAV1-1"><span class="toc-number">1.9.18.2.</span> <span class="toc-text">自动饮料售卖机V1.1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1FSM"><span class="toc-number">1.9.19.</span> <span class="toc-text">层次FSM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-8-eos"><span class="toc-number">1.10.</span> <span class="toc-text">Lecture 8 - eos</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.1.</span> <span class="toc-text">实时系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-2"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.2.</span> <span class="toc-text">嵌入式操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.3.</span> <span class="toc-text">实时操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RTOS-and-GPOS%EF%BC%88%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">RTOS and GPOS（通用操作系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RTOS%E4%BB%8EGPOS%E4%B8%AD%E5%88%86%E7%A6%BB%E5%87%BA%E6%9D%A5%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.10.3.1.1.</span> <span class="toc-text">RTOS从GPOS中分离出来的不同功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTOS%E5%85%B3%E9%94%AE%E8%A6%81%E6%B1%82"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">RTOS关键要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8RTOS"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">为何使用RTOS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTOS%E7%B1%BB%E5%88%AB"><span class="toc-number">1.10.3.4.</span> <span class="toc-text">RTOS类别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%A0%87%E5%87%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E6%97%B6%E6%89%A9%E5%B1%95"><span class="toc-number">1.10.4.</span> <span class="toc-text">对于标准操作系统的实时扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%B5%81%E8%A1%8C%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.5.</span> <span class="toc-text">最流行的嵌入式操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E4%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.6.</span> <span class="toc-text">国产嵌入式操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.7.</span> <span class="toc-text">物联网操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%81%E6%B1%82-%E5%86%85%E5%AD%98-%E5%BC%82%E6%9E%84%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.10.7.1.</span> <span class="toc-text">物联网操作系统的要求-内存&#x2F;异构硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%81%E6%B1%82-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5-%E8%8A%82%E8%83%BD"><span class="toc-number">1.10.7.2.</span> <span class="toc-text">物联网操作系统的要求-网络连接&#x2F;节能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%81%E6%B1%82-%E5%AE%9E%E6%97%B6"><span class="toc-number">1.10.7.3.</span> <span class="toc-text">物联网操作系统的要求-实时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%81%E6%B1%82-%E5%AE%89%E5%85%A8"><span class="toc-number">1.10.7.4.</span> <span class="toc-text">物联网操作系统的要求-安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.10.8.</span> <span class="toc-text">调度模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.10.9.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.10.10.</span> <span class="toc-text">网络缓存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.10.11.</span> <span class="toc-text">编程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.10.12.</span> <span class="toc-text">编程语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82"><span class="toc-number">1.10.13.</span> <span class="toc-text">驱动模型和硬件抽象层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.10.14.</span> <span class="toc-text">调试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E9%9B%86"><span class="toc-number">1.10.15.</span> <span class="toc-text">特征集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.10.16.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB"><span class="toc-number">1.10.17.</span> <span class="toc-text">与物联网相关的操作系统分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-8-2-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">1.11.</span> <span class="toc-text">Lecture 8-2 - 实时调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E6%89%80%E9%9C%80%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">1.11.1.</span> <span class="toc-text">实时系统所需的调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.11.2.</span> <span class="toc-text">调度程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E5%88%86%E7%B1%BB-%E6%A0%B9%E6%8D%AE%E5%86%B3%E7%AD%96%E5%88%B6%E5%AE%9A%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.11.3.</span> <span class="toc-text">调度程序分类 - 根据决策制定的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.11.4.</span> <span class="toc-text">任务模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%91%A8%E6%9C%9F"><span class="toc-number">1.11.5.</span> <span class="toc-text">任务的周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">与任务执行相关的时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%99%90%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.11.6.</span> <span class="toc-text">时限约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.11.7.</span> <span class="toc-text">优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.11.7.1.</span> <span class="toc-text">非抢占式调度与抢占式调度程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">1.11.8.</span> <span class="toc-text">调度程序的度量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E8%B0%83%E5%BA%A6"><span class="toc-number">1.11.9.</span> <span class="toc-text">可行调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.11.10.</span> <span class="toc-text">利用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.11.11.</span> <span class="toc-text">延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E5%AE%8C%E6%88%90%E6%97%B6%E9%97%B4-%E6%80%BB%E6%97%B6%E7%A8%8B"><span class="toc-number">1.11.12.</span> <span class="toc-text">总完成时间&#x2F;总时程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%B0%83%E5%BA%A6%E4%B8%8E%E9%80%9A%E7%94%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">1.11.13.</span> <span class="toc-text">嵌入式调度与通用调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E4%BD%95%E6%97%B6%E8%A2%AB%E8%B0%83%E7%94%A8"><span class="toc-number">1.11.14.</span> <span class="toc-text">调度程序何时被调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-8-3-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6-%E8%B0%83%E5%BA%A6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.12.</span> <span class="toc-text">lecture 8-3 - 实时调度 - 调度异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.12.1.</span> <span class="toc-text">调度异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%99%91%E4%BA%92%E6%96%A5"><span class="toc-number">1.12.2.</span> <span class="toc-text">考虑互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PIP"><span class="toc-number">1.12.3.</span> <span class="toc-text">PIP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.12.4.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8A%E9%99%90%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.12.5.</span> <span class="toc-text">优先级上限协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OCPP-amp-ICPP"><span class="toc-number">1.12.5.1.</span> <span class="toc-text">OCPP &amp; ICPP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%86%E5%BC%B1%E6%80%A7"><span class="toc-number">1.12.6.</span> <span class="toc-text">脆弱性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Richard%E5%BC%82%E5%B8%B8"><span class="toc-number">1.12.7.</span> <span class="toc-text">Richard异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%A4%84%E7%90%86%E5%99%A8%E6%95%B0%E9%87%8F"><span class="toc-number">1.12.7.1.</span> <span class="toc-text">增加处理器数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E8%B0%83%E5%BA%A6"><span class="toc-number">1.12.7.2.</span> <span class="toc-text">贪心调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4"><span class="toc-number">1.12.7.3.</span> <span class="toc-text">减少计算时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%8C%96%E4%BC%98%E5%85%88%E5%BA%8F%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.12.7.4.</span> <span class="toc-text">弱化优先序约束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-9-1-%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.13.</span> <span class="toc-text">Lecture 9-1 - 实时内核-任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%C2%B5C-OS-II"><span class="toc-number">1.13.1.</span> <span class="toc-text">µC&#x2F;OS-II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AE%89%E5%85%A8%E6%80%A7%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81%E7%9A%84%E5%B8%82%E5%9C%BA%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">面向安全性至关重要的市场的可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-2"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.13.1.4.</span> <span class="toc-text">任务优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E5%92%8C%E7%BB%9F%E8%AE%A1%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.13.2.</span> <span class="toc-text">空闲任务和统计任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97TCB"><span class="toc-number">1.13.3.</span> <span class="toc-text">任务控制块TCB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%8C%87%E9%92%88"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">栈指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%8C%87%E9%92%88"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">链表指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2TCB%E9%93%BE%E8%A1%A8"><span class="toc-number">1.13.3.3.</span> <span class="toc-text">空闲TCB链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-%E6%8C%87%E5%90%91%E7%9B%B8%E5%BA%94TCB"><span class="toc-number">1.13.3.4.</span> <span class="toc-text">指针数组(指向相应TCB)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.13.4.</span> <span class="toc-text">状态的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%B0%B1%E7%BB%AA%E8%A1%A8"><span class="toc-number">1.13.5.</span> <span class="toc-text">任务就绪表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BC%98%E5%85%88%E7%BA%A7%E7%A1%AE%E5%AE%9A%E5%B0%B1%E7%BB%AA%E8%A1%A8"><span class="toc-number">1.13.5.1.</span> <span class="toc-text">根据优先级确定就绪表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E4%BB%BB%E5%8A%A1%E8%BF%9B%E5%85%A5%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="toc-number">1.13.6.</span> <span class="toc-text">使任务进入就绪态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E4%BB%BB%E5%8A%A1%E8%84%B1%E7%A6%BB%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="toc-number">1.13.7.</span> <span class="toc-text">使任务脱离就绪态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.13.8.</span> <span class="toc-text">任务的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.13.9.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%B0%B1%E7%BB%AA%E8%A1%A8%E7%A1%AE%E5%AE%9A%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.13.10.</span> <span class="toc-text">根据就绪表确定最高优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">1.13.10.1.</span> <span class="toc-text">源代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#freertos%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%A4%BA%E6%84%8F"><span class="toc-number">1.13.11.</span> <span class="toc-text">freertos的任务优先级调度示意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%BA%A7%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2OS-TASK-SW"><span class="toc-number">1.13.12.</span> <span class="toc-text">任务级的任务切换OS_TASK_SW()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2OS-TASK-SW-%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.13.12.1.</span> <span class="toc-text">任务切换OS_TASK_SW()的代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B8%8A%E9%94%81"><span class="toc-number">1.13.13.</span> <span class="toc-text">给调度器上锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-9-2-%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8-%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.14.</span> <span class="toc-text">lecture 9-2 - 实时内核-任务之间的通信与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97ECB"><span class="toc-number">1.14.1.</span> <span class="toc-text">事件控制块ECB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97ECB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">事件控制块ECB数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%92%8CISR%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.14.2.</span> <span class="toc-text">任务和ISR之间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8"><span class="toc-number">1.14.3.</span> <span class="toc-text">等待任务列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-10-bsp-bootloader"><span class="toc-number">1.15.</span> <span class="toc-text">- lecture 10 - bsp-bootloader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.15.1.</span> <span class="toc-text">嵌入式系统的启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bsp%EF%BC%8C%E7%89%B9%E7%82%B9%EF%BC%8C%E4%B8%8Ebios%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.2.</span> <span class="toc-text">bsp，特点，与bios区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.15.3.</span> <span class="toc-text">引导模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bootloader%E5%8F%8A%E5%85%B6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.15.4.</span> <span class="toc-text">bootloader及其启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture11-%E7%89%A9%E8%81%94%E2%BD%B9%E6%A6%82%E8%BF%B0"><span class="toc-number">1.16.</span> <span class="toc-text">Lecture11 - 物联⽹概述+</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.16.1.</span> <span class="toc-text">定义，术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOT%E7%89%B9%E5%BE%81"><span class="toc-number">1.16.2.</span> <span class="toc-text">IOT特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOT%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.16.3.</span> <span class="toc-text">IOT的优势和不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-3"><span class="toc-number">1.16.4.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture12-IoT-%E6%8A%80%E6%9C%AF"><span class="toc-number">1.17.</span> <span class="toc-text">lecture12 - IoT 技术+</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IoT%E5%A4%9A%E6%A0%B7%E5%8C%96%E7%9A%84%E6%8A%80%E6%9C%AF%E7%8E%AF%E5%A2%83"><span class="toc-number">1.17.1.</span> <span class="toc-text">IoT多样化的技术环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E8%81%94%E7%BD%91%E8%BD%AF%E4%BB%B6%E3%80%81%E7%A1%AC%E4%BB%B6%E3%80%81%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.17.2.</span> <span class="toc-text">物联网软件、硬件、连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E6%AD%A5%E6%9C%80%E5%BF%AB%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="toc-number">1.17.3.</span> <span class="toc-text">进步最快的技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoT%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.17.4.</span> <span class="toc-text">IoT面临的挑战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture13-IOT%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.18.</span> <span class="toc-text">lecture13 - IOT平台</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.18.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E9%A2%86%E5%9F%9F"><span class="toc-number">1.18.2.</span> <span class="toc-text">功能领域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture14-IOT%E5%B9%B3%E5%8F%B0%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="toc-number">1.19.</span> <span class="toc-text">lecture14 - IOT平台关键技术+</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%8C%E7%89%A9%E6%A8%A1%E5%9E%8B%E3%80%81%E8%AE%BE%E5%A4%87%E5%BD%B1%E5%AD%90%E3%80%81%E6%95%B0%E5%AD%97%E5%AD%AA%E7%94%9F%EF%BC%88%E6%A6%82%E5%BF%B5%E3%80%81%E4%BB%B7%E5%80%BC%EF%BC%89"><span class="toc-number">1.19.1.</span> <span class="toc-text">设备管理，主要功能，物模型、设备影子、数字孪生（概念、价值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97"><span class="toc-number">1.19.2.</span> <span class="toc-text">边缘计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.19.3.</span> <span class="toc-text">通信协议</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/eb3d82ea.html" title="数据库复习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/65d5936759cc46bdab99/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库复习"/></a><div class="content"><a class="title" href="/posts/eb3d82ea.html" title="数据库复习">数据库复习</a><time datetime="2024-06-11T09:01:46.000Z" title="发表于 2024-06-11 17:01:46">2024-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3a00daf2.html" title="最近听的歌第一期"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/365b81efc4ad4879a819/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="最近听的歌第一期"/></a><div class="content"><a class="title" href="/posts/3a00daf2.html" title="最近听的歌第一期">最近听的歌第一期</a><time datetime="2024-06-10T12:15:23.000Z" title="发表于 2024-06-10 20:15:23">2024-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c22f54fd.html" title="An Empirical Study on the Usage of Transformer Models for Code Completion"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/49fb0997934545dbae83/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="An Empirical Study on the Usage of Transformer Models for Code Completion"/></a><div class="content"><a class="title" href="/posts/c22f54fd.html" title="An Empirical Study on the Usage of Transformer Models for Code Completion">An Empirical Study on the Usage of Transformer Models for Code Completion</a><time datetime="2024-05-24T14:44:39.000Z" title="发表于 2024-05-24 22:44:39">2024-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6485cb09.html" title="ReACC: A Retrieval-Augmented Code Completion Framework"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/d6b6537b41be4d2fa9c0/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ReACC: A Retrieval-Augmented Code Completion Framework"/></a><div class="content"><a class="title" href="/posts/6485cb09.html" title="ReACC: A Retrieval-Augmented Code Completion Framework">ReACC: A Retrieval-Augmented Code Completion Framework</a><time datetime="2024-05-22T14:07:52.000Z" title="发表于 2024-05-22 22:07:52">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3dbfc87e.html" title="0516Honor笔试"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://box.nju.edu.cn/f/493b6ecb651f4dd99d71/?dl=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0516Honor笔试"/></a><div class="content"><a class="title" href="/posts/3dbfc87e.html" title="0516Honor笔试">0516Honor笔试</a><time datetime="2024-05-16T13:02:51.000Z" title="发表于 2024-05-16 21:02:51">2024-05-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Rain Sun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.rainsgy.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.rainsgy.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="8251277445" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = '9a4f31a8f3de9ac55803';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html><div id="sakana-widget" style="position:fixed;bottom:0px;right:0px;"></div><script>function initSakanaWidget() {
  new SakanaWidget().mount('#sakana-widget');
}</script><script async="" onload="initSakanaWidget()" src="https://cdn.jsdelivr.net/npm/sakana-widget@2.2.1/lib/sakana.min.js"></script>